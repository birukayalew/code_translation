DefId(0:899 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clzl)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {
    return (if n != 0 {
        n.leading_zeros() as i32 as libc::c_ulong
    } else {
        (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)
    }) as libc::c_int;
}
```
Here are its call sites
Call site 1:
```rust
return __gl_stdbit_clzl(n) as libc::c_uint;
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:904 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ul)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn stdc_leading_zeros_ul(mut n: libc::c_ulong) -> libc::c_uint {
    return __gl_stdbit_clzl(n) as libc::c_uint;
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1003 ~ rust[fc84]::src::xmalloc::_gl_alloc_nomem)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn _gl_alloc_nomem() -> *mut libc::c_void {
    *__errno_location() = 12 as libc::c_int;
    return 0 as *mut libc::c_void;
}
```
Here are its call sites
Call site 1:
```rust
return _gl_alloc_nomem();
```
Call site 2:
```rust
{
        return _gl_alloc_nomem()
    }
```
Call site 3:
```rust
return _gl_alloc_nomem();
```
Call site 4:
```rust
{
        return _gl_alloc_nomem()
    }
```
Call site 5:
```rust
{
        _gl_alloc_nomem()
    }
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1005 ~ rust[fc84]::src::xmalloc::check_nonnull)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {
    if p.is_null() {
        xalloc_die();
    }
    return p;
}
```
Here are its call sites
Call site 1:
```rust
return check_nonnull(imalloc(s));
```
Call site 2:
```rust
return check_nonnull(irealloc(p, s));
```
Call site 3:
```rust
return check_nonnull(calloc(n, s));
```
Call site 4:
```rust
return check_nonnull(ireallocarray(p, n, s));
```
Call site 5:
```rust
return check_nonnull(malloc(s));
```
Call site 6:
```rust
return check_nonnull(icalloc(n, s));
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1002 ~ rust[fc84]::src::xmalloc::ireallocarray)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn ireallocarray(
    mut p: *mut libc::c_void,
    mut n: idx_t,
    mut s: idx_t,
) -> *mut libc::c_void {
    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong
        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong
    {
        let mut nx: size_t = n as size_t;
        let mut sx: size_t = s as size_t;
        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long
        {
            sx = 1 as libc::c_int as size_t;
            nx = sx;
        }
        p = reallocarray(p, nx, sx);
        return p;
    } else {
        return _gl_alloc_nomem()
    };
}
```
Here are its call sites
Call site 1:
```rust
return check_nonnull(ireallocarray(p, n, s));
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1001 ~ rust[fc84]::src::xmalloc::icalloc)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {
    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {
        if s != 0 as libc::c_int as libc::c_long {
            return _gl_alloc_nomem();
        }
        n = 0 as libc::c_int as idx_t;
    }
    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {
        if n != 0 as libc::c_int as libc::c_long {
            return _gl_alloc_nomem();
        }
        s = 0 as libc::c_int as idx_t;
    }
    return calloc(n as libc::c_ulong, s as libc::c_ulong);
}
```
Here are its call sites
Call site 1:
```rust
return check_nonnull(icalloc(n, s));
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1011 ~ rust[fc84]::src::xmalloc::xreallocarray)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xreallocarray(
    mut p: *mut libc::c_void,
    mut n: size_t,
    mut s: size_t,
) -> *mut libc::c_void {
    let mut r: *mut libc::c_void = reallocarray(p, n, s);
    if r.is_null() && (p.is_null() || n != 0 && s != 0) {
        xalloc_die();
    }
    return r;
}
```
Here are its call sites
Call site 1:
```rust
p = xreallocarray(p, n, s);
```
Call site 2:
```rust
return xreallocarray(0 as *mut libc::c_void, n, s);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1004 ~ rust[fc84]::src::xmalloc::imalloc)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn imalloc(mut s: idx_t) -> *mut libc::c_void {
    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {
        malloc(s as libc::c_ulong)
    } else {
        _gl_alloc_nomem()
    };
}
```
Here are its call sites
Call site 1:
```rust
return check_nonnull(imalloc(s));
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1006 ~ rust[fc84]::src::xmalloc::xmalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xmalloc(mut s: size_t) -> *mut libc::c_void {
    return check_nonnull(malloc(s));
}
```
Here are its call sites
Call site 1:
```rust
return memcpy(xmalloc(s), p, s);
```
Call site 2:
```rust
{
        xmalloc(n)
    }
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1012 ~ rust[fc84]::src::xmalloc::xireallocarray)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xireallocarray(
    mut p: *mut libc::c_void,
    mut n: idx_t,
    mut s: idx_t,
) -> *mut libc::c_void {
    return check_nonnull(ireallocarray(p, n, s));
}
```
Here are its call sites
Call site 1:
```rust
return xireallocarray(0 as *mut libc::c_void, n, s);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1021 ~ rust[fc84]::src::xmalloc::xicalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {
    return check_nonnull(icalloc(n, s));
}
```
Here are its call sites
Call site 1:
```rust
return xicalloc(s, 1 as libc::c_int as idx_t);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1013 ~ rust[fc84]::src::xmalloc::xnmalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {
    return xreallocarray(0 as *mut libc::c_void, n, s);
}
```
Here are its call sites
Call site 1:
```rust
{
        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)
    }
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1020 ~ rust[fc84]::src::xmalloc::xcalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {
    return check_nonnull(calloc(n, s));
}
```
Here are its call sites
Call site 1:
```rust
return xcalloc(s, 1 as libc::c_int as size_t);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1000 ~ rust[fc84]::src::xmalloc::irealloc)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn irealloc(
    mut p: *mut libc::c_void,
    mut s: idx_t,
) -> *mut libc::c_void {
    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {
        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);
        return p;
    } else {
        return _gl_alloc_nomem()
    };
}
```
Here are its call sites
Call site 1:
```rust
return check_nonnull(irealloc(p, s));
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1016 ~ rust[fc84]::src::xmalloc::x2nrealloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn x2nrealloc(
    mut p: *mut libc::c_void,
    mut pn: *mut size_t,
    mut s: size_t,
) -> *mut libc::c_void {
    let mut n: size_t = *pn;
    if p.is_null() {
        if n == 0 {
            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);
            n = (n as libc::c_ulong)
                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t
                as size_t;
        }
    } else {
        let (fresh0, fresh1) = n
            .overflowing_add(
                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),
            );
        *(&mut n as *mut size_t) = fresh0;
        if fresh1 {
            xalloc_die();
        }
    }
    p = xreallocarray(p, n, s);
    *pn = n;
    return p;
}
```
Here are its call sites
Call site 1:
```rust
return x2nrealloc(p, ps, 1 as libc::c_int as size_t);
```
The function uses the following global variables:
```rust
pub const DEFAULT_MXFAST: C2RustUnnamed = 128;
```
The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1007 ~ rust[fc84]::src::xmalloc::ximalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {
    return check_nonnull(imalloc(s));
}
```
Here are its call sites
Call site 1:
```rust
let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)
        as *mut libc::c_char;
```
Call site 2:
```rust
return memcpy(ximalloc(s), p, s as libc::c_ulong);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1022 ~ rust[fc84]::src::xmalloc::xmemdup)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xmemdup(
    mut p: *const libc::c_void,
    mut s: size_t,
) -> *mut libc::c_void {
    return memcpy(xmalloc(s), p, s);
}
```
Here are its call sites
Call site 1:
```rust
return xmemdup(
        string as *const libc::c_void,
        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),
    ) as *mut libc::c_char;
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1014 ~ rust[fc84]::src::xmalloc::xinmalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {
    return xireallocarray(0 as *mut libc::c_void, n, s);
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1019 ~ rust[fc84]::src::xmalloc::xizalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {
    return xicalloc(s, 1 as libc::c_int as idx_t);
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::vec::Vec;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1008 ~ rust[fc84]::src::xmalloc::xcharalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {
    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong
        == 1 as libc::c_int as libc::c_ulong
    {
        xmalloc(n)
    } else {
        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)
    }) as *mut libc::c_char;
}
```


The file contains the following imports:
```rust
Layout
```
```rust
use ::libc;
```
```rust
dealloc
```
```rust
use std::alloc::{alloc, dealloc, Layout};
```
```rust
alloc
```
```rust
use std::vec::Vec;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1018 ~ rust[fc84]::src::xmalloc::xzalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xzalloc(mut s: size_t) -> *mut libc::c_void {
    return xcalloc(s, 1 as libc::c_int as size_t);
}
```


The file contains the following imports:
```rust
use std::alloc::{alloc, dealloc, Layout};
```
```rust
dealloc
```
```rust
Layout
```
```rust
use std::vec::Vec;
```
```rust
use ::libc;
```
```rust
alloc
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1010 ~ rust[fc84]::src::xmalloc::xirealloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xirealloc(
    mut p: *mut libc::c_void,
    mut s: idx_t,
) -> *mut libc::c_void {
    return check_nonnull(irealloc(p, s));
}
```


The file contains the following imports:
```rust
alloc
```
```rust
Layout
```
```rust
use std::vec::Vec;
```
```rust
dealloc
```
```rust
use std::alloc::{alloc, dealloc, Layout};
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1015 ~ rust[fc84]::src::xmalloc::x2realloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn x2realloc(
    mut p: *mut libc::c_void,
    mut ps: *mut size_t,
) -> *mut libc::c_void {
    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);
}
```


The file contains the following imports:
```rust
use std::alloc::{alloc, dealloc, Layout};
```
```rust
use ::libc;
```
```rust
Layout
```
```rust
dealloc
```
```rust
alloc
```
```rust
use std::vec::Vec;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1024 ~ rust[fc84]::src::xmalloc::ximemdup0)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn ximemdup0(
    mut p: *const libc::c_void,
    mut s: idx_t,
) -> *mut libc::c_char {
    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)
        as *mut libc::c_char;
    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;
    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)
        as *mut libc::c_char;
}
```


The file contains the following imports:
```rust
alloc
```
```rust
use std::vec::Vec;
```
```rust
Layout
```
```rust
use ::libc;
```
```rust
use std::alloc::{alloc, dealloc, Layout};
```
```rust
dealloc
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1025 ~ rust[fc84]::src::xmalloc::xstrdup)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {
    return xmemdup(
        string as *const libc::c_void,
        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),
    ) as *mut libc::c_char;
}
```


The file contains the following imports:
```rust
Layout
```
```rust
use std::alloc::{alloc, dealloc, Layout};
```
```rust
use std::vec::Vec;
```
```rust
dealloc
```
```rust
alloc
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1023 ~ rust[fc84]::src::xmalloc::ximemdup)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn ximemdup(
    mut p: *const libc::c_void,
    mut s: idx_t,
) -> *mut libc::c_void {
    return memcpy(ximalloc(s), p, s as libc::c_ulong);
}
```


The file contains the following imports:
```rust
Layout
```
```rust
use std::vec::Vec;
```
```rust
use std::alloc::{alloc, dealloc, Layout};
```
```rust
use std::string::String;
```
```rust
use ::libc;
```
```rust
alloc
```
```rust
dealloc
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:275 ~ rust[fc84]::src::ialloc::_gl_alloc_nomem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn _gl_alloc_nomem() -> *mut libc::c_void {
    *__errno_location() = 12 as libc::c_int;
    return 0 as *mut libc::c_void;
}
```
Here are its call sites
Call site 1:
```rust
{
        return _gl_alloc_nomem()
    }
```
Call site 2:
```rust
{
        _gl_alloc_nomem()
    }
```
Call site 3:
```rust
{
        return _gl_alloc_nomem()
    }
```
Call site 4:
```rust
return _gl_alloc_nomem();
```
Call site 5:
```rust
return _gl_alloc_nomem();
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:273 ~ rust[fc84]::src::ialloc::irealloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn irealloc(
    mut p: *mut libc::c_void,
    mut s: idx_t,
) -> *mut libc::c_void {
    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {
        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);
        return p;
    } else {
        return _gl_alloc_nomem()
    };
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:272 ~ rust[fc84]::src::ialloc::icalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {
    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {
        if s != 0 as libc::c_int as libc::c_long {
            return _gl_alloc_nomem();
        }
        n = 0 as libc::c_int as idx_t;
    }
    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {
        if n != 0 as libc::c_int as libc::c_long {
            return _gl_alloc_nomem();
        }
        s = 0 as libc::c_int as idx_t;
    }
    return calloc(n as libc::c_ulong, s as libc::c_ulong);
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::vec::Vec;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:274 ~ rust[fc84]::src::ialloc::imalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn imalloc(mut s: idx_t) -> *mut libc::c_void {
    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {
        malloc(s as libc::c_ulong)
    } else {
        _gl_alloc_nomem()
    };
}
```


The file contains the following imports:
```rust
use std::vec::Vec;
```
```rust
use std::option::Option;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:271 ~ rust[fc84]::src::ialloc::ireallocarray)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn ireallocarray(
    mut p: *mut libc::c_void,
    mut n: idx_t,
    mut s: idx_t,
) -> *mut libc::c_void {
    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong
        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong
    {
        let mut nx: size_t = n as size_t;
        let mut sx: size_t = s as size_t;
        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long
        {
            sx = 1 as libc::c_int as size_t;
            nx = sx;
        }
        p = reallocarray(p, nx, sx);
        return p;
    } else {
        return _gl_alloc_nomem()
    };
}
```


The file contains the following imports:
```rust
use std::alloc::Layout;
```
```rust
use std::option::Option;
```
```rust
use std::vec::Vec;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:971 ~ rust[fc84]::src::xalloc_die::xalloc_die)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xalloc_die() {
    if 0 != 0 {
        error(
            exit_failure,
            0 as libc::c_int,
            b"%s\0" as *const u8 as *const libc::c_char,
            gettext(b"memory exhausted\0" as *const u8 as *const libc::c_char),
        );
        if exit_failure != 0 as libc::c_int {
            unreachable!();
        } else {};
    } else {
        ({
            let __errstatus: libc::c_int = exit_failure;
            error(
                __errstatus,
                0 as libc::c_int,
                b"%s\0" as *const u8 as *const libc::c_char,
                gettext(b"memory exhausted\0" as *const u8 as *const libc::c_char),
            );
            if __errstatus != 0 as libc::c_int {
                unreachable!();
            } else {};
            
        });
        ({
            let __errstatus: libc::c_int = exit_failure;
            error(
                __errstatus,
                0 as libc::c_int,
                b"%s\0" as *const u8 as *const libc::c_char,
                gettext(b"memory exhausted\0" as *const u8 as *const libc::c_char),
            );
            if __errstatus != 0 as libc::c_int {
                unreachable!();
            } else {};
            
        });
    };
    abort();
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:683 ~ rust[fc84]::src::mbrtoc32::mbszero)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn mbszero(mut ps: *mut mbstate_t) {
    memset(
        ps as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,
    );
}
```
Here are its call sites
Call site 1:
```rust
mbszero(ps);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:685 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn rpl_mbrtoc32(
    mut pwc: *mut char32_t,
    mut s: *const libc::c_char,
    mut n: size_t,
    mut ps: *mut mbstate_t,
) -> size_t {
    if s.is_null() {
        pwc = 0 as *mut char32_t;
        s = b"\0" as *const u8 as *const libc::c_char;
        n = 1 as libc::c_int as size_t;
    }
    if ps.is_null() {
        ps = &mut internal_state;
    }
    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);
    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {
        mbszero(ps);
    }
    if ret == -(3 as libc::c_int) as size_t {
        abort();
    }
    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong
        && !hard_locale(0 as libc::c_int)
    {
        if !pwc.is_null() {
            *pwc = *s as libc::c_uchar as char32_t;
        }
        return 1 as libc::c_int as size_t;
    }
    return ret;
}
```

The function uses the following global variables:
```rust
static mut internal_state: mbstate_t = mbstate_t {
    __count: 0,
    __value: C2RustUnnamed { __wch: 0 },
};
```
The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:39 ~ rust[fc84]::src::c_ctype::c_isupper)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_isupper(mut c: libc::c_int) -> bool {
    match c {
        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80
        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:798 ~ rust[fc84]::src::quotearg::gettext_quote)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn gettext_quote(
    mut msgid: *const libc::c_char,
    mut s: quoting_style,
) -> *const libc::c_char {
    let mut translation: *const libc::c_char = gettext(msgid);
    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;
    if translation != msgid {
        return translation;
    }
    locale_code = locale_charset();
    if c_strcasecmp(locale_code, b"UTF-8\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {
            b"\xE2\x80\x98\0" as *const u8 as *const libc::c_char
        } else {
            b"\xE2\x80\x99\0" as *const u8 as *const libc::c_char
        };
    }
    if c_strcasecmp(locale_code, b"GB18030\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {
            b"\xA1\x07e\0" as *const u8 as *const libc::c_char
        } else {
            b"\xA1\xAF\0" as *const u8 as *const libc::c_char
        };
    }
    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {
        b"\"\0" as *const u8 as *const libc::c_char
    } else {
        b"'\0" as *const u8 as *const libc::c_char
    };
}
```
Here are its call sites
Call site 1:
```rust
right_quote = gettext_quote(
                        b"'\0" as *const u8 as *const libc::c_char,
                        quoting_style,
                    );
```
Call site 2:
```rust
left_quote = gettext_quote(
                        b"`\0" as *const u8 as *const libc::c_char,
                        quoting_style,
                    );
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:799 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn quotearg_buffer_restyled(
    mut buffer: *mut libc::c_char,
    mut buffersize: size_t,
    mut arg: *const libc::c_char,
    mut argsize: size_t,
    mut quoting_style: quoting_style,
    mut flags: libc::c_int,
    mut quote_these_too: *const libc::c_uint,
    mut left_quote: *const libc::c_char,
    mut right_quote: *const libc::c_char,
) -> size_t {
    let mut pending_shell_escape_end: bool = false;
    let mut current_block: u64;
    let mut i: size_t = 0;
    let mut len: size_t = 0 as libc::c_int as size_t;
    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;
    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;
    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;
    let mut backslash_escapes: bool = 0 as libc::c_int != 0;
    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()
        == 1 as libc::c_int as libc::c_ulong;
    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int
        != 0 as libc::c_int;
    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;
    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;
    's_25: loop {
        pending_shell_escape_end = 0 as libc::c_int != 0;
        let mut current_block_48: u64;
        match quoting_style as libc::c_uint {
            6 => {
                quoting_style = c_quoting_style;
                elide_outer_quotes = 1 as libc::c_int != 0;
                current_block_48 = 1283995450065962895;
            }
            5 => {
                current_block_48 = 1283995450065962895;
            }
            7 => {
                backslash_escapes = 1 as libc::c_int != 0;
                elide_outer_quotes = 0 as libc::c_int != 0;
                current_block_48 = 2989495919056355252;
            }
            8 | 9 | 10 => {
                if quoting_style as libc::c_uint
                    != custom_quoting_style as libc::c_int as libc::c_uint
                {
                    left_quote = gettext_quote(
                        b"`\0" as *const u8 as *const libc::c_char,
                        quoting_style,
                    );
                    right_quote = gettext_quote(
                        b"'\0" as *const u8 as *const libc::c_char,
                        quoting_style,
                    );
                }
                if !elide_outer_quotes {
                    quote_string = left_quote;
                    while *quote_string != 0 {
                        if len < buffersize {
                            *buffer.offset(len as isize) = *quote_string;
                        }
                        len = len.wrapping_add(1);
                        len;
                        quote_string = quote_string.offset(1);
                        quote_string;
                    }
                }
                backslash_escapes = 1 as libc::c_int != 0;
                quote_string = right_quote;
                quote_string_len = strlen(quote_string);
                current_block_48 = 2989495919056355252;
            }
            3 => {
                backslash_escapes = 1 as libc::c_int != 0;
                current_block_48 = 2694013637280298776;
            }
            1 => {
                current_block_48 = 2694013637280298776;
            }
            4 => {
                current_block_48 = 2266290538919981374;
            }
            2 => {
                current_block_48 = 14141891332124833771;
            }
            0 => {
                elide_outer_quotes = 0 as libc::c_int != 0;
                current_block_48 = 2989495919056355252;
            }
            _ => {
                abort();
            }
        }
        match current_block_48 {
            1283995450065962895 => {
                if !elide_outer_quotes {
                    if len < buffersize {
                        *buffer.offset(len as isize) = '"' as i32 as libc::c_char;
                    }
                    len = len.wrapping_add(1);
                    len;
                }
                backslash_escapes = 1 as libc::c_int != 0;
                quote_string = b"\"\0" as *const u8 as *const libc::c_char;
                quote_string_len = 1 as libc::c_int as size_t;
                current_block_48 = 2989495919056355252;
            }
            2694013637280298776 => {
                elide_outer_quotes = 1 as libc::c_int != 0;
                current_block_48 = 2266290538919981374;
            }
            _ => {}
        }
        match current_block_48 {
            2266290538919981374 => {
                if !elide_outer_quotes {
                    backslash_escapes = 1 as libc::c_int != 0;
                }
                current_block_48 = 14141891332124833771;
            }
            _ => {}
        }
        match current_block_48 {
            14141891332124833771 => {
                quoting_style = shell_always_quoting_style;
                if !elide_outer_quotes {
                    if len < buffersize {
                        *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                    }
                    len = len.wrapping_add(1);
                    len;
                }
                quote_string = b"'\0" as *const u8 as *const libc::c_char;
                quote_string_len = 1 as libc::c_int as size_t;
            }
            _ => {}
        }
        i = 0 as libc::c_int as size_t;
        while if argsize == 18446744073709551615 as libc::c_ulong {
            (*arg.offset(i as isize) as libc::c_int == '\0' as i32) as libc::c_int
        } else {
            (i == argsize) as libc::c_int
        } == 0
        {
            let mut c: libc::c_uchar = 0;
            let mut esc: libc::c_uchar = 0;
            let mut is_right_quote: bool = 0 as libc::c_int != 0;
            let mut escaping: bool = 0 as libc::c_int != 0;
            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;
            if backslash_escapes as libc::c_int != 0
                && quoting_style as libc::c_uint
                    != shell_always_quoting_style as libc::c_int as libc::c_uint
                && quote_string_len != 0
                && i.wrapping_add(quote_string_len)
                    <= (if argsize == 18446744073709551615 as libc::c_ulong
                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len
                    {
                        argsize = strlen(arg);
                        argsize
                    } else {
                        argsize
                    })
                && memcmp(
                    arg.offset(i as isize) as *const libc::c_void,
                    quote_string as *const libc::c_void,
                    quote_string_len,
                ) == 0 as libc::c_int
            {
                if elide_outer_quotes {
                    current_block = 7928555609993211441;
                    break 's_25;
                }
                is_right_quote = 1 as libc::c_int != 0;
            }
            c = *arg.offset(i as isize) as libc::c_uchar;
            match c as libc::c_int {
                0 => {
                    if backslash_escapes {
                        if elide_outer_quotes {
                            current_block = 7928555609993211441;
                            break 's_25;
                        }
                        escaping = 1 as libc::c_int != 0;
                        if quoting_style as libc::c_uint
                            == shell_always_quoting_style as libc::c_int as libc::c_uint
                            && !pending_shell_escape_end
                        {
                            if len < buffersize {
                                *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                            }
                            len = len.wrapping_add(1);
                            len;
                            if len < buffersize {
                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;
                            }
                            len = len.wrapping_add(1);
                            len;
                            if len < buffersize {
                                *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                            }
                            len = len.wrapping_add(1);
                            len;
                            pending_shell_escape_end = 1 as libc::c_int != 0;
                        }
                        if len < buffersize {
                            *buffer.offset(len as isize) = '\\' as i32 as libc::c_char;
                        }
                        len = len.wrapping_add(1);
                        len;
                        if quoting_style as libc::c_uint
                            != shell_always_quoting_style as libc::c_int as libc::c_uint
                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)
                                < argsize
                            && '0' as i32
                                <= *arg
                                    .offset(
                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                                    ) as libc::c_int
                            && *arg
                                .offset(
                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                                ) as libc::c_int <= '9' as i32
                        {
                            if len < buffersize {
                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;
                            }
                            len = len.wrapping_add(1);
                            len;
                            if len < buffersize {
                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;
                            }
                            len = len.wrapping_add(1);
                            len;
                        }
                        c = '0' as i32 as libc::c_uchar;
                        current_block = 253337042034819032;
                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {
                        current_block = 13619784596304402172;
                    } else {
                        current_block = 253337042034819032;
                    }
                }
                63 => {
                    match quoting_style as libc::c_uint {
                        2 => {
                            current_block = 17954593875197965021;
                            match current_block {
                                17954593875197965021 => {
                                    if elide_outer_quotes {
                                        current_block = 7928555609993211441;
                                        break 's_25;
                                    }
                                }
                                _ => {
                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0
                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)
                                            < argsize
                                        && *arg
                                            .offset(
                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                                            ) as libc::c_int == '?' as i32
                                    {
                                        match *arg
                                            .offset(
                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,
                                            ) as libc::c_int
                                        {
                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {
                                                if elide_outer_quotes {
                                                    current_block = 7928555609993211441;
                                                    break 's_25;
                                                }
                                                c = *arg
                                                    .offset(
                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,
                                                    ) as libc::c_uchar;
                                                i = (i as libc::c_ulong)
                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t
                                                    as size_t;
                                                if len < buffersize {
                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;
                                                }
                                                len = len.wrapping_add(1);
                                                len;
                                                if len < buffersize {
                                                    *buffer.offset(len as isize) = '"' as i32 as libc::c_char;
                                                }
                                                len = len.wrapping_add(1);
                                                len;
                                                if len < buffersize {
                                                    *buffer.offset(len as isize) = '"' as i32 as libc::c_char;
                                                }
                                                len = len.wrapping_add(1);
                                                len;
                                                if len < buffersize {
                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;
                                                }
                                                len = len.wrapping_add(1);
                                                len;
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                            current_block = 253337042034819032;
                        }
                        5 => {
                            current_block = 14514781131754033399;
                            match current_block {
                                17954593875197965021 => {
                                    if elide_outer_quotes {
                                        current_block = 7928555609993211441;
                                        break 's_25;
                                    }
                                }
                                _ => {
                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0
                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)
                                            < argsize
                                        && *arg
                                            .offset(
                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,
                                            ) as libc::c_int == '?' as i32
                                    {
                                        match *arg
                                            .offset(
                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,
                                            ) as libc::c_int
                                        {
                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {
                                                if elide_outer_quotes {
                                                    current_block = 7928555609993211441;
                                                    break 's_25;
                                                }
                                                c = *arg
                                                    .offset(
                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,
                                                    ) as libc::c_uchar;
                                                i = (i as libc::c_ulong)
                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t
                                                    as size_t;
                                                if len < buffersize {
                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;
                                                }
                                                len = len.wrapping_add(1);
                                                len;
                                                if len < buffersize {
                                                    *buffer.offset(len as isize) = '"' as i32 as libc::c_char;
                                                }
                                                len = len.wrapping_add(1);
                                                len;
                                                if len < buffersize {
                                                    *buffer.offset(len as isize) = '"' as i32 as libc::c_char;
                                                }
                                                len = len.wrapping_add(1);
                                                len;
                                                if len < buffersize {
                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;
                                                }
                                                len = len.wrapping_add(1);
                                                len;
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                            current_block = 253337042034819032;
                        }
                        _ => {
                            current_block = 253337042034819032;
                        }
                    }
                }
                7 => {
                    esc = 'a' as i32 as libc::c_uchar;
                    current_block = 1190876092451756080;
                }
                8 => {
                    esc = 'b' as i32 as libc::c_uchar;
                    current_block = 1190876092451756080;
                }
                12 => {
                    esc = 'f' as i32 as libc::c_uchar;
                    current_block = 1190876092451756080;
                }
                10 => {
                    esc = 'n' as i32 as libc::c_uchar;
                    current_block = 9215498979640025612;
                }
                13 => {
                    esc = 'r' as i32 as libc::c_uchar;
                    current_block = 9215498979640025612;
                }
                9 => {
                    esc = 't' as i32 as libc::c_uchar;
                    current_block = 9215498979640025612;
                }
                11 => {
                    esc = 'v' as i32 as libc::c_uchar;
                    current_block = 1190876092451756080;
                }
                92 => {
                    esc = c;
                    if quoting_style as libc::c_uint
                        == shell_always_quoting_style as libc::c_int as libc::c_uint
                    {
                        if elide_outer_quotes {
                            current_block = 7928555609993211441;
                            break 's_25;
                        }
                        current_block = 4476262310586904498;
                    } else if backslash_escapes as libc::c_int != 0
                        && elide_outer_quotes as libc::c_int != 0
                        && quote_string_len != 0
                    {
                        current_block = 4476262310586904498;
                    } else {
                        current_block = 9215498979640025612;
                    }
                }
                123 | 125 => {
                    if if argsize == 18446744073709551615 as libc::c_ulong {
                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int
                            == '\0' as i32) as libc::c_int
                    } else {
                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int
                    } == 0
                    {
                        current_block = 253337042034819032;
                    } else {
                        current_block = 16442922512115311366;
                    }
                }
                35 | 126 => {
                    current_block = 16442922512115311366;
                }
                32 => {
                    current_block = 4634307283396172174;
                }
                33 => {
                    current_block = 7549413860336125482;
                }
                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {
                    current_block = 13059411171234995867;
                }
                62 | 91 | 94 => {
                    current_block = 16620298045565028098;
                }
                96 | 124 => {
                    current_block = 15155215915847730705;
                }
                39 => {
                    encountered_single_quote = 1 as libc::c_int != 0;
                    c_and_shell_quote_compat = 1 as libc::c_int != 0;
                    if quoting_style as libc::c_uint
                        == shell_always_quoting_style as libc::c_int as libc::c_uint
                    {
                        if elide_outer_quotes {
                            current_block = 7928555609993211441;
                            break 's_25;
                        }
                        if buffersize != 0 && orig_buffersize == 0 {
                            orig_buffersize = buffersize;
                            buffersize = 0 as libc::c_int as size_t;
                        }
                        if len < buffersize {
                            *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                        }
                        len = len.wrapping_add(1);
                        len;
                        if len < buffersize {
                            *buffer.offset(len as isize) = '\\' as i32 as libc::c_char;
                        }
                        len = len.wrapping_add(1);
                        len;
                        if len < buffersize {
                            *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                        }
                        len = len.wrapping_add(1);
                        len;
                        pending_shell_escape_end = 0 as libc::c_int != 0;
                        current_block = 253337042034819032;
                    } else {
                        current_block = 253337042034819032;
                    }
                }
                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56
                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76
                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90
                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107
                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119
                | 120 | 121 | 122 => {
                    c_and_shell_quote_compat = 1 as libc::c_int != 0;
                    current_block = 253337042034819032;
                }
                _ => {
                    let mut m: size_t = 0;
                    let mut printable: bool = false;
                    if unibyte_locale {
                        m = 1 as libc::c_int as size_t;
                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)
                            as libc::c_int
                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int
                            != 0 as libc::c_int;
                    } else {
                        let mut mbstate: mbstate_t = mbstate_t {
                            __count: 0,
                            __value: C2RustUnnamed { __wch: 0 },
                        };
                        mbszero(&mut mbstate);
                        m = 0 as libc::c_int as size_t;
                        printable = 1 as libc::c_int != 0;
                        if argsize == 18446744073709551615 as libc::c_ulong {
                            argsize = strlen(arg);
                        }
                        let mut w: char32_t = 0;
                        let mut bytes: size_t = rpl_mbrtoc32(
                            &mut w,
                            &*arg.offset(i.wrapping_add(m) as isize),
                            argsize.wrapping_sub(i.wrapping_add(m)),
                            &mut mbstate,
                        );
                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {
                            if bytes == -(1 as libc::c_int) as size_t {
                                printable = 0 as libc::c_int != 0;
                            } else if bytes == -(2 as libc::c_int) as size_t {
                                printable = 0 as libc::c_int != 0;
                                while i.wrapping_add(m) < argsize
                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int
                                        != 0
                                {
                                    m = m.wrapping_add(1);
                                    m;
                                }
                            } else {
                                if '[' as i32 == 0x5b as libc::c_int
                                    && elide_outer_quotes as libc::c_int != 0
                                    && quoting_style as libc::c_uint
                                        == shell_always_quoting_style as libc::c_int as libc::c_uint
                                {
                                    let mut j: size_t = 0;
                                    j = 1 as libc::c_int as size_t;
                                    while j < bytes {
                                        match *arg
                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)
                                            as libc::c_int
                                        {
                                            91 | 92 | 94 | 96 | 124 => {
                                                current_block = 7928555609993211441;
                                                break 's_25;
                                            }
                                            _ => {}
                                        }
                                        j = j.wrapping_add(1);
                                        j;
                                    }
                                }
                                if c32isprint(w) == 0 {
                                    printable = 0 as libc::c_int != 0;
                                }
                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t
                                    as size_t;
                            }
                        }
                    }
                    c_and_shell_quote_compat = printable;
                    if (1 as libc::c_int as libc::c_ulong) < m
                        || backslash_escapes as libc::c_int != 0 && !printable
                    {
                        let mut ilim: size_t = i.wrapping_add(m);
                        loop {
                            if backslash_escapes as libc::c_int != 0 && !printable {
                                if elide_outer_quotes {
                                    current_block = 7928555609993211441;
                                    break 's_25;
                                }
                                escaping = 1 as libc::c_int != 0;
                                if quoting_style as libc::c_uint
                                    == shell_always_quoting_style as libc::c_int as libc::c_uint
                                    && !pending_shell_escape_end
                                {
                                    if len < buffersize {
                                        *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                                    }
                                    len = len.wrapping_add(1);
                                    len;
                                    if len < buffersize {
                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;
                                    }
                                    len = len.wrapping_add(1);
                                    len;
                                    if len < buffersize {
                                        *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                                    }
                                    len = len.wrapping_add(1);
                                    len;
                                    pending_shell_escape_end = 1 as libc::c_int != 0;
                                }
                                if len < buffersize {
                                    *buffer.offset(len as isize) = '\\' as i32 as libc::c_char;
                                }
                                len = len.wrapping_add(1);
                                len;
                                if len < buffersize {
                                    *buffer
                                        .offset(
                                            len as isize,
                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))
                                        as libc::c_char;
                                }
                                len = len.wrapping_add(1);
                                len;
                                if len < buffersize {
                                    *buffer
                                        .offset(
                                            len as isize,
                                        ) = ('0' as i32
                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))
                                        as libc::c_char;
                                }
                                len = len.wrapping_add(1);
                                len;
                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))
                                    as libc::c_uchar;
                            } else if is_right_quote {
                                if len < buffersize {
                                    *buffer.offset(len as isize) = '\\' as i32 as libc::c_char;
                                }
                                len = len.wrapping_add(1);
                                len;
                                is_right_quote = 0 as libc::c_int != 0;
                            }
                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)
                            {
                                break;
                            }
                            if pending_shell_escape_end as libc::c_int != 0 && !escaping
                            {
                                if len < buffersize {
                                    *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                                }
                                len = len.wrapping_add(1);
                                len;
                                if len < buffersize {
                                    *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                                }
                                len = len.wrapping_add(1);
                                len;
                                pending_shell_escape_end = 0 as libc::c_int != 0;
                            }
                            if len < buffersize {
                                *buffer.offset(len as isize) = c as libc::c_char;
                            }
                            len = len.wrapping_add(1);
                            len;
                            i = i.wrapping_add(1);
                            c = *arg.offset(i as isize) as libc::c_uchar;
                        }
                        current_block = 4476262310586904498;
                    } else {
                        current_block = 253337042034819032;
                    }
                }
            }
            match current_block {
                16442922512115311366 => {
                    if i != 0 as libc::c_int as libc::c_ulong {
                        current_block = 253337042034819032;
                    } else {
                        current_block = 4634307283396172174;
                    }
                }
                9215498979640025612 => {
                    if quoting_style as libc::c_uint
                        == shell_always_quoting_style as libc::c_int as libc::c_uint
                        && elide_outer_quotes as libc::c_int != 0
                    {
                        current_block = 7928555609993211441;
                        break 's_25;
                    }
                    current_block = 1190876092451756080;
                }
                _ => {}
            }
            match current_block {
                1190876092451756080 => {
                    if backslash_escapes {
                        c = esc;
                        current_block = 3173013908131212616;
                    } else {
                        current_block = 253337042034819032;
                    }
                }
                4634307283396172174 => {
                    c_and_shell_quote_compat = 1 as libc::c_int != 0;
                    current_block = 7549413860336125482;
                }
                _ => {}
            }
            match current_block {
                7549413860336125482 => {
                    current_block = 13059411171234995867;
                }
                _ => {}
            }
            match current_block {
                13059411171234995867 => {
                    current_block = 16620298045565028098;
                }
                _ => {}
            }
            match current_block {
                16620298045565028098 => {
                    current_block = 15155215915847730705;
                }
                _ => {}
            }
            match current_block {
                15155215915847730705 => {
                    if quoting_style as libc::c_uint
                        == shell_always_quoting_style as libc::c_int as libc::c_uint
                        && elide_outer_quotes as libc::c_int != 0
                    {
                        current_block = 7928555609993211441;
                        break 's_25;
                    }
                    current_block = 253337042034819032;
                }
                _ => {}
            }
            match current_block {
                253337042034819032 => {
                    if !((backslash_escapes as libc::c_int != 0
                        && quoting_style as libc::c_uint
                            != shell_always_quoting_style as libc::c_int as libc::c_uint
                        || elide_outer_quotes as libc::c_int != 0)
                        && !quote_these_too.is_null()
                        && *quote_these_too
                            .offset(
                                (c as libc::c_ulong)
                                    .wrapping_div(
                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),
                                    ) as isize,
                            )
                            >> (c as libc::c_ulong)
                                .wrapping_rem(
                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),
                                ) & 1 as libc::c_int as libc::c_uint != 0)
                        && !is_right_quote
                    {
                        current_block = 4476262310586904498;
                    } else {
                        current_block = 3173013908131212616;
                    }
                }
                _ => {}
            }
            match current_block {
                3173013908131212616 => {
                    if elide_outer_quotes {
                        current_block = 7928555609993211441;
                        break 's_25;
                    }
                    escaping = 1 as libc::c_int != 0;
                    if quoting_style as libc::c_uint
                        == shell_always_quoting_style as libc::c_int as libc::c_uint
                        && !pending_shell_escape_end
                    {
                        if len < buffersize {
                            *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                        }
                        len = len.wrapping_add(1);
                        len;
                        if len < buffersize {
                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;
                        }
                        len = len.wrapping_add(1);
                        len;
                        if len < buffersize {
                            *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                        }
                        len = len.wrapping_add(1);
                        len;
                        pending_shell_escape_end = 1 as libc::c_int != 0;
                    }
                    if len < buffersize {
                        *buffer.offset(len as isize) = '\\' as i32 as libc::c_char;
                    }
                    len = len.wrapping_add(1);
                    len;
                    current_block = 4476262310586904498;
                }
                _ => {}
            }
            match current_block {
                4476262310586904498 => {
                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {
                        if len < buffersize {
                            *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                        }
                        len = len.wrapping_add(1);
                        len;
                        if len < buffersize {
                            *buffer.offset(len as isize) = '\'' as i32 as libc::c_char;
                        }
                        len = len.wrapping_add(1);
                        len;
                        pending_shell_escape_end = 0 as libc::c_int != 0;
                    }
                    if len < buffersize {
                        *buffer.offset(len as isize) = c as libc::c_char;
                    }
                    len = len.wrapping_add(1);
                    len;
                    if !c_and_shell_quote_compat {
                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;
                    }
                }
                _ => {}
            }
            i = i.wrapping_add(1);
            i;
        }
        if len == 0 as libc::c_int as libc::c_ulong
            && quoting_style as libc::c_uint
                == shell_always_quoting_style as libc::c_int as libc::c_uint
            && elide_outer_quotes as libc::c_int != 0
        {
            current_block = 7928555609993211441;
            break;
        }
        if !(quoting_style as libc::c_uint
            == shell_always_quoting_style as libc::c_int as libc::c_uint
            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)
        {
            current_block = 6412618891452676311;
            break;
        }
        if all_c_and_shell_quote_compat {
            return quotearg_buffer_restyled(
                buffer,
                orig_buffersize,
                arg,
                argsize,
                c_quoting_style,
                flags,
                quote_these_too,
                left_quote,
                right_quote,
            )
        } else {
            if !(buffersize == 0 && orig_buffersize != 0) {
                current_block = 6412618891452676311;
                break;
            }
            buffersize = orig_buffersize;
            len = 0 as libc::c_int as size_t;
        }
    }
    match current_block {
        7928555609993211441 => {
            if quoting_style as libc::c_uint
                == shell_always_quoting_style as libc::c_int as libc::c_uint
                && backslash_escapes as libc::c_int != 0
            {
                quoting_style = shell_escape_always_quoting_style;
            }
            return quotearg_buffer_restyled(
                buffer,
                buffersize,
                arg,
                argsize,
                quoting_style,
                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),
                0 as *const libc::c_uint,
                left_quote,
                right_quote,
            );
        }
        _ => {
            if !quote_string.is_null() && !elide_outer_quotes {
                while *quote_string != 0 {
                    if len < buffersize {
                        *buffer.offset(len as isize) = *quote_string;
                    }
                    len = len.wrapping_add(1);
                    len;
                    quote_string = quote_string.offset(1);
                    quote_string;
                }
            }
            if len < buffersize {
                *buffer.offset(len as isize) = '\0' as i32 as libc::c_char;
            }
            return len;
        }
    };
}
```
Here are its call sites
Call site 1:
```rust
quotearg_buffer_restyled(
        buf,
        bufsize,
        arg,
        argsize,
        (*p).style,
        flags,
        ((*p).quote_these_too).as_ptr(),
        (*p).left_quote,
        (*p).right_quote,
    );
```
Call site 2:
```rust
quotearg_buffer_restyled(
            val,
            size,
            arg,
            argsize,
            (*options).style,
            flags,
            ((*options).quote_these_too).as_ptr(),
            (*options).left_quote,
            (*options).right_quote,
        );
```
Call site 3:
```rust
return quotearg_buffer_restyled(
                buffer,
                buffersize,
                arg,
                argsize,
                quoting_style,
                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),
                0 as *const libc::c_uint,
                left_quote,
                right_quote,
            );
```
Call site 4:
```rust
let mut qsize: size_t = quotearg_buffer_restyled(
        val,
        size,
        arg,
        argsize,
        (*options).style,
        flags,
        ((*options).quote_these_too).as_ptr(),
        (*options).left_quote,
        (*options).right_quote,
    );
```
Call site 5:
```rust
let mut bufsize: size_t = (quotearg_buffer_restyled(
        0 as *mut libc::c_char,
        0 as libc::c_int as size_t,
        arg,
        argsize,
        (*p).style,
        flags,
        ((*p).quote_these_too).as_ptr(),
        (*p).left_quote,
        (*p).right_quote,
    ))
        .wrapping_add(1 as libc::c_int as libc::c_ulong);
```
Call site 6:
```rust
{
            return quotearg_buffer_restyled(
                buffer,
                orig_buffersize,
                arg,
                argsize,
                c_quoting_style,
                flags,
                quote_these_too,
                left_quote,
                right_quote,
            )
        }
```
Call site 7:
```rust
let mut r: size_t = quotearg_buffer_restyled(
        buffer,
        buffersize,
        arg,
        argsize,
        (*p).style,
        (*p).flags,
        ((*p).quote_these_too).as_ptr(),
        (*p).left_quote,
        (*p).right_quote,
    );
```
The function uses the following global variables:
```rust
pub const shell_escape_always_quoting_style: quoting_style = 4;
```
```rust
pub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;
```
```rust
pub const shell_always_quoting_style: quoting_style = 2;
```
```rust
pub const c_quoting_style: quoting_style = 5;
```
The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:812 ~ rust[fc84]::src::quotearg::quotearg_n_options)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn quotearg_n_options(
    mut n: libc::c_int,
    mut arg: *const libc::c_char,
    mut argsize: size_t,
    mut options: *const quoting_options,
) -> *mut libc::c_char {
    let mut e: libc::c_int = *__errno_location();
    let mut sv: *mut slotvec = slotvec;
    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)
        < 9223372036854775807 as libc::c_long
    {
        2147483647 as libc::c_int as libc::c_long
    } else {
        9223372036854775807 as libc::c_long
    }) as libc::c_int;
    if !(0 as libc::c_int <= n && n < nslots_max) {
        abort();
    }
    if nslots <= n {
        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;
        let mut new_nslots: idx_t = nslots as idx_t;
        sv = xpalloc(
            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })
                as *mut libc::c_void,
            &mut new_nslots,
            (n - nslots + 1 as libc::c_int) as idx_t,
            nslots_max as ptrdiff_t,
            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,
        ) as *mut slotvec;
        slotvec = sv;
        if preallocated {
            *sv = slotvec0;
        }
        memset(
            sv.offset(nslots as isize) as *mut libc::c_void,
            0 as libc::c_int,
            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),
        );
        nslots = new_nslots as libc::c_int;
    }
    let mut size: size_t = (*sv.offset(n as isize)).size;
    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;
    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;
    let mut qsize: size_t = quotearg_buffer_restyled(
        val,
        size,
        arg,
        argsize,
        (*options).style,
        flags,
        ((*options).quote_these_too).as_ptr(),
        (*options).left_quote,
        (*options).right_quote,
    );
    if size <= qsize {
        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);
        (*sv.offset(n as isize)).size = size;
        if val != slot0.as_mut_ptr() {
            free(val as *mut libc::c_void);
        }
        val = xcharalloc(size);
        let ref mut fresh0 = (*sv.offset(n as isize)).val;
        *fresh0 = val;
        quotearg_buffer_restyled(
            val,
            size,
            arg,
            argsize,
            (*options).style,
            flags,
            ((*options).quote_these_too).as_ptr(),
            (*options).left_quote,
            (*options).right_quote,
        );
    }
    *__errno_location() = e;
    return val;
}
```
Here are its call sites
Call site 1:
```rust
return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);
```
Call site 2:
```rust
return quotearg_n_options(
        n,
        arg,
        18446744073709551615 as libc::c_ulong,
        &mut default_quoting_options,
    );
```
Call site 3:
```rust
return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);
```
Call site 4:
```rust
return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);
```
Call site 5:
```rust
return quotearg_n_options(
        n,
        arg,
        18446744073709551615 as libc::c_ulong,
        &mut options,
    );
```
Call site 6:
```rust
return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);
```
Call site 7:
```rust
return quotearg_n_options(n, arg, argsize, &mut o);
```
Call site 8:
```rust
return quotearg_n_options(n, arg, argsize, &o);
```
The function uses the following global variables:
```rust
pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;
```
```rust
static mut slotvec: *mut slotvec = unsafe {
    &slotvec0 as *const slotvec as *mut slotvec
};
```
```rust
static mut slotvec0: slotvec = unsafe {
    {
        let mut init = slotvec {
            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            val: slot0.as_ptr() as *mut _,
        };
        init
    }
};
```
```rust
static mut nslots: libc::c_int = 1 as libc::c_int;
```
The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:794 ~ rust[fc84]::src::quotearg::set_char_quoting)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn set_char_quoting(
    mut o: *mut quoting_options,
    mut c: libc::c_char,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut uc: libc::c_uchar = c as libc::c_uchar;
    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {
        o
    } else {
        &mut default_quoting_options as *mut quoting_options
    }))
        .quote_these_too)
        .as_mut_ptr()
        .offset(
            (uc as libc::c_ulong)
                .wrapping_div(
                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),
                ) as isize,
        );
    let mut shift: libc::c_int = (uc as libc::c_ulong)
        .wrapping_rem(
            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_mul(8 as libc::c_int as libc::c_ulong),
        ) as libc::c_int;
    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)
        as libc::c_int;
    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;
    return r;
}
```
Here are its call sites
Call site 1:
```rust
set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);
```
Call site 2:
```rust
set_char_quoting(&mut options, ch, 1 as libc::c_int);
```
The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:821 ~ rust[fc84]::src::quotearg::quotearg_char_mem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_char_mem(
    mut arg: *const libc::c_char,
    mut argsize: size_t,
    mut ch: libc::c_char,
) -> *mut libc::c_char {
    let mut options: quoting_options = quoting_options {
        style: literal_quoting_style,
        flags: 0,
        quote_these_too: [0; 8],
        left_quote: 0 as *const libc::c_char,
        right_quote: 0 as *const libc::c_char,
    };
    options = default_quoting_options;
    set_char_quoting(&mut options, ch, 1 as libc::c_int);
    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);
}
```
Here are its call sites
Call site 1:
```rust
return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);
```
Call site 2:
```rust
return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);
```
The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
```rust
pub const literal_quoting_style: quoting_style = 0;
```
The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:823 ~ rust[fc84]::src::quotearg::quotearg_char)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_char(
    mut arg: *const libc::c_char,
    mut ch: libc::c_char,
) -> *mut libc::c_char {
    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);
}
```
Here are its call sites
Call site 1:
```rust
return quotearg_char(arg, ':' as i32 as libc::c_char);
```

The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:796 ~ rust[fc84]::src::quotearg::set_custom_quoting)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn set_custom_quoting(
    mut o: *mut quoting_options,
    mut left_quote: *const libc::c_char,
    mut right_quote: *const libc::c_char,
) {
    if o.is_null() {
        o = &mut default_quoting_options;
    }
    (*o).style = custom_quoting_style;
    if left_quote.is_null() || right_quote.is_null() {
        abort();
    }
    (*o).left_quote = left_quote;
    (*o).right_quote = right_quote;
}
```
Here are its call sites
Call site 1:
```rust
set_custom_quoting(&mut o, left_quote, right_quote);
```
The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
```rust
pub const custom_quoting_style: quoting_style = 10;
```
The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:829 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_n_custom_mem(
    mut n: libc::c_int,
    mut left_quote: *const libc::c_char,
    mut right_quote: *const libc::c_char,
    mut arg: *const libc::c_char,
    mut argsize: size_t,
) -> *mut libc::c_char {
    let mut o: quoting_options = default_quoting_options;
    set_custom_quoting(&mut o, left_quote, right_quote);
    return quotearg_n_options(n, arg, argsize, &mut o);
}
```
Here are its call sites
Call site 1:
```rust
return quotearg_n_custom_mem(
        n,
        left_quote,
        right_quote,
        arg,
        18446744073709551615 as libc::c_ulong,
    );
```
Call site 2:
```rust
return quotearg_n_custom_mem(
        0 as libc::c_int,
        left_quote,
        right_quote,
        arg,
        argsize,
    );
```
The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:831 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_custom_mem(
    mut left_quote: *const libc::c_char,
    mut right_quote: *const libc::c_char,
    mut arg: *const libc::c_char,
    mut argsize: size_t,
) -> *mut libc::c_char {
    return quotearg_n_custom_mem(
        0 as libc::c_int,
        left_quote,
        right_quote,
        arg,
        argsize,
    );
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:813 ~ rust[fc84]::src::quotearg::quotearg_n)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_n(
    mut n: libc::c_int,
    mut arg: *const libc::c_char,
) -> *mut libc::c_char {
    return quotearg_n_options(
        n,
        arg,
        18446744073709551615 as libc::c_ulong,
        &mut default_quoting_options,
    );
}
```
Here are its call sites
Call site 1:
```rust
return quotearg_n(0 as libc::c_int, arg);
```
The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
The file contains the following imports:
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CStr;
```
```rust
use std::os::raw::c_char;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:825 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_colon_mem(
    mut arg: *const libc::c_char,
    mut argsize: size_t,
) -> *mut libc::c_char {
    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);
}
```


The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use std::os::raw::c_char;
```
```rust
use ::libc;
```
```rust
use std::convert::TryInto;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:797 ~ rust[fc84]::src::quotearg::quoting_options_from_style)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn quoting_options_from_style(
    mut style: quoting_style,
) -> quoting_options {
    let mut o: quoting_options = {
        let mut init = quoting_options {
            style: literal_quoting_style,
            flags: 0 as libc::c_int,
            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],
            left_quote: 0 as *const libc::c_char,
            right_quote: 0 as *const libc::c_char,
        };
        init
    };
    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {
        abort();
    }
    o.style = style;
    return o;
}
```
Here are its call sites
Call site 1:
```rust
options = quoting_options_from_style(s);
```
Call site 2:
```rust
let o: quoting_options = quoting_options_from_style(s);
```
Call site 3:
```rust
let o: quoting_options = quoting_options_from_style(s);
```
The function uses the following global variables:
```rust
pub const literal_quoting_style: quoting_style = 0;
```
The file contains the following imports:
```rust
use std::convert::TryInto;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:817 ~ rust[fc84]::src::quotearg::quotearg_n_style)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_n_style(
    mut n: libc::c_int,
    mut s: quoting_style,
    mut arg: *const libc::c_char,
) -> *mut libc::c_char {
    let o: quoting_options = quoting_options_from_style(s);
    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);
}
```
Here are its call sites
Call site 1:
```rust
return quotearg_n_style(0 as libc::c_int, s, arg);
```

The file contains the following imports:
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
```rust
use std::os::raw::c_char;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:802 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_alloc_mem(
    mut arg: *const libc::c_char,
    mut argsize: size_t,
    mut size: *mut size_t,
    mut o: *const quoting_options,
) -> *mut libc::c_char {
    let mut p: *const quoting_options = if !o.is_null() {
        o
    } else {
        &mut default_quoting_options as *mut quoting_options as *const quoting_options
    };
    let mut e: libc::c_int = *__errno_location();
    let mut flags: libc::c_int = (*p).flags
        | (if !size.is_null() {
            0 as libc::c_int
        } else {
            QA_ELIDE_NULL_BYTES as libc::c_int
        });
    let mut bufsize: size_t = (quotearg_buffer_restyled(
        0 as *mut libc::c_char,
        0 as libc::c_int as size_t,
        arg,
        argsize,
        (*p).style,
        flags,
        ((*p).quote_these_too).as_ptr(),
        (*p).left_quote,
        (*p).right_quote,
    ))
        .wrapping_add(1 as libc::c_int as libc::c_ulong);
    let mut buf: *mut libc::c_char = xcharalloc(bufsize);
    quotearg_buffer_restyled(
        buf,
        bufsize,
        arg,
        argsize,
        (*p).style,
        flags,
        ((*p).quote_these_too).as_ptr(),
        (*p).left_quote,
        (*p).right_quote,
    );
    *__errno_location() = e;
    if !size.is_null() {
        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);
    }
    return buf;
}
```
Here are its call sites
Call site 1:
```rust
return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);
```
The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
```rust
pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;
```
The file contains the following imports:
```rust
use std::os::raw::c_char;
```
```rust
use std::ffi::CStr;
```
```rust
use std::convert::TryInto;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:801 ~ rust[fc84]::src::quotearg::quotearg_alloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_alloc(
    mut arg: *const libc::c_char,
    mut argsize: size_t,
    mut o: *const quoting_options,
) -> *mut libc::c_char {
    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::ffi::CStr;
```
```rust
use std::convert::TryInto;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:818 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_n_style_mem(
    mut n: libc::c_int,
    mut s: quoting_style,
    mut arg: *const libc::c_char,
    mut argsize: size_t,
) -> *mut libc::c_char {
    let o: quoting_options = quoting_options_from_style(s);
    return quotearg_n_options(n, arg, argsize, &o);
}
```
Here are its call sites
Call site 1:
```rust
return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);
```

The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use std::ffi::CString;
```
```rust
use std::os::raw::c_char;
```
```rust
use ::libc;
```
```rust
use std::convert::TryInto;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:820 ~ rust[fc84]::src::quotearg::quotearg_style_mem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_style_mem(
    mut s: quoting_style,
    mut arg: *const libc::c_char,
    mut argsize: size_t,
) -> *mut libc::c_char {
    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);
}
```


The file contains the following imports:
```rust
use std::ffi::CString;
```
```rust
use std::convert::TryInto;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:814 ~ rust[fc84]::src::quotearg::quotearg_n_mem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_n_mem(
    mut n: libc::c_int,
    mut arg: *const libc::c_char,
    mut argsize: size_t,
) -> *mut libc::c_char {
    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);
}
```
Here are its call sites
Call site 1:
```rust
return quotearg_n_mem(0 as libc::c_int, arg, argsize);
```
The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
The file contains the following imports:
```rust
use std::ffi::CString;
```
```rust
use std::ffi::CStr;
```
```rust
use std::os::raw::c_char;
```
```rust
use ::libc;
```
```rust
use std::convert::TryInto;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:833 ~ rust[fc84]::src::quotearg::quote_n_mem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quote_n_mem(
    mut n: libc::c_int,
    mut arg: *const libc::c_char,
    mut argsize: size_t,
) -> *const libc::c_char {
    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);
}
```
Here are its call sites
Call site 1:
```rust
return quote_n_mem(0 as libc::c_int, arg, argsize);
```
Call site 2:
```rust
return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);
```
The function uses the following global variables:
```rust
pub static mut quote_quoting_options: quoting_options = {
    let mut init = quoting_options {
        style: locale_quoting_style,
        flags: 0 as libc::c_int,
        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],
        left_quote: 0 as *const libc::c_char,
        right_quote: 0 as *const libc::c_char,
    };
    init
};
```
The file contains the following imports:
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
```rust
use std::ffi::CString;
```
```rust
use std::os::raw::c_char;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:835 ~ rust[fc84]::src::quotearg::quote_n)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quote_n(
    mut n: libc::c_int,
    mut arg: *const libc::c_char,
) -> *const libc::c_char {
    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);
}
```
Here are its call sites
Call site 1:
```rust
return quote_n(0 as libc::c_int, arg);
```

The file contains the following imports:
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CString;
```
```rust
use ::libc;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:828 ~ rust[fc84]::src::quotearg::quotearg_n_custom)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_n_custom(
    mut n: libc::c_int,
    mut left_quote: *const libc::c_char,
    mut right_quote: *const libc::c_char,
    mut arg: *const libc::c_char,
) -> *mut libc::c_char {
    return quotearg_n_custom_mem(
        n,
        left_quote,
        right_quote,
        arg,
        18446744073709551615 as libc::c_ulong,
    );
}
```
Here are its call sites
Call site 1:
```rust
return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);
```

The file contains the following imports:
```rust
use std::os::raw::c_char;
```
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
```rust
use std::ffi::CString;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:816 ~ rust[fc84]::src::quotearg::quotearg_mem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_mem(
    mut arg: *const libc::c_char,
    mut argsize: size_t,
) -> *mut libc::c_char {
    return quotearg_n_mem(0 as libc::c_int, arg, argsize);
}
```


The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use std::convert::TryInto;
```
```rust
use ::libc;
```
```rust
use std::ffi::CString;
```
```rust
use std::os::raw::c_char;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:836 ~ rust[fc84]::src::quotearg::quote)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {
    return quote_n(0 as libc::c_int, arg);
}
```


The file contains the following imports:
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CStr;
```
```rust
use std::ffi::CString;
```
```rust
use std::os::raw::c_char;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:800 ~ rust[fc84]::src::quotearg::quotearg_buffer)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_buffer(
    mut buffer: *mut libc::c_char,
    mut buffersize: size_t,
    mut arg: *const libc::c_char,
    mut argsize: size_t,
    mut o: *const quoting_options,
) -> size_t {
    let mut p: *const quoting_options = if !o.is_null() {
        o
    } else {
        &mut default_quoting_options as *mut quoting_options as *const quoting_options
    };
    let mut e: libc::c_int = *__errno_location();
    let mut r: size_t = quotearg_buffer_restyled(
        buffer,
        buffersize,
        arg,
        argsize,
        (*p).style,
        (*p).flags,
        ((*p).quote_these_too).as_ptr(),
        (*p).left_quote,
        (*p).right_quote,
    );
    *__errno_location() = e;
    return r;
}
```

The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CString;
```
```rust
use std::os::raw::c_char;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:824 ~ rust[fc84]::src::quotearg::quotearg_colon)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_colon(
    mut arg: *const libc::c_char,
) -> *mut libc::c_char {
    return quotearg_char(arg, ':' as i32 as libc::c_char);
}
```


The file contains the following imports:
```rust
use std::convert::TryInto;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
```rust
use std::ffi::CString;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:819 ~ rust[fc84]::src::quotearg::quotearg_style)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_style(
    mut s: quoting_style,
    mut arg: *const libc::c_char,
) -> *mut libc::c_char {
    return quotearg_n_style(0 as libc::c_int, s, arg);
}
```


The file contains the following imports:
```rust
use std::os::raw::c_char;
```
```rust
use std::ffi::CString;
```
```rust
use std::convert::TryInto;
```
```rust
use ::libc;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:830 ~ rust[fc84]::src::quotearg::quotearg_custom)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_custom(
    mut left_quote: *const libc::c_char,
    mut right_quote: *const libc::c_char,
    mut arg: *const libc::c_char,
) -> *mut libc::c_char {
    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);
}
```


The file contains the following imports:
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CStr;
```
```rust
use std::ffi::CString;
```
```rust
use std::os::raw::c_char;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:815 ~ rust[fc84]::src::quotearg::quotearg)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {
    return quotearg_n(0 as libc::c_int, arg);
}
```


The file contains the following imports:
```rust
use std::ffi::CString;
```
```rust
use ::libc;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:826 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_n_style_colon(
    mut n: libc::c_int,
    mut s: quoting_style,
    mut arg: *const libc::c_char,
) -> *mut libc::c_char {
    let mut options: quoting_options = quoting_options {
        style: literal_quoting_style,
        flags: 0,
        quote_these_too: [0; 8],
        left_quote: 0 as *const libc::c_char,
        right_quote: 0 as *const libc::c_char,
    };
    options = quoting_options_from_style(s);
    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);
    return quotearg_n_options(
        n,
        arg,
        18446744073709551615 as libc::c_ulong,
        &mut options,
    );
}
```

The function uses the following global variables:
```rust
pub const literal_quoting_style: quoting_style = 0;
```
The file contains the following imports:
```rust
use std::ffi::CString;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::convert::TryInto;
```
```rust
use ::libc;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:834 ~ rust[fc84]::src::quotearg::quote_mem)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quote_mem(
    mut arg: *const libc::c_char,
    mut argsize: size_t,
) -> *const libc::c_char {
    return quote_n_mem(0 as libc::c_int, arg, argsize);
}
```


The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::convert::TryInto;
```
```rust
use ::libc;
```
```rust
use std::ffi::CString;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:34 ~ rust[fc84]::src::c_ctype::c_isgraph)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_isgraph(mut c: libc::c_int) -> bool {
    match c {
        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102
        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115
        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40
        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92
        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71
        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87
        | 88 | 89 | 90 => return 1 as libc::c_int != 0,
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::ops::RangeInclusive;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:810 ~ rust[fc84]::src::quotearg::quotearg_free)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn quotearg_free() {
    let mut sv: *mut slotvec = slotvec;
    let mut i: libc::c_int = 0;
    i = 1 as libc::c_int;
    while i < nslots {
        free((*sv.offset(i as isize)).val as *mut libc::c_void);
        i += 1;
        i;
    }
    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {
        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);
        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;
        slotvec0.val = slot0.as_mut_ptr();
    }
    if sv != &mut slotvec0 as *mut slotvec {
        free(sv as *mut libc::c_void);
        slotvec = &mut slotvec0;
    }
    nslots = 1 as libc::c_int;
}
```

The function uses the following global variables:
```rust
static mut slot0: [libc::c_char; 256] = [0; 256];
```
```rust
static mut slotvec: *mut slotvec = unsafe {
    &slotvec0 as *const slotvec as *mut slotvec
};
```
```rust
static mut nslots: libc::c_int = 1 as libc::c_int;
```
```rust
static mut slotvec0: slotvec = unsafe {
    {
        let mut init = slotvec {
            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            val: slot0.as_ptr() as *mut _,
        };
        init
    }
};
```
The file contains the following imports:
```rust
use std::ffi::CString;
```
```rust
use std::convert::TryInto;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:110 ~ rust[fc84]::src::copy_file_range::rpl_copy_file_range)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn rpl_copy_file_range(
    mut infd: libc::c_int,
    mut pinoff: *mut off_t,
    mut outfd: libc::c_int,
    mut poutoff: *mut off_t,
    mut length: size_t,
    mut flags: libc::c_uint,
) -> ssize_t {
    static mut ok: libc::c_schar = 0;
    if ok == 0 {
        let mut name: utsname = utsname {
            sysname: [0; 65],
            nodename: [0; 65],
            release: [0; 65],
            version: [0; 65],
            machine: [0; 65],
            domainname: [0; 65],
        };
        uname(&mut name);
        let mut p: *mut libc::c_char = (name.release).as_mut_ptr();
        ok = (if *p.offset(1 as libc::c_int as isize) as libc::c_int != '.' as i32
            || ('5' as i32) < *p.offset(0 as libc::c_int as isize) as libc::c_int
            || *p.offset(0 as libc::c_int as isize) as libc::c_int == '5' as i32
                && (*p.offset(3 as libc::c_int as isize) as libc::c_int != '.' as i32
                    || ('2' as i32)
                        < *p.offset(2 as libc::c_int as isize) as libc::c_int)
        {
            1 as libc::c_int
        } else {
            -(1 as libc::c_int)
        }) as libc::c_schar;
    }
    if (0 as libc::c_int) < ok as libc::c_int {
        return copy_file_range(infd, pinoff, outfd, poutoff, length, flags);
    }
    *__errno_location() = 38 as libc::c_int;
    return -(1 as libc::c_int) as ssize_t;
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:202 ~ rust[fc84]::src::fflush::clear_ungetc_buffer_preserving_position)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {
    if (*fp)._flags & 0x100 as libc::c_int != 0 {
        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);
    }
}
```
Here are its call sites
Call site 1:
```rust
clear_ungetc_buffer_preserving_position(stream);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:203 ~ rust[fc84]::src::fflush::rpl_fflush)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {
    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {
        return fflush(stream);
    }
    clear_ungetc_buffer_preserving_position(stream);
    return fflush(stream);
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:882 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_unlocked)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn setlocale_null_unlocked(
    mut category: libc::c_int,
) -> *const libc::c_char {
    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);
    return result;
}
```
Here are its call sites
Call site 1:
```rust
let mut result: *const libc::c_char = setlocale_null_unlocked(category);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:883 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn setlocale_null_r_unlocked(
    mut category: libc::c_int,
    mut buf: *mut libc::c_char,
    mut bufsize: size_t,
) -> libc::c_int {
    let mut result: *const libc::c_char = setlocale_null_unlocked(category);
    if result.is_null() {
        if bufsize > 0 as libc::c_int as libc::c_ulong {
            *buf.offset(0 as libc::c_int as isize) = '\0' as i32 as libc::c_char;
        }
        return 22 as libc::c_int;
    } else {
        let mut length: size_t = strlen(result);
        if length < bufsize {
            memcpy(
                buf as *mut libc::c_void,
                result as *const libc::c_void,
                length.wrapping_add(1 as libc::c_int as libc::c_ulong),
            );
            return 0 as libc::c_int;
        } else {
            if bufsize > 0 as libc::c_int as libc::c_ulong {
                memcpy(
                    buf as *mut libc::c_void,
                    result as *const libc::c_void,
                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                );
                *buf
                    .offset(
                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                    ) = '\0' as i32 as libc::c_char;
            }
            return 34 as libc::c_int;
        }
    };
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:791 ~ rust[fc84]::src::quotearg::clone_quoting_options)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn clone_quoting_options(
    mut o: *mut quoting_options,
) -> *mut quoting_options {
    let mut e: libc::c_int = *__errno_location();
    let mut p: *mut quoting_options = xmemdup(
        (if !o.is_null() {
            o
        } else {
            &mut default_quoting_options as *mut quoting_options
        }) as *const libc::c_void,
        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,
    ) as *mut quoting_options;
    *__errno_location() = e;
    return p;
}
```

The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
The file contains the following imports:
```rust
use std::boxed::Box;
```
```rust
use std::ffi::CString;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::convert::TryInto;
```
```rust
use ::libc;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:849 ~ rust[fc84]::src::safe_read::safe_read)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn safe_read(
    mut fd: libc::c_int,
    mut buf: *mut libc::c_void,
    mut count: size_t,
) -> size_t {
    loop {
        let mut result: ssize_t = read(fd, buf, count);
        if 0 as libc::c_int as libc::c_long <= result {
            return result as size_t
        } else {
            if *__errno_location() == 4 as libc::c_int {
                continue;
            }
            if *__errno_location() == 22 as libc::c_int
                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count
            {
                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;
            } else {
                return result as size_t
            }
        }
    };
}
```

The function uses the following global variables:
```rust
pub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;
```
The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:872 ~ rust[fc84]::src::setlocale_null::setlocale_null)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn setlocale_null(
    mut category: libc::c_int,
) -> *const libc::c_char {
    return setlocale_null_unlocked(category);
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:977 ~ rust[fc84]::src::xbinary_io::xset_binary_mode_error)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xset_binary_mode_error() {}
```
Here are its call sites
Call site 1:
```rust
xset_binary_mode_error();
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:976 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {
    if set_binary_mode(fd, mode) < 0 as libc::c_int {
        xset_binary_mode_error();
    }
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:900 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clzll)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {
    return (if n != 0 {
        n.leading_zeros() as i32 as libc::c_ulong
    } else {
        (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)
    }) as libc::c_int;
}
```
Here are its call sites
Call site 1:
```rust
return __gl_stdbit_clzll(n) as libc::c_uint;
```

The file contains the following imports:
```rust
use std::convert::TryInto;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:905 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ull)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn stdc_leading_zeros_ull(
    mut n: libc::c_ulonglong,
) -> libc::c_uint {
    return __gl_stdbit_clzll(n) as libc::c_uint;
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::convert::TryInto;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:47 ~ rust[fc84]::src::c_strcasecmp::c_tolower)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn c_tolower(mut c: libc::c_int) -> libc::c_int {
    match c {
        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80
        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {
            return c - 'A' as i32 + 'a' as i32;
        }
        _ => return c,
    };
}
```
Here are its call sites
Call site 1:
```rust
c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;
```
Call site 2:
```rust
c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:48 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_strcasecmp(
    mut s1: *const libc::c_char,
    mut s2: *const libc::c_char,
) -> libc::c_int {
    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;
    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;
    let mut c1: libc::c_uchar = 0;
    let mut c2: libc::c_uchar = 0;
    if p1 == p2 {
        return 0 as libc::c_int;
    }
    loop {
        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;
        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;
        if c1 as libc::c_int == '\0' as i32 {
            break;
        }
        p1 = p1.offset(1);
        p1;
        p2 = p2.offset(1);
        p2;
        if !(c1 as libc::c_int == c2 as libc::c_int) {
            break;
        }
    }
    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int
        <= 2147483647 as libc::c_int
    {
        return c1 as libc::c_int - c2 as libc::c_int
    } else {
        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int
            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int
    };
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:871 ~ rust[fc84]::src::setlocale_null::setlocale_null_r)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn setlocale_null_r(
    mut category: libc::c_int,
    mut buf: *mut libc::c_char,
    mut bufsize: size_t,
) -> libc::c_int {
    return setlocale_null_r_unlocked(category, buf, bufsize);
}
```


The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:42 ~ rust[fc84]::src::c_ctype::c_toupper)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_toupper(mut c: libc::c_int) -> libc::c_int {
    match c {
        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110
        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {
            return c - 'a' as i32 + 'A' as i32;
        }
        _ => return c,
    };
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::ops::RangeInclusive;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:38 ~ rust[fc84]::src::c_ctype::c_isspace)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_isspace(mut c: libc::c_int) -> bool {
    match c {
        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use std::ops::RangeInclusive;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:935 ~ rust[fc84]::src::version_etc::version_etc_arn)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn version_etc_arn(
    mut stream: *mut FILE,
    mut command_name: *const libc::c_char,
    mut package: *const libc::c_char,
    mut version: *const libc::c_char,
    mut authors: *const *const libc::c_char,
    mut n_authors: size_t,
) {
    if !command_name.is_null() {
        fprintf(
            stream,
            b"%s (%s) %s\n\0" as *const u8 as *const libc::c_char,
            command_name,
            package,
            version,
        );
    } else {
        fprintf(
            stream,
            b"%s %s\n\0" as *const u8 as *const libc::c_char,
            package,
            version,
        );
    }
    fprintf(
        stream,
        version_etc_copyright.as_ptr(),
        gettext(b"(C)\0" as *const u8 as *const libc::c_char),
        COPYRIGHT_YEAR as libc::c_int,
    );
    fputs_unlocked(b"\n\0" as *const u8 as *const libc::c_char, stream);
    fprintf(
        stream,
        gettext(
            b"License GPLv3+: GNU GPL version 3 or later <%s>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\0"
                as *const u8 as *const libc::c_char,
        ),
        b"https://gnu.org/licenses/gpl.html\0" as *const u8 as *const libc::c_char,
    );
    fputs_unlocked(b"\n\0" as *const u8 as *const libc::c_char, stream);
    match n_authors {
        0 => {}
        1 => {
            fprintf(
                stream,
                gettext(b"Written by %s.\n\0" as *const u8 as *const libc::c_char),
                *authors.offset(0 as libc::c_int as isize),
            );
        }
        2 => {
            fprintf(
                stream,
                gettext(
                    b"Written by %s and %s.\n\0" as *const u8 as *const libc::c_char,
                ),
                *authors.offset(0 as libc::c_int as isize),
                *authors.offset(1 as libc::c_int as isize),
            );
        }
        3 => {
            fprintf(
                stream,
                gettext(
                    b"Written by %s, %s, and %s.\n\0" as *const u8 as *const libc::c_char,
                ),
                *authors.offset(0 as libc::c_int as isize),
                *authors.offset(1 as libc::c_int as isize),
                *authors.offset(2 as libc::c_int as isize),
            );
        }
        4 => {
            fprintf(
                stream,
                gettext(
                    b"Written by %s, %s, %s,\nand %s.\n\0" as *const u8
                        as *const libc::c_char,
                ),
                *authors.offset(0 as libc::c_int as isize),
                *authors.offset(1 as libc::c_int as isize),
                *authors.offset(2 as libc::c_int as isize),
                *authors.offset(3 as libc::c_int as isize),
            );
        }
        5 => {
            fprintf(
                stream,
                gettext(
                    b"Written by %s, %s, %s,\n%s, and %s.\n\0" as *const u8
                        as *const libc::c_char,
                ),
                *authors.offset(0 as libc::c_int as isize),
                *authors.offset(1 as libc::c_int as isize),
                *authors.offset(2 as libc::c_int as isize),
                *authors.offset(3 as libc::c_int as isize),
                *authors.offset(4 as libc::c_int as isize),
            );
        }
        6 => {
            fprintf(
                stream,
                gettext(
                    b"Written by %s, %s, %s,\n%s, %s, and %s.\n\0" as *const u8
                        as *const libc::c_char,
                ),
                *authors.offset(0 as libc::c_int as isize),
                *authors.offset(1 as libc::c_int as isize),
                *authors.offset(2 as libc::c_int as isize),
                *authors.offset(3 as libc::c_int as isize),
                *authors.offset(4 as libc::c_int as isize),
                *authors.offset(5 as libc::c_int as isize),
            );
        }
        7 => {
            fprintf(
                stream,
                gettext(
                    b"Written by %s, %s, %s,\n%s, %s, %s, and %s.\n\0" as *const u8
                        as *const libc::c_char,
                ),
                *authors.offset(0 as libc::c_int as isize),
                *authors.offset(1 as libc::c_int as isize),
                *authors.offset(2 as libc::c_int as isize),
                *authors.offset(3 as libc::c_int as isize),
                *authors.offset(4 as libc::c_int as isize),
                *authors.offset(5 as libc::c_int as isize),
                *authors.offset(6 as libc::c_int as isize),
            );
        }
        8 => {
            fprintf(
                stream,
                gettext(
                    b"Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n\0" as *const u8
                        as *const libc::c_char,
                ),
                *authors.offset(0 as libc::c_int as isize),
                *authors.offset(1 as libc::c_int as isize),
                *authors.offset(2 as libc::c_int as isize),
                *authors.offset(3 as libc::c_int as isize),
                *authors.offset(4 as libc::c_int as isize),
                *authors.offset(5 as libc::c_int as isize),
                *authors.offset(6 as libc::c_int as isize),
                *authors.offset(7 as libc::c_int as isize),
            );
        }
        9 => {
            fprintf(
                stream,
                gettext(
                    b"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n\0"
                        as *const u8 as *const libc::c_char,
                ),
                *authors.offset(0 as libc::c_int as isize),
                *authors.offset(1 as libc::c_int as isize),
                *authors.offset(2 as libc::c_int as isize),
                *authors.offset(3 as libc::c_int as isize),
                *authors.offset(4 as libc::c_int as isize),
                *authors.offset(5 as libc::c_int as isize),
                *authors.offset(6 as libc::c_int as isize),
                *authors.offset(7 as libc::c_int as isize),
                *authors.offset(8 as libc::c_int as isize),
            );
        }
        _ => {
            fprintf(
                stream,
                gettext(
                    b"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n\0"
                        as *const u8 as *const libc::c_char,
                ),
                *authors.offset(0 as libc::c_int as isize),
                *authors.offset(1 as libc::c_int as isize),
                *authors.offset(2 as libc::c_int as isize),
                *authors.offset(3 as libc::c_int as isize),
                *authors.offset(4 as libc::c_int as isize),
                *authors.offset(5 as libc::c_int as isize),
                *authors.offset(6 as libc::c_int as isize),
                *authors.offset(7 as libc::c_int as isize),
                *authors.offset(8 as libc::c_int as isize),
            );
        }
    };
}
```
Here are its call sites
Call site 1:
```rust
version_etc_arn(stream, command_name, package, version, authors, n_authors);
```
Call site 2:
```rust
version_etc_arn(
        stream,
        command_name,
        package,
        version,
        authtab.as_mut_ptr(),
        n_authors,
    );
```
The function uses the following global variables:
```rust
pub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;
```
The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:937 ~ rust[fc84]::src::version_etc::version_etc_va)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn version_etc_va(
    mut stream: *mut FILE,
    mut command_name: *const libc::c_char,
    mut package: *const libc::c_char,
    mut version: *const libc::c_char,
    mut authors: ::core::ffi::VaList,
) {
    let mut n_authors: size_t = 0;
    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];
    n_authors = 0 as libc::c_int as size_t;
    while n_authors < 10 as libc::c_int as libc::c_ulong
        && {
            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();
            !(authtab[n_authors as usize]).is_null()
        }
    {
        n_authors = n_authors.wrapping_add(1);
        n_authors;
    }
    version_etc_arn(
        stream,
        command_name,
        package,
        version,
        authtab.as_mut_ptr(),
        n_authors,
    );
}
```
Here are its call sites
Call site 1:
```rust
version_etc_va(stream, command_name, package, version, authors.as_va_list());
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:936 ~ rust[fc84]::src::version_etc::version_etc_ar)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn version_etc_ar(
    mut stream: *mut FILE,
    mut command_name: *const libc::c_char,
    mut package: *const libc::c_char,
    mut version: *const libc::c_char,
    mut authors: *const *const libc::c_char,
) {
    let mut n_authors: size_t = 0;
    n_authors = 0 as libc::c_int as size_t;
    while !(*authors.offset(n_authors as isize)).is_null() {
        n_authors = n_authors.wrapping_add(1);
        n_authors;
    }
    version_etc_arn(stream, command_name, package, version, authors, n_authors);
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:940 ~ rust[fc84]::src::version_etc::version_etc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn version_etc(
    mut stream: *mut FILE,
    mut command_name: *const libc::c_char,
    mut package: *const libc::c_char,
    mut version: *const libc::c_char,
    mut args: ...
) {
    let mut authors: ::core::ffi::VaListImpl;
    authors = args.clone();
    version_etc_va(stream, command_name, package, version, authors.as_va_list());
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:22 ~ rust[fc84]::src::binary_io::__gl_setmode)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn __gl_setmode(
    mut _fd: libc::c_int,
    mut _mode: libc::c_int,
) -> libc::c_int {
    return 0 as libc::c_int;
}
```
Here are its call sites
Call site 1:
```rust
return __gl_setmode(fd, mode);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:21 ~ rust[fc84]::src::binary_io::set_binary_mode)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn set_binary_mode(
    mut fd: libc::c_int,
    mut mode: libc::c_int,
) -> libc::c_int {
    return __gl_setmode(fd, mode);
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:979 ~ rust[fc84]::src::xbinary_io::__gl_setmode)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn __gl_setmode(
    mut _fd: libc::c_int,
    mut _mode: libc::c_int,
) -> libc::c_int {
    return 0 as libc::c_int;
}
```
Here are its call sites
Call site 1:
```rust
return __gl_setmode(fd, mode);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:978 ~ rust[fc84]::src::xbinary_io::set_binary_mode)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn set_binary_mode(
    mut fd: libc::c_int,
    mut mode: libc::c_int,
) -> libc::c_int {
    return __gl_setmode(fd, mode);
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:889 ~ rust[fc84]::src::stdbit::__gl_stdbit_clzl)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {
    return (if n != 0 {
        n.leading_zeros() as i32 as libc::c_ulong
    } else {
        (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)
    }) as libc::c_int;
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:29 ~ rust[fc84]::src::c_ctype::c_isalpha)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_isalpha(mut c: libc::c_int) -> bool {
    match c {
        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110
        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66
        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82
        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use std::convert::TryFrom;
```
```rust
use ::libc;
```
```rust
use std::ops::RangeInclusive;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:862 ~ rust[fc84]::src::safe_write::safe_write)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn safe_write(
    mut fd: libc::c_int,
    mut buf: *const libc::c_void,
    mut count: size_t,
) -> size_t {
    loop {
        let mut result: ssize_t = write(fd, buf, count);
        if 0 as libc::c_int as libc::c_long <= result {
            return result as size_t
        } else {
            if *__errno_location() == 4 as libc::c_int {
                continue;
            }
            if *__errno_location() == 22 as libc::c_int
                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count
            {
                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;
            } else {
                return result as size_t
            }
        }
    };
}
```

The function uses the following global variables:
```rust
pub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;
```
The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:888 ~ rust[fc84]::src::stdbit::__gl_stdbit_clz)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {
    return (if n != 0 {
        n.leading_zeros() as i32 as libc::c_ulong
    } else {
        (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
    }) as libc::c_int;
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:30 ~ rust[fc84]::src::c_ctype::c_isascii)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_isascii(mut c: libc::c_int) -> bool {
    match c {
        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16
        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127
        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101
        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114
        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38
        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64
        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69
        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85
        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use std::convert::TryFrom;
```
```rust
use std::ops::RangeInclusive;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:31 ~ rust[fc84]::src::c_ctype::c_isblank)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_isblank(mut c: libc::c_int) -> bool {
    return c == ' ' as i32 || c == '\t' as i32;
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::convert::TryFrom;
```
```rust
use std::ops::RangeInclusive;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:892 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctzl)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn __gl_stdbit_ctzl(mut n: libc::c_ulong) -> libc::c_int {
    return (if n != 0 {
        n.trailing_zeros() as i32 as libc::c_ulong
    } else {
        (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)
    }) as libc::c_int;
}
```


The file contains the following imports:
```rust
use std::mem;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:960 ~ rust[fc84]::src::xalignalloc::alignalloc)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn alignalloc(
    mut alignment: idx_t,
    mut size: idx_t,
) -> *mut libc::c_void {
    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {
        alignment = -(1 as libc::c_int) as size_t as idx_t;
    }
    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {
        size = -(1 as libc::c_int) as size_t as idx_t;
    }
    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);
}
```
Here are its call sites
Call site 1:
```rust
let mut p: *mut libc::c_void = alignalloc(alignment, size);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:961 ~ rust[fc84]::src::xalignalloc::xalignalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xalignalloc(
    mut alignment: idx_t,
    mut size: idx_t,
) -> *mut libc::c_void {
    let mut p: *mut libc::c_void = alignalloc(alignment, size);
    if p.is_null() {
        xalloc_die();
    }
    return p;
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:41 ~ rust[fc84]::src::c_ctype::c_tolower)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_tolower(mut c: libc::c_int) -> libc::c_int {
    match c {
        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80
        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {
            return c - 'A' as i32 + 'a' as i32;
        }
        _ => return c,
    };
}
```


The file contains the following imports:
```rust
use std::ops::RangeInclusive;
```
```rust
use ::libc;
```
```rust
use std::convert::TryFrom;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:92 ~ rust[fc84]::src::closeout::close_stdout_set_file_name)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn close_stdout_set_file_name(mut file: *const libc::c_char) {
    file_name = file;
}
```

The function uses the following global variables:
```rust
static mut file_name: *const libc::c_char = 0 as *const libc::c_char;
```
The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:32 ~ rust[fc84]::src::c_ctype::c_iscntrl)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_iscntrl(mut c: libc::c_int) -> bool {
    match c {
        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17
        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {
            return 1 as libc::c_int != 0;
        }
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::ops::RangeInclusive;
```
```rust
use std::convert::TryFrom;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:693 ~ rust[fc84]::src::mbszero::mbszero)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn mbszero(mut ps: *mut mbstate_t) {
    memset(
        ps as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,
    );
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:715 ~ rust[fc84]::src::progname::set_program_name)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn set_program_name(mut argv0: *const libc::c_char) {
    let mut slash: *const libc::c_char = 0 as *const libc::c_char;
    let mut base: *const libc::c_char = 0 as *const libc::c_char;
    if argv0.is_null() {
        fputs(
            b"A NULL argv[0] was passed through an exec system call.\n\0" as *const u8
                as *const libc::c_char,
            stderr,
        );
        abort();
    }
    slash = strrchr(argv0, '/' as i32);
    base = if !slash.is_null() {
        slash.offset(1 as libc::c_int as isize)
    } else {
        argv0
    };
    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long
        && strncmp(
            base.offset(-(7 as libc::c_int as isize)),
            b"/.libs/\0" as *const u8 as *const libc::c_char,
            7 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        argv0 = base;
        if strncmp(
            base,
            b"lt-\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
        {
            argv0 = base.offset(3 as libc::c_int as isize);
            program_invocation_short_name = argv0 as *mut libc::c_char;
        }
    }
    program_name = argv0;
    program_invocation_name = argv0 as *mut libc::c_char;
}
```

The function uses the following global variables:
```rust
pub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;
```
The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:898 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clz)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {
    return (if n != 0 {
        n.leading_zeros() as i32 as libc::c_ulong
    } else {
        (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
    }) as libc::c_int;
}
```
Here are its call sites
Call site 1:
```rust
return __gl_stdbit_clz(n) as libc::c_uint;
```

The file contains the following imports:
```rust
use std::convert::TryInto;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:901 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ui)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn stdc_leading_zeros_ui(mut n: libc::c_uint) -> libc::c_uint {
    return __gl_stdbit_clz(n) as libc::c_uint;
}
```
Here are its call sites
Call site 1:
```rust
return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)
        .wrapping_sub(
            (8 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                        .wrapping_sub(
                            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong,
                        ),
                ),
        ) as libc::c_uint;
```
Call site 2:
```rust
return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)
        .wrapping_sub(
            (8 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                        .wrapping_sub(
                            ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong,
                        ),
                ),
        ) as libc::c_uint;
```

The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::convert::TryInto;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:902 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_uc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn stdc_leading_zeros_uc(mut n: libc::c_uchar) -> libc::c_uint {
    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)
        .wrapping_sub(
            (8 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                        .wrapping_sub(
                            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong,
                        ),
                ),
        ) as libc::c_uint;
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::convert::TryInto;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:903 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_us)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn stdc_leading_zeros_us(mut n: libc::c_ushort) -> libc::c_uint {
    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)
        .wrapping_sub(
            (8 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                        .wrapping_sub(
                            ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong,
                        ),
                ),
        ) as libc::c_uint;
}
```


The file contains the following imports:
```rust
use std::convert::TryInto;
```
```rust
use std::mem;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:245 ~ rust[fc84]::src::full_write::full_write)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn full_write(
    mut fd: libc::c_int,
    mut buf: *const libc::c_void,
    mut count: size_t,
) -> size_t {
    let mut total: size_t = 0 as libc::c_int as size_t;
    let mut ptr: *const libc::c_char = buf as *const libc::c_char;
    while count > 0 as libc::c_int as libc::c_ulong {
        let mut n_rw: size_t = safe_write(fd, ptr as *const libc::c_void, count);
        if n_rw == -(1 as libc::c_int) as size_t {
            break;
        }
        if n_rw == 0 as libc::c_int as libc::c_ulong {
            *__errno_location() = 28 as libc::c_int;
            break;
        } else {
            total = (total as libc::c_ulong).wrapping_add(n_rw) as size_t as size_t;
            ptr = ptr.offset(n_rw as isize);
            count = (count as libc::c_ulong).wrapping_sub(n_rw) as size_t as size_t;
        }
    }
    return total;
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:16 ~ rust[fc84]::src::alignalloc::alignfree)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn alignfree(mut ptr: *mut libc::c_void) {
    free(ptr);
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:890 ~ rust[fc84]::src::stdbit::__gl_stdbit_clzll)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {
    return (if n != 0 {
        n.leading_zeros() as i32 as libc::c_ulong
    } else {
        (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)
    }) as libc::c_int;
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::convert::TryInto;
```
```rust
use std::mem;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:37 ~ rust[fc84]::src::c_ctype::c_ispunct)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_ispunct(mut c: libc::c_int) -> bool {
    match c {
        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58
        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125
        | 126 => return 1 as libc::c_int != 0,
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::ops::RangeInclusive;
```
```rust
use std::convert::TryFrom;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:784 ~ rust[fc84]::src::quotearg::mbszero)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn mbszero(mut ps: *mut mbstate_t) {
    memset(
        ps as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,
    );
}
```


The file contains the following imports:
```rust
use std::os::raw::c_char;
```
```rust
use std::boxed::Box;
```
```rust
use ::libc;
```
```rust
use std::ffi::CStr;
```
```rust
use std::convert::TryInto;
```
```rust
std::clone::Clone
```
```rust
use std::ffi::CString;
```
```rust
use std::clone::Clone;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:94 ~ rust[fc84]::src::closeout::close_stdout_set_ignore_EPIPE)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {
    ignore_EPIPE = ignore;
}
```

The function uses the following global variables:
```rust
static mut ignore_EPIPE: bool = false;
```
The file contains the following imports:
```rust
use std::ffi::CString;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:891 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctz)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn __gl_stdbit_ctz(mut n: libc::c_uint) -> libc::c_int {
    return (if n != 0 {
        n.trailing_zeros() as i32 as libc::c_ulong
    } else {
        (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
    }) as libc::c_int;
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::mem;
```
```rust
use std::u64;
```
```rust
use std::convert::TryInto;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:236 ~ rust[fc84]::src::fseeko::rpl_fseeko)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn rpl_fseeko(
    mut fp: *mut FILE,
    mut offset: off_t,
    mut whence: libc::c_int,
) -> libc::c_int {
    if (*fp)._IO_read_end == (*fp)._IO_read_ptr
        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()
    {
        let mut pos: off_t = lseek(fileno(fp), offset, whence);
        if pos == -(1 as libc::c_int) as libc::c_long {
            return -(1 as libc::c_int);
        }
        (*fp)._flags &= !(0x10 as libc::c_int);
        (*fp)._offset = pos;
        return 0 as libc::c_int;
    }
    return fseeko(fp, offset, whence);
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:724 ~ rust[fc84]::src::propername_lite::proper_name_lite)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn proper_name_lite(
    mut name_ascii: *const libc::c_char,
    mut name_utf8: *const libc::c_char,
) -> *const libc::c_char {
    let mut translation: *const libc::c_char = gettext(name_ascii);
    return if translation != name_ascii {
        translation
    } else if c_strcasecmp(
        locale_charset(),
        b"UTF-8\0" as *const u8 as *const libc::c_char,
    ) == 0 as libc::c_int
    {
        name_utf8
    } else {
        name_ascii
    };
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:893 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctzll)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn __gl_stdbit_ctzll(mut n: libc::c_ulonglong) -> libc::c_int {
    return (if n != 0 {
        n.trailing_zeros() as i32 as libc::c_ulong
    } else {
        (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)
    }) as libc::c_int;
}
```


The file contains the following imports:
```rust
use std::u64;
```
```rust
use std::mem;
```
```rust
use ::libc;
```
```rust
use std::u32;
```
```rust
use std::convert::TryInto;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:15 ~ rust[fc84]::src::alignalloc::alignalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn alignalloc(
    mut alignment: idx_t,
    mut size: idx_t,
) -> *mut libc::c_void {
    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {
        alignment = -(1 as libc::c_int) as size_t as idx_t;
    }
    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {
        size = -(1 as libc::c_int) as size_t as idx_t;
    }
    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);
}
```


The file contains the following imports:
```rust
use std::any::Any;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:941 ~ rust[fc84]::src::version_etc::emit_bug_reporting_address)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn emit_bug_reporting_address() {
    fputs_unlocked(b"\n\0" as *const u8 as *const libc::c_char, stdout);
    printf(
        gettext(b"Report bugs to: %s\n\0" as *const u8 as *const libc::c_char),
        b"bug-coreutils@gnu.org\0" as *const u8 as *const libc::c_char,
    );
    printf(
        gettext(b"%s home page: <%s>\n\0" as *const u8 as *const libc::c_char),
        b"GNU coreutils\0" as *const u8 as *const libc::c_char,
        b"https://www.gnu.org/software/coreutils/\0" as *const u8 as *const libc::c_char,
    );
    printf(
        gettext(
            b"General help using GNU software: <%s>\n\0" as *const u8
                as *const libc::c_char,
        ),
        b"https://www.gnu.org/gethelp/\0" as *const u8 as *const libc::c_char,
    );
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:793 ~ rust[fc84]::src::quotearg::set_quoting_style)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn set_quoting_style(
    mut o: *mut quoting_options,
    mut s: quoting_style,
) {
    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;
}
```

The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
The file contains the following imports:
```rust
use std::os::raw::c_char;
```
```rust
std::clone::Clone
```
```rust
use std::ffi::CString;
```
```rust
use ::libc;
```
```rust
use std::boxed::Box;
```
```rust
use std::clone::Clone;
```
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:179 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn rpl_fcntl_DUPFD(
    mut fd: libc::c_int,
    mut target: libc::c_int,
) -> libc::c_int {
    let mut result: libc::c_int = 0;
    result = fcntl(fd, 0 as libc::c_int, target);
    return result;
}
```
Here are its call sites
Call site 1:
```rust
result = rpl_fcntl_DUPFD(fd, target);
```
Call site 2:
```rust
result = rpl_fcntl_DUPFD(fd, target);
```
Call site 3:
```rust
result = rpl_fcntl_DUPFD(fd, target);
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:181 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn rpl_fcntl_DUPFD_CLOEXEC(
    mut fd: libc::c_int,
    mut target: libc::c_int,
) -> libc::c_int {
    let mut result: libc::c_int = 0;
    if 0 as libc::c_int <= have_dupfd_cloexec {
        result = fcntl(fd, 1030 as libc::c_int, target);
        if 0 as libc::c_int <= result || *__errno_location() != 22 as libc::c_int {
            have_dupfd_cloexec = 1 as libc::c_int;
        } else {
            result = rpl_fcntl_DUPFD(fd, target);
            if result >= 0 as libc::c_int {
                have_dupfd_cloexec = -(1 as libc::c_int);
            }
        }
    } else {
        result = rpl_fcntl_DUPFD(fd, target);
    }
    if 0 as libc::c_int <= result && have_dupfd_cloexec == -(1 as libc::c_int) {
        let mut flags: libc::c_int = fcntl(result, 1 as libc::c_int);
        if flags < 0 as libc::c_int
            || fcntl(result, 2 as libc::c_int, flags | 1 as libc::c_int)
                == -(1 as libc::c_int)
        {
            let mut saved_errno: libc::c_int = *__errno_location();
            close(result);
            *__errno_location() = saved_errno;
            result = -(1 as libc::c_int);
        }
    }
    return result;
}
```
Here are its call sites
Call site 1:
```rust
result = rpl_fcntl_DUPFD_CLOEXEC(fd, target_0);
```
The function uses the following global variables:
```rust
static mut have_dupfd_cloexec: libc::c_int = 0;
```
The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:178 ~ rust[fc84]::src::fcntl::rpl_fcntl)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn rpl_fcntl(
    mut fd: libc::c_int,
    mut action: libc::c_int,
    mut args: ...
) -> libc::c_int {
    let mut arg: ::core::ffi::VaListImpl;
    let mut result: libc::c_int = -(1 as libc::c_int);
    arg = args.clone();
    match action {
        0 => {
            let mut target: libc::c_int = arg.arg::<libc::c_int>();
            result = rpl_fcntl_DUPFD(fd, target);
        }
        1030 => {
            let mut target_0: libc::c_int = arg.arg::<libc::c_int>();
            result = rpl_fcntl_DUPFD_CLOEXEC(fd, target_0);
        }
        _ => {
            let mut current_block_7: u64;
            match action {
                1 => {
                    current_block_7 = 4046302689674688614;
                }
                3 => {
                    current_block_7 = 4046302689674688614;
                }
                1025 => {
                    current_block_7 = 6453289516101043606;
                }
                9 => {
                    current_block_7 = 13722137258147953758;
                }
                1032 => {
                    current_block_7 = 12766345184754617216;
                }
                1034 => {
                    current_block_7 = 6940526744265269810;
                }
                11 => {
                    current_block_7 = 7022052692272556539;
                }
                1033 => {
                    current_block_7 = 8871774344836507656;
                }
                0 => {
                    current_block_7 = 8871774344836507656;
                }
                1030 => {
                    current_block_7 = 5351856672558463576;
                }
                1026 => {
                    current_block_7 = 9332010126091029806;
                }
                2 => {
                    current_block_7 = 17966572639739034653;
                }
                4 => {
                    current_block_7 = 15280576717888187136;
                }
                8 => {
                    current_block_7 = 12013198723313890981;
                }
                1031 => {
                    current_block_7 = 12013198723313890981;
                }
                1024 | 10 => {
                    current_block_7 = 14034191772621753005;
                }
                _ => {
                    let mut p: *mut libc::c_void = arg.arg::<*mut libc::c_void>();
                    result = fcntl(fd, action, p);
                    current_block_7 = 7175849428784450219;
                }
            }
            match current_block_7 {
                4046302689674688614 => {
                    current_block_7 = 6453289516101043606;
                }
                8871774344836507656 => {
                    current_block_7 = 5351856672558463576;
                }
                12013198723313890981 => {
                    current_block_7 = 14034191772621753005;
                }
                _ => {}
            }
            match current_block_7 {
                6453289516101043606 => {
                    current_block_7 = 13722137258147953758;
                }
                5351856672558463576 => {
                    current_block_7 = 9332010126091029806;
                }
                _ => {}
            }
            match current_block_7 {
                13722137258147953758 => {
                    current_block_7 = 12766345184754617216;
                }
                9332010126091029806 => {
                    current_block_7 = 17966572639739034653;
                }
                _ => {}
            }
            match current_block_7 {
                12766345184754617216 => {
                    current_block_7 = 6940526744265269810;
                }
                17966572639739034653 => {
                    current_block_7 = 15280576717888187136;
                }
                _ => {}
            }
            match current_block_7 {
                6940526744265269810 => {
                    current_block_7 = 7022052692272556539;
                }
                15280576717888187136 => {
                    current_block_7 = 14034191772621753005;
                }
                _ => {}
            }
            match current_block_7 {
                7022052692272556539 => {
                    result = fcntl(fd, action);
                }
                14034191772621753005 => {
                    let mut x: libc::c_int = arg.arg::<libc::c_int>();
                    result = fcntl(fd, action, x);
                }
                _ => {}
            }
        }
    }
    return result;
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:254 ~ rust[fc84]::src::hard_locale::hard_locale)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn hard_locale(mut category: libc::c_int) -> bool {
    let mut locale: [libc::c_char; 257] = [0; 257];
    if setlocale_null_r(
        category,
        locale.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,
    ) != 0
    {
        return 0 as libc::c_int != 0;
    }
    if !(strcmp(locale.as_mut_ptr(), b"C\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
        || strcmp(locale.as_mut_ptr(), b"POSIX\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int)
    {
        return 1 as libc::c_int != 0;
    }
    return 0 as libc::c_int != 0;
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:36 ~ rust[fc84]::src::c_ctype::c_isprint)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_isprint(mut c: libc::c_int) -> bool {
    match c {
        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101
        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114
        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38
        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64
        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69
        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85
        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::convert::TryFrom;
```
```rust
use std::ops::RangeInclusive;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:667 ~ rust[fc84]::src::localcharset::locale_charset)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn locale_charset() -> *const libc::c_char {
    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;
    codeset = nl_langinfo(CODESET as libc::c_int);
    if codeset.is_null() {
        codeset = b"\0" as *const u8 as *const libc::c_char;
    }
    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\0' as i32 {
        codeset = b"ASCII\0" as *const u8 as *const libc::c_char;
    }
    return codeset;
}
```

The function uses the following global variables:
```rust
pub const CODESET: C2RustUnnamed = 14;
```
The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:40 ~ rust[fc84]::src::c_ctype::c_isxdigit)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_isxdigit(mut c: libc::c_int) -> bool {
    match c {
        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102
        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use std::ops::RangeInclusive;
```
```rust
use ::libc;
```
```rust
use std::convert::TryFrom;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:182 ~ rust[fc84]::src::fcntl::run_static_initializers)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn run_static_initializers() {
    have_dupfd_cloexec = if 0 as libc::c_int != 0 {
        -(1 as libc::c_int)
    } else {
        0 as libc::c_int
    };
}
```

The function uses the following global variables:
```rust
static mut have_dupfd_cloexec: libc::c_int = 0;
```
The file contains the following imports:
```rust
use std::ffi::VaList;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:28 ~ rust[fc84]::src::c_ctype::c_isalnum)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_isalnum(mut c: libc::c_int) -> bool {
    match c {
        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102
        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115
        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72
        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88
        | 89 | 90 => return 1 as libc::c_int != 0,
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use std::ops::RangeInclusive;
```
```rust
use ::libc;
```
```rust
use std::convert::TryFrom;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:35 ~ rust[fc84]::src::c_ctype::c_islower)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_islower(mut c: libc::c_int) -> bool {
    match c {
        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110
        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {
            return 1 as libc::c_int != 0;
        }
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use ::libc;
```
```rust
use std::ops::RangeInclusive;
```
```rust
use std::convert::TryFrom;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:33 ~ rust[fc84]::src::c_ctype::c_isdigit)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn c_isdigit(mut c: libc::c_int) -> bool {
    match c {
        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,
        _ => return 0 as libc::c_int != 0,
    };
}
```


The file contains the following imports:
```rust
use std::ops::RangeInclusive;
```
```rust
use ::libc;
```
```rust
use std::convert::TryFrom;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:792 ~ rust[fc84]::src::quotearg::get_quoting_style)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn get_quoting_style(
    mut o: *const quoting_options,
) -> quoting_style {
    return (*if !o.is_null() {
        o
    } else {
        &mut default_quoting_options as *mut quoting_options as *const quoting_options
    })
        .style;
}
```

The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
The file contains the following imports:
```rust
use std::boxed::Box;
```
```rust
use std::convert::TryInto;
```
```rust
use std::clone::Clone;
```
```rust
use std::option::Option;
```
```rust
std::clone::Clone
```
```rust
use std::os::raw::c_char;
```
```rust
use std::ffi::CStr;
```
```rust
use std::ffi::CString;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:95 ~ rust[fc84]::src::closeout::close_stdout)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn close_stdout() {
    if close_stream(stdout) != 0 as libc::c_int
        && !(ignore_EPIPE as libc::c_int != 0
            && *__errno_location() == 32 as libc::c_int)
    {
        let mut write_error: *const libc::c_char = gettext(
            b"write error\0" as *const u8 as *const libc::c_char,
        );
        if !file_name.is_null() {
            if 0 != 0 {
                error(
                    0 as libc::c_int,
                    *__errno_location(),
                    b"%s: %s\0" as *const u8 as *const libc::c_char,
                    quotearg_colon(file_name),
                    write_error,
                );
                if 0 as libc::c_int != 0 as libc::c_int {
                    unreachable!();
                } else {};
            } else {
                ({
                    let __errstatus: libc::c_int = 0 as libc::c_int;
                    error(
                        __errstatus,
                        *__errno_location(),
                        b"%s: %s\0" as *const u8 as *const libc::c_char,
                        quotearg_colon(file_name),
                        write_error,
                    );
                    if __errstatus != 0 as libc::c_int {
                        unreachable!();
                    } else {};
                    
                });
                ({
                    let __errstatus: libc::c_int = 0 as libc::c_int;
                    error(
                        __errstatus,
                        *__errno_location(),
                        b"%s: %s\0" as *const u8 as *const libc::c_char,
                        quotearg_colon(file_name),
                        write_error,
                    );
                    if __errstatus != 0 as libc::c_int {
                        unreachable!();
                    } else {};
                    
                });
            };
        } else {
            if 0 != 0 {
                error(
                    0 as libc::c_int,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    write_error,
                );
                if 0 as libc::c_int != 0 as libc::c_int {
                    unreachable!();
                } else {};
            } else {
                ({
                    let __errstatus: libc::c_int = 0 as libc::c_int;
                    error(
                        __errstatus,
                        *__errno_location(),
                        b"%s\0" as *const u8 as *const libc::c_char,
                        write_error,
                    );
                    if __errstatus != 0 as libc::c_int {
                        unreachable!();
                    } else {};
                    
                });
                ({
                    let __errstatus: libc::c_int = 0 as libc::c_int;
                    error(
                        __errstatus,
                        *__errno_location(),
                        b"%s\0" as *const u8 as *const libc::c_char,
                        write_error,
                    );
                    if __errstatus != 0 as libc::c_int {
                        unreachable!();
                    } else {};
                    
                });
            };
        }
        _exit(exit_failure);
    }
    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {
        _exit(exit_failure);
    }
}
```

The function uses the following global variables:
```rust
static mut file_name: *const libc::c_char = 0 as *const libc::c_char;
```
The file contains the following imports:
```rust
use std::ffi::CString;
```
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1009 ~ rust[fc84]::src::xmalloc::xrealloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xrealloc(
    mut p: *mut libc::c_void,
    mut s: size_t,
) -> *mut libc::c_void {
    let mut r: *mut libc::c_void = realloc(p, s);
    if r.is_null() && (p.is_null() || s != 0) {
        xalloc_die();
    }
    return r;
}
```
Here are its call sites
Call site 1:
```rust
pa = xrealloc(pa, nbytes as size_t);
```

The file contains the following imports:
```rust
use std::string::String;
```
```rust
alloc
```
```rust
dealloc
```
```rust
use std::alloc::{alloc, dealloc, Layout};
```
```rust
use ::libc;
```
```rust
use std::slice;
```
```rust
use std::vec::Vec;
```
```rust
Layout
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:1017 ~ rust[fc84]::src::xmalloc::xpalloc)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn xpalloc(
    mut pa: *mut libc::c_void,
    mut pn: *mut idx_t,
    mut n_incr_min: idx_t,
    mut n_max: ptrdiff_t,
    mut s: idx_t,
) -> *mut libc::c_void {
    let mut n0: idx_t = *pn;
    let mut n: idx_t = 0;
    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);
    *(&mut n as *mut idx_t) = fresh2;
    if fresh3 {
        n = 9223372036854775807 as libc::c_long;
    }
    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {
        n = n_max;
    }
    let mut nbytes: idx_t = 0;
    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)
        < -(1 as libc::c_int) as idx_t
        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })
            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long
        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })
            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long
        && (if s < 0 as libc::c_int as libc::c_long {
            if n < 0 as libc::c_int as libc::c_long {
                if ((if 1 as libc::c_int != 0 {
                    0 as libc::c_int as libc::c_long
                } else {
                    (if 1 as libc::c_int != 0 {
                        0 as libc::c_int as libc::c_long
                    } else {
                        -(1 as libc::c_int) as idx_t
                    }) + s
                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long
                {
                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int
                } else {
                    ((if (if (if ((if 1 as libc::c_int != 0 {
                        0 as libc::c_int as libc::c_long
                    } else {
                        s
                    }) - 1 as libc::c_int as libc::c_long)
                        < 0 as libc::c_int as libc::c_long
                    {
                        !(((((if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            s
                        }) + 1 as libc::c_int as libc::c_long)
                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)
                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                            - 1 as libc::c_int as libc::c_long)
                            * 2 as libc::c_int as libc::c_long
                            + 1 as libc::c_int as libc::c_long)
                    } else {
                        (if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            s
                        }) + 0 as libc::c_int as libc::c_long
                    }) < 0 as libc::c_int as libc::c_long
                    {
                        (s
                            < -(if ((if 1 as libc::c_int != 0 {
                                0 as libc::c_int as libc::c_long
                            } else {
                                s
                            }) - 1 as libc::c_int as libc::c_long)
                                < 0 as libc::c_int as libc::c_long
                            {
                                ((((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    s
                                }) + 1 as libc::c_int as libc::c_long)
                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)
                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                    - 1 as libc::c_int as libc::c_long)
                                    * 2 as libc::c_int as libc::c_long
                                    + 1 as libc::c_int as libc::c_long
                            } else {
                                (if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    s
                                }) - 1 as libc::c_int as libc::c_long
                            })) as libc::c_int
                    } else {
                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int
                    }) != 0
                    {
                        (if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            s
                        }) + -(1 as libc::c_int) as idx_t
                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)
                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    } else {
                        -(1 as libc::c_int) as idx_t / -s
                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int
                }
            } else {
                if (if (if ((if 1 as libc::c_int != 0 {
                    0 as libc::c_int as libc::c_long
                } else {
                    (if 1 as libc::c_int != 0 {
                        0 as libc::c_int as libc::c_long
                    } else {
                        s
                    }) + 0 as libc::c_int as idx_t
                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long
                {
                    !(((((if 1 as libc::c_int != 0 {
                        0 as libc::c_int as libc::c_long
                    } else {
                        (if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            s
                        }) + 0 as libc::c_int as idx_t
                    }) + 1 as libc::c_int as libc::c_long)
                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                        - 1 as libc::c_int as libc::c_long)
                        * 2 as libc::c_int as libc::c_long
                        + 1 as libc::c_int as libc::c_long)
                } else {
                    (if 1 as libc::c_int != 0 {
                        0 as libc::c_int as libc::c_long
                    } else {
                        (if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            s
                        }) + 0 as libc::c_int as idx_t
                    }) + 0 as libc::c_int as libc::c_long
                }) < 0 as libc::c_int as libc::c_long
                {
                    (((if 1 as libc::c_int != 0 {
                        0 as libc::c_int as libc::c_long
                    } else {
                        s
                    }) + 0 as libc::c_int as idx_t)
                        < -(if ((if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            (if 1 as libc::c_int != 0 {
                                0 as libc::c_int as libc::c_long
                            } else {
                                s
                            }) + 0 as libc::c_int as idx_t
                        }) - 1 as libc::c_int as libc::c_long)
                            < 0 as libc::c_int as libc::c_long
                        {
                            ((((if 1 as libc::c_int != 0 {
                                0 as libc::c_int as libc::c_long
                            } else {
                                (if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    s
                                }) + 0 as libc::c_int as idx_t
                            }) + 1 as libc::c_int as libc::c_long)
                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                - 1 as libc::c_int as libc::c_long)
                                * 2 as libc::c_int as libc::c_long
                                + 1 as libc::c_int as libc::c_long
                        } else {
                            (if 1 as libc::c_int != 0 {
                                0 as libc::c_int as libc::c_long
                            } else {
                                (if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    s
                                }) + 0 as libc::c_int as idx_t
                            }) - 1 as libc::c_int as libc::c_long
                        })) as libc::c_int
                } else {
                    ((0 as libc::c_int as libc::c_long)
                        < (if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            s
                        }) + 0 as libc::c_int as idx_t) as libc::c_int
                }) != 0 && s == -(1 as libc::c_int) as libc::c_long
                {
                    if ((if 1 as libc::c_int != 0 {
                        0 as libc::c_int as libc::c_long
                    } else {
                        n
                    }) - 1 as libc::c_int as libc::c_long)
                        < 0 as libc::c_int as libc::c_long
                    {
                        ((0 as libc::c_int as libc::c_long)
                            < n + 0 as libc::c_int as idx_t) as libc::c_int
                    } else {
                        ((0 as libc::c_int as libc::c_long) < n
                            && (-(1 as libc::c_int) as libc::c_long
                                - 0 as libc::c_int as idx_t)
                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int
                    }
                } else {
                    (0 as libc::c_int as idx_t / s < n) as libc::c_int
                }
            }
        } else {
            if s == 0 as libc::c_int as libc::c_long {
                0 as libc::c_int
            } else {
                if n < 0 as libc::c_int as libc::c_long {
                    if (if (if ((if 1 as libc::c_int != 0 {
                        0 as libc::c_int as libc::c_long
                    } else {
                        (if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            n
                        }) + 0 as libc::c_int as idx_t
                    }) - 1 as libc::c_int as libc::c_long)
                        < 0 as libc::c_int as libc::c_long
                    {
                        !(((((if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            (if 1 as libc::c_int != 0 {
                                0 as libc::c_int as libc::c_long
                            } else {
                                n
                            }) + 0 as libc::c_int as idx_t
                        }) + 1 as libc::c_int as libc::c_long)
                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                            - 1 as libc::c_int as libc::c_long)
                            * 2 as libc::c_int as libc::c_long
                            + 1 as libc::c_int as libc::c_long)
                    } else {
                        (if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            (if 1 as libc::c_int != 0 {
                                0 as libc::c_int as libc::c_long
                            } else {
                                n
                            }) + 0 as libc::c_int as idx_t
                        }) + 0 as libc::c_int as libc::c_long
                    }) < 0 as libc::c_int as libc::c_long
                    {
                        (((if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            n
                        }) + 0 as libc::c_int as idx_t)
                            < -(if ((if 1 as libc::c_int != 0 {
                                0 as libc::c_int as libc::c_long
                            } else {
                                (if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    n
                                }) + 0 as libc::c_int as idx_t
                            }) - 1 as libc::c_int as libc::c_long)
                                < 0 as libc::c_int as libc::c_long
                            {
                                ((((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        n
                                    }) + 0 as libc::c_int as idx_t
                                }) + 1 as libc::c_int as libc::c_long)
                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                    - 1 as libc::c_int as libc::c_long)
                                    * 2 as libc::c_int as libc::c_long
                                    + 1 as libc::c_int as libc::c_long
                            } else {
                                (if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        n
                                    }) + 0 as libc::c_int as idx_t
                                }) - 1 as libc::c_int as libc::c_long
                            })) as libc::c_int
                    } else {
                        ((0 as libc::c_int as libc::c_long)
                            < (if 1 as libc::c_int != 0 {
                                0 as libc::c_int as libc::c_long
                            } else {
                                n
                            }) + 0 as libc::c_int as idx_t) as libc::c_int
                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long
                    {
                        if ((if 1 as libc::c_int != 0 {
                            0 as libc::c_int as libc::c_long
                        } else {
                            s
                        }) - 1 as libc::c_int as libc::c_long)
                            < 0 as libc::c_int as libc::c_long
                        {
                            ((0 as libc::c_int as libc::c_long)
                                < s + 0 as libc::c_int as idx_t) as libc::c_int
                        } else {
                            ((-(1 as libc::c_int) as libc::c_long
                                - 0 as libc::c_int as idx_t)
                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int
                        }
                    } else {
                        (0 as libc::c_int as idx_t / n < s) as libc::c_int
                    }
                } else {
                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int
                }
            }
        }) != 0
    {
        let (fresh8, _fresh9) = n.overflowing_mul(s);
        *(&mut nbytes as *mut idx_t) = fresh8;
        1 as libc::c_int
    } else {
        let (fresh10, fresh11) = n.overflowing_mul(s);
        *(&mut nbytes as *mut idx_t) = fresh10;
        fresh11 as libc::c_int
    } != 0
    {
        if (9223372036854775807 as libc::c_long as libc::c_ulong)
            < 18446744073709551615 as libc::c_ulong
        {
            9223372036854775807 as libc::c_long as libc::c_ulong
        } else {
            18446744073709551615 as libc::c_ulong
        }
    } else {
        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {
            DEFAULT_MXFAST_0 as libc::c_int
        } else {
            0 as libc::c_int
        }) as libc::c_ulong
    }) as idx_t;
    if adjusted_nbytes != 0 {
        n = adjusted_nbytes / s;
        nbytes = adjusted_nbytes - adjusted_nbytes % s;
    }
    if pa.is_null() {
        *pn = 0 as libc::c_int as idx_t;
    }
    if n - n0 < n_incr_min
        && {
            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);
            *(&mut n as *mut idx_t) = fresh12;
            fresh13 as libc::c_int != 0
                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n
                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t
                    && ((if 1 as libc::c_int != 0 {
                        0 as libc::c_int as libc::c_long
                    } else {
                        n
                    }) - 1 as libc::c_int as libc::c_long)
                        < 0 as libc::c_int as libc::c_long
                    && ((if 1 as libc::c_int != 0 {
                        0 as libc::c_int as libc::c_long
                    } else {
                        s
                    }) - 1 as libc::c_int as libc::c_long)
                        < 0 as libc::c_int as libc::c_long
                    && (if s < 0 as libc::c_int as libc::c_long {
                        if n < 0 as libc::c_int as libc::c_long {
                            if ((if 1 as libc::c_int != 0 {
                                0 as libc::c_int as libc::c_long
                            } else {
                                (if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    -(1 as libc::c_int) as idx_t
                                }) + s
                            }) - 1 as libc::c_int as libc::c_long)
                                < 0 as libc::c_int as libc::c_long
                            {
                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int
                            } else {
                                ((if (if (if ((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    s
                                }) - 1 as libc::c_int as libc::c_long)
                                    < 0 as libc::c_int as libc::c_long
                                {
                                    !(((((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        s
                                    }) + 1 as libc::c_int as libc::c_long)
                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)
                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                        - 1 as libc::c_int as libc::c_long)
                                        * 2 as libc::c_int as libc::c_long
                                        + 1 as libc::c_int as libc::c_long)
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        s
                                    }) + 0 as libc::c_int as libc::c_long
                                }) < 0 as libc::c_int as libc::c_long
                                {
                                    (s
                                        < -(if ((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            s
                                        }) - 1 as libc::c_int as libc::c_long)
                                            < 0 as libc::c_int as libc::c_long
                                        {
                                            ((((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                s
                                            }) + 1 as libc::c_int as libc::c_long)
                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)
                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                - 1 as libc::c_int as libc::c_long)
                                                * 2 as libc::c_int as libc::c_long
                                                + 1 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                s
                                            }) - 1 as libc::c_int as libc::c_long
                                        })) as libc::c_int
                                } else {
                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int
                                }) != 0
                                {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        s
                                    }) + -(1 as libc::c_int) as idx_t
                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)
                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                } else {
                                    -(1 as libc::c_int) as idx_t / -s
                                }) <= -(1 as libc::c_int) as libc::c_long - n)
                                    as libc::c_int
                            }
                        } else {
                            if (if (if ((if 1 as libc::c_int != 0 {
                                0 as libc::c_int as libc::c_long
                            } else {
                                (if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    s
                                }) + 0 as libc::c_int as idx_t
                            }) - 1 as libc::c_int as libc::c_long)
                                < 0 as libc::c_int as libc::c_long
                            {
                                !(((((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        s
                                    }) + 0 as libc::c_int as idx_t
                                }) + 1 as libc::c_int as libc::c_long)
                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                    - 1 as libc::c_int as libc::c_long)
                                    * 2 as libc::c_int as libc::c_long
                                    + 1 as libc::c_int as libc::c_long)
                            } else {
                                (if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        s
                                    }) + 0 as libc::c_int as idx_t
                                }) + 0 as libc::c_int as libc::c_long
                            }) < 0 as libc::c_int as libc::c_long
                            {
                                (((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    s
                                }) + 0 as libc::c_int as idx_t)
                                    < -(if ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            s
                                        }) + 0 as libc::c_int as idx_t
                                    }) - 1 as libc::c_int as libc::c_long)
                                        < 0 as libc::c_int as libc::c_long
                                    {
                                        ((((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                s
                                            }) + 0 as libc::c_int as idx_t
                                        }) + 1 as libc::c_int as libc::c_long)
                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                            - 1 as libc::c_int as libc::c_long)
                                            * 2 as libc::c_int as libc::c_long
                                            + 1 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                s
                                            }) + 0 as libc::c_int as idx_t
                                        }) - 1 as libc::c_int as libc::c_long
                                    })) as libc::c_int
                            } else {
                                ((0 as libc::c_int as libc::c_long)
                                    < (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        s
                                    }) + 0 as libc::c_int as idx_t) as libc::c_int
                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long
                            {
                                if ((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    n
                                }) - 1 as libc::c_int as libc::c_long)
                                    < 0 as libc::c_int as libc::c_long
                                {
                                    ((0 as libc::c_int as libc::c_long)
                                        < n + 0 as libc::c_int as idx_t) as libc::c_int
                                } else {
                                    ((0 as libc::c_int as libc::c_long) < n
                                        && (-(1 as libc::c_int) as libc::c_long
                                            - 0 as libc::c_int as idx_t)
                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int
                                }
                            } else {
                                (0 as libc::c_int as idx_t / s < n) as libc::c_int
                            }
                        }
                    } else {
                        if s == 0 as libc::c_int as libc::c_long {
                            0 as libc::c_int
                        } else {
                            if n < 0 as libc::c_int as libc::c_long {
                                if (if (if ((if 1 as libc::c_int != 0 {
                                    0 as libc::c_int as libc::c_long
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        n
                                    }) + 0 as libc::c_int as idx_t
                                }) - 1 as libc::c_int as libc::c_long)
                                    < 0 as libc::c_int as libc::c_long
                                {
                                    !(((((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            n
                                        }) + 0 as libc::c_int as idx_t
                                    }) + 1 as libc::c_int as libc::c_long)
                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                        - 1 as libc::c_int as libc::c_long)
                                        * 2 as libc::c_int as libc::c_long
                                        + 1 as libc::c_int as libc::c_long)
                                } else {
                                    (if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            n
                                        }) + 0 as libc::c_int as idx_t
                                    }) + 0 as libc::c_int as libc::c_long
                                }) < 0 as libc::c_int as libc::c_long
                                {
                                    (((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        n
                                    }) + 0 as libc::c_int as idx_t)
                                        < -(if ((if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                n
                                            }) + 0 as libc::c_int as idx_t
                                        }) - 1 as libc::c_int as libc::c_long)
                                            < 0 as libc::c_int as libc::c_long
                                        {
                                            ((((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    n
                                                }) + 0 as libc::c_int as idx_t
                                            }) + 1 as libc::c_int as libc::c_long)
                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                - 1 as libc::c_int as libc::c_long)
                                                * 2 as libc::c_int as libc::c_long
                                                + 1 as libc::c_int as libc::c_long
                                        } else {
                                            (if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    n
                                                }) + 0 as libc::c_int as idx_t
                                            }) - 1 as libc::c_int as libc::c_long
                                        })) as libc::c_int
                                } else {
                                    ((0 as libc::c_int as libc::c_long)
                                        < (if 1 as libc::c_int != 0 {
                                            0 as libc::c_int as libc::c_long
                                        } else {
                                            n
                                        }) + 0 as libc::c_int as idx_t) as libc::c_int
                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long
                                {
                                    if ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        s
                                    }) - 1 as libc::c_int as libc::c_long)
                                        < 0 as libc::c_int as libc::c_long
                                    {
                                        ((0 as libc::c_int as libc::c_long)
                                            < s + 0 as libc::c_int as idx_t) as libc::c_int
                                    } else {
                                        ((-(1 as libc::c_int) as libc::c_long
                                            - 0 as libc::c_int as idx_t)
                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int
                                    }
                                } else {
                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int
                                }
                            } else {
                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int
                            }
                        }
                    }) != 0
                {
                    let (fresh18, _fresh19) = n.overflowing_mul(s);
                    *(&mut nbytes as *mut idx_t) = fresh18;
                    1 as libc::c_int
                } else {
                    let (fresh20, fresh21) = n.overflowing_mul(s);
                    *(&mut nbytes as *mut idx_t) = fresh20;
                    fresh21 as libc::c_int
                }) != 0
        }
    {
        xalloc_die();
    }
    pa = xrealloc(pa, nbytes as size_t);
    *pn = n;
    return pa;
}
```

The function uses the following global variables:
```rust
pub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;
```
The file contains the following imports:
```rust
use std::string::String;
```
```rust
use std::alloc::{alloc, dealloc, Layout};
```
```rust
use std::slice;
```
```rust
use std::vec::Vec;
```
```rust
Layout
```
```rust
use ::libc;
```
```rust
alloc
```
```rust
dealloc
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:146 ~ rust[fc84]::src::fadvise::fdadvise)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn fdadvise(
    mut fd: libc::c_int,
    mut offset: off_t,
    mut len: off_t,
    mut advice: fadvice_t,
) {
    posix_fadvise(fd, offset, len, advice as libc::c_int);
}
```
Here are its call sites
Call site 1:
```rust
fdadvise(
            fileno(fp),
            0 as libc::c_int as off_t,
            0 as libc::c_int as off_t,
            advice,
        );
```

The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:147 ~ rust[fc84]::src::fadvise::fadvise)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn fadvise(mut fp: *mut FILE, mut advice: fadvice_t) {
    if !fp.is_null() {
        fdadvise(
            fileno(fp),
            0 as libc::c_int as off_t,
            0 as libc::c_int as off_t,
            advice,
        );
    }
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:167 ~ rust[fc84]::src::fclose::rpl_fclose)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {
    let mut saved_errno: libc::c_int = 0 as libc::c_int;
    let mut fd: libc::c_int = 0;
    let mut result: libc::c_int = 0 as libc::c_int;
    fd = fileno(fp);
    if fd < 0 as libc::c_int {
        return fclose(fp);
    }
    if (!(__freading(fp) != 0 as libc::c_int)
        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)
            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0
    {
        saved_errno = *__errno_location();
    }
    result = fclose(fp);
    if saved_errno != 0 as libc::c_int {
        *__errno_location() = saved_errno;
        result = -(1 as libc::c_int);
    }
    return result;
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:783 ~ rust[fc84]::src::quotearg::c32isprint)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn c32isprint(mut wc: wint_t) -> libc::c_int {
    return iswprint(wc);
}
```


The file contains the following imports:
```rust
use std::option::Option;
```
```rust
use ::libc;
```
```rust
use std::ffi::CString;
```
```rust
use std::boxed::Box;
```
```rust
use std::clone::Clone;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CStr;
```
```rust
std::clone::Clone
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:795 ~ rust[fc84]::src::quotearg::set_quoting_flags)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn set_quoting_flags(
    mut o: *mut quoting_options,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut r: libc::c_int = 0;
    if o.is_null() {
        o = &mut default_quoting_options;
    }
    r = (*o).flags;
    (*o).flags = i;
    return r;
}
```

The function uses the following global variables:
```rust
static mut default_quoting_options: quoting_options = quoting_options {
    style: literal_quoting_style,
    flags: 0,
    quote_these_too: [0; 8],
    left_quote: 0 as *const libc::c_char,
    right_quote: 0 as *const libc::c_char,
};
```
The file contains the following imports:
```rust
use std::option::Option;
```
```rust
use std::os::raw::c_char;
```
```rust
std::clone::Clone
```
```rust
use std::clone::Clone;
```
```rust
use std::convert::TryInto;
```
```rust
use std::ffi::CString;
```
```rust
use std::boxed::Box;
```
```rust
use ::libc;
```
```rust
use std::ffi::CStr;
```
```rust
use std::os::raw::c_int;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:218 ~ rust[fc84]::src::fpurge::fpurge)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn fpurge(mut fp: *mut FILE) -> libc::c_int {
    __fpurge(fp);
    return 0 as libc::c_int;
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:66 ~ rust[fc84]::src::close_stream::close_stream)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn close_stream(mut stream: *mut FILE) -> libc::c_int {
    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;
    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;
    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;
    if prev_fail as libc::c_int != 0
        || fclose_fail as libc::c_int != 0
            && (some_pending as libc::c_int != 0
                || *__errno_location() != 9 as libc::c_int)
    {
        if !fclose_fail {
            *__errno_location() = 0 as libc::c_int;
        }
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
```


The file contains the following imports:
```rust
use ::libc;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:105 ~ cat[4a5d]::__gl_stdbit_clzll)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {
    return (if n != 0 {
        n.leading_zeros() as i32 as libc::c_ulong
    } else {
        (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)
    }) as libc::c_int;
}
```
Here are its call sites
Call site 1:
```rust
return __gl_stdbit_clzll(n) as libc::c_uint;
```

The file contains the following imports:
```rust
use ::rust::*;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:103 ~ cat[4a5d]::write_error)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn write_error() {
    let mut saved_errno: libc::c_int = *__errno_location();
    fflush_unlocked(stdout);
    fpurge(stdout);
    clearerr_unlocked(stdout);
    if 0 != 0 {
        error(
            1 as libc::c_int,
            saved_errno,
            gettext(b"write error\0" as *const u8 as *const libc::c_char),
        );
        if 1 as libc::c_int != 0 as libc::c_int {
            unreachable!();
        } else {};
    } else {
        ({
            let __errstatus: libc::c_int = 1 as libc::c_int;
            error(
                __errstatus,
                saved_errno,
                gettext(b"write error\0" as *const u8 as *const libc::c_char),
            );
            if __errstatus != 0 as libc::c_int {
                unreachable!();
            } else {};
            
        });
        ({
            let __errstatus: libc::c_int = 1 as libc::c_int;
            error(
                __errstatus,
                saved_errno,
                gettext(b"write error\0" as *const u8 as *const libc::c_char),
            );
            if __errstatus != 0 as libc::c_int {
                unreachable!();
            } else {};
            
        });
    };
}
```
Here are its call sites
Call site 1:
```rust
write_error();
```
Call site 2:
```rust
write_error();
```
Call site 3:
```rust
write_error();
```
Call site 4:
```rust
write_error();
```

The file contains the following imports:
```rust
use ::rust::*;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:99 ~ cat[4a5d]::emit_stdin_note)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn emit_stdin_note() {
    fputs_unlocked(
        gettext(
            b"\nWith no FILE, or when FILE is -, read standard input.\n\0" as *const u8
                as *const libc::c_char,
        ),
        stdout,
    );
}
```
Here are its call sites
Call site 1:
```rust
emit_stdin_note();
```

The file contains the following imports:
```rust
use std::io::Write;
```
```rust
use ::rust::*;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:100 ~ cat[4a5d]::emit_ancillary_info)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn emit_ancillary_info(mut program: *const libc::c_char) {
    let infomap_0: [infomap; 7] = [
        {
            let mut init = infomap {
                program: b"[\0" as *const u8 as *const libc::c_char,
                node: b"test invocation\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = infomap {
                program: b"coreutils\0" as *const u8 as *const libc::c_char,
                node: b"Multi-call invocation\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = infomap {
                program: b"sha224sum\0" as *const u8 as *const libc::c_char,
                node: b"sha2 utilities\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = infomap {
                program: b"sha256sum\0" as *const u8 as *const libc::c_char,
                node: b"sha2 utilities\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = infomap {
                program: b"sha384sum\0" as *const u8 as *const libc::c_char,
                node: b"sha2 utilities\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = infomap {
                program: b"sha512sum\0" as *const u8 as *const libc::c_char,
                node: b"sha2 utilities\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = infomap {
                program: 0 as *const libc::c_char,
                node: 0 as *const libc::c_char,
            };
            init
        },
    ];
    let mut node: *const libc::c_char = program;
    let mut map_prog: *const infomap = infomap_0.as_ptr();
    while !((*map_prog).program).is_null()
        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)
    {
        map_prog = map_prog.offset(1);
        map_prog;
    }
    if !((*map_prog).node).is_null() {
        node = (*map_prog).node;
    }
    printf(
        gettext(b"\n%s online help: <%s>\n\0" as *const u8 as *const libc::c_char),
        b"GNU coreutils\0" as *const u8 as *const libc::c_char,
        b"https://www.gnu.org/software/coreutils/\0" as *const u8 as *const libc::c_char,
    );
    let mut lc_messages: *const libc::c_char = setlocale(
        5 as libc::c_int,
        0 as *const libc::c_char,
    );
    if !lc_messages.is_null()
        && strncmp(
            lc_messages,
            b"en_\0" as *const u8 as *const libc::c_char,
            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
        ) != 0
    {
        fputs_unlocked(
            gettext(
                b"Report any translation bugs to <https://translationproject.org/team/>\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
    }
    let mut url_program: *const libc::c_char = if strcmp(
        program,
        b"[\0" as *const u8 as *const libc::c_char,
    ) == 0 as libc::c_int
    {
        b"test\0" as *const u8 as *const libc::c_char
    } else {
        program
    };
    printf(
        gettext(b"Full documentation <%s%s>\n\0" as *const u8 as *const libc::c_char),
        b"https://www.gnu.org/software/coreutils/\0" as *const u8 as *const libc::c_char,
        url_program,
    );
    printf(
        gettext(
            b"or available locally via: info '(coreutils) %s%s'\n\0" as *const u8
                as *const libc::c_char,
        ),
        node,
        if node == program {
            b" invocation\0" as *const u8 as *const libc::c_char
        } else {
            b"\0" as *const u8 as *const libc::c_char
        },
    );
}
```
Here are its call sites
Call site 1:
```rust
emit_ancillary_info(b"cat\0" as *const u8 as *const libc::c_char);
```

The file contains the following imports:
```rust
use ::rust::*;
```
```rust
use std::io::Write;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:106 ~ cat[4a5d]::stdc_leading_zeros_ull)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn stdc_leading_zeros_ull(mut n: libc::c_ulonglong) -> libc::c_uint {
    return __gl_stdbit_clzll(n) as libc::c_uint;
}
```
Here are its call sites
Call site 1:
```rust
let mut leading_zeros: libc::c_int = stdc_leading_zeros_ull(
            blocksize as libc::c_ulonglong,
        ) as libc::c_int;
```

The file contains the following imports:
```rust
use std::os::raw::c_char;
```
```rust
use ::rust::*;
```
```rust
use std::io::Write;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:110 ~ cat[4a5d]::xset_binary_mode_error)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn xset_binary_mode_error() {}
```
Here are its call sites
Call site 1:
```rust
xset_binary_mode_error();
```

The file contains the following imports:
```rust
use std::os::raw::c_char;
```
```rust
use std::io::Write;
```
```rust
use std::ffi::CStr;
```
```rust
use ::rust::*;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:124 ~ cat[4a5d]::write_pending)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn write_pending(
    mut outbuf: *mut libc::c_char,
    mut bpout: *mut *mut libc::c_char,
) {
    let mut n_write: idx_t = (*bpout).offset_from(outbuf) as libc::c_long;
    if (0 as libc::c_int as libc::c_long) < n_write {
        if full_write(1 as libc::c_int, outbuf as *const libc::c_void, n_write as size_t)
            != n_write as libc::c_ulong
        {
            write_error();
        }
        *bpout = outbuf;
    }
}
```
Here are its call sites
Call site 1:
```rust
write_pending(outbuf, &mut bpout);
```
Call site 2:
```rust
write_pending(outbuf, &mut bpout);
```
Call site 3:
```rust
write_pending(outbuf, &mut bpout);
```

The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use std::io::Write;
```
```rust
use std::os::raw::c_char;
```
```rust
use ::rust::*;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:122 ~ cat[4a5d]::next_line_num)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn next_line_num() {
    let mut endp: *mut libc::c_char = line_num_end;
    loop {
        let fresh0 = *endp;
        *endp = *endp + 1;
        if (fresh0 as libc::c_int) < '9' as i32 {
            return;
        }
        let fresh1 = endp;
        endp = endp.offset(-1);
        *fresh1 = '0' as i32 as libc::c_char;
        if !(endp >= line_num_start) {
            break;
        }
    }
    if line_num_start > line_buf.as_mut_ptr() {
        line_num_start = line_num_start.offset(-1);
        *line_num_start = '1' as i32 as libc::c_char;
    } else {
        *line_buf.as_mut_ptr() = '>' as i32 as libc::c_char;
    }
    if line_num_start < line_num_print {
        line_num_print = line_num_print.offset(-1);
        line_num_print;
    }
}
```
Here are its call sites
Call site 1:
```rust
next_line_num();
```
Call site 2:
```rust
next_line_num();
```
The function uses the following global variables:
```rust
static mut line_num_print: *mut libc::c_char = 0 as *const libc::c_char
    as *mut libc::c_char;
```
```rust
static mut line_num_end: *mut libc::c_char = 0 as *const libc::c_char
    as *mut libc::c_char;
```
```rust
static mut line_buf: [libc::c_char; 20] = [
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\0' as i32 as libc::c_char,
];
```
```rust
static mut line_num_start: *mut libc::c_char = 0 as *const libc::c_char
    as *mut libc::c_char;
```
The file contains the following imports:
```rust
use std::os::raw::c_char;
```
```rust
use ::rust::*;
```
```rust
use std::ffi::CStr;
```
```rust
use std::io::Write;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:121 ~ cat[4a5d]::usage)
Chunk root
Here is a function:
```rust
pub unsafe extern "C" fn usage(mut status: libc::c_int) {
    if status != 0 as libc::c_int {
        fprintf(
            stderr,
            gettext(
                b"Try '%s --help' for more information.\n\0" as *const u8
                    as *const libc::c_char,
            ),
            program_name,
        );
    } else {
        printf(
            gettext(
                b"Usage: %s [OPTION]... [FILE]...\n\0" as *const u8
                    as *const libc::c_char,
            ),
            program_name,
        );
        fputs_unlocked(
            gettext(
                b"Concatenate FILE(s) to standard output.\n\0" as *const u8
                    as *const libc::c_char,
            ),
            stdout,
        );
        emit_stdin_note();
        fputs_unlocked(
            gettext(
                b"\n  -A, --show-all           equivalent to -vET\n  -b, --number-nonblank    number nonempty output lines, overrides -n\n  -e                       equivalent to -vE\n  -E, --show-ends          display $ at end of each line\n  -n, --number             number all output lines\n  -s, --squeeze-blank      suppress repeated empty output lines\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"  -t                       equivalent to -vT\n  -T, --show-tabs          display TAB characters as ^I\n  -u                       (ignored)\n  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"      --help        display this help and exit\n\0" as *const u8
                    as *const libc::c_char,
            ),
            stdout,
        );
        fputs_unlocked(
            gettext(
                b"      --version     output version information and exit\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            stdout,
        );
        printf(
            gettext(
                b"\nExamples:\n  %s f - g  Output f's contents, then standard input, then g's contents.\n  %s        Copy standard input to standard output.\n\0"
                    as *const u8 as *const libc::c_char,
            ),
            program_name,
            program_name,
        );
        emit_ancillary_info(b"cat\0" as *const u8 as *const libc::c_char);
    }
    exit(status);
}
```
Here are its call sites
Call site 1:
```rust
usage(0 as libc::c_int);
```
Call site 2:
```rust
usage(1 as libc::c_int);
```

The file contains the following imports:
```rust
use std::os::raw::c_char;
```
```rust
use ::rust::*;
```
```rust
use std::ffi::CStr;
```
```rust
use std::io::Write;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:107 ~ cat[4a5d]::io_blksize)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn io_blksize(mut st: *const stat) -> idx_t {
    let mut blocksize: idx_t = (if (if (0 as libc::c_int) < (*st).st_blksize
        && (*st).st_blksize as libc::c_ulong
            <= (-(1 as libc::c_int) as size_t)
                .wrapping_div(8 as libc::c_int as libc::c_ulong)
                .wrapping_add(1 as libc::c_int as libc::c_ulong)
    {
        (*st).st_blksize
    } else {
        512 as libc::c_int
    }) <= 0 as libc::c_int
    {
        IO_BUFSIZE as libc::c_int
    } else if (0 as libc::c_int) < (*st).st_blksize
        && (*st).st_blksize as libc::c_ulong
            <= (-(1 as libc::c_int) as size_t)
                .wrapping_div(8 as libc::c_int as libc::c_ulong)
                .wrapping_add(1 as libc::c_int as libc::c_ulong)
    {
        (*st).st_blksize
    } else {
        512 as libc::c_int
    }) as idx_t;
    blocksize
        += (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long
            - (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long % blocksize;
    if (*st).st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o100000 as libc::c_int as libc::c_uint
        && blocksize & blocksize - 1 as libc::c_int as libc::c_long != 0
    {
        let mut leading_zeros: libc::c_int = stdc_leading_zeros_ull(
            blocksize as libc::c_ulonglong,
        ) as libc::c_int;
        if (9223372036854775807 as libc::c_long as libc::c_ulonglong)
            < (9223372036854775807 as libc::c_longlong as libc::c_ulonglong)
                .wrapping_mul(2 as libc::c_ulonglong)
                .wrapping_add(1 as libc::c_ulonglong) || leading_zeros != 0
        {
            let mut power: libc::c_ulonglong = (1 as libc::c_ulonglong)
                << 64 as libc::c_int - leading_zeros;
            if power <= 9223372036854775807 as libc::c_long as libc::c_ulonglong {
                blocksize = power as idx_t;
            }
        }
    }
    return (if (if (9223372036854775807 as libc::c_long as libc::c_ulong)
        < 18446744073709551615 as libc::c_ulong
    {
        9223372036854775807 as libc::c_long as libc::c_ulong
    } else {
        18446744073709551615 as libc::c_ulong
    })
        .wrapping_div(2 as libc::c_int as libc::c_ulong)
        .wrapping_add(1 as libc::c_int as libc::c_ulong) < blocksize as libc::c_ulong
    {
        (if (9223372036854775807 as libc::c_long as libc::c_ulong)
            < 18446744073709551615 as libc::c_ulong
        {
            9223372036854775807 as libc::c_long as libc::c_ulong
        } else {
            18446744073709551615 as libc::c_ulong
        })
            .wrapping_div(2 as libc::c_int as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
    } else {
        blocksize as libc::c_ulong
    }) as idx_t;
}
```
Here are its call sites
Call site 1:
```rust
let mut outsize: idx_t = io_blksize(&mut stat_buf);
```
Call site 2:
```rust
insize = io_blksize(&mut stat_buf);
```
The function uses the following global variables:
```rust
pub const IO_BUFSIZE: C2RustUnnamed_0 = 262144;
```
The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use std::io::Write;
```
```rust
use std::os::raw::c_char;
```
```rust
use ::rust::*;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:111 ~ cat[4a5d]::xset_binary_mode)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {
    if set_binary_mode(fd, mode) < 0 as libc::c_int {
        xset_binary_mode_error();
    }
}
```
Here are its call sites
Call site 1:
```rust
xset_binary_mode(0 as libc::c_int, 0 as libc::c_int);
```
Call site 2:
```rust
xset_binary_mode(1 as libc::c_int, 0 as libc::c_int);
```

The file contains the following imports:
```rust
use ::rust::*;
```
```rust
use std::ffi::CStr;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::io::Write;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:126 ~ cat[4a5d]::copy_cat)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn copy_cat() -> libc::c_int {
    let mut copy_max: ssize_t = (((if (9223372036854775807 as libc::c_long
        as libc::c_ulong) < 18446744073709551615 as libc::c_ulong
    {
        9223372036854775807 as libc::c_long as libc::c_ulong
    } else {
        18446744073709551615 as libc::c_ulong
    }) >> 30 as libc::c_int) << 30 as libc::c_int) as ssize_t;
    let mut some_copied: bool = 0 as libc::c_int != 0;
    loop {
        match rpl_copy_file_range(
            input_desc,
            0 as *mut off_t,
            1 as libc::c_int,
            0 as *mut off_t,
            copy_max as size_t,
            0 as libc::c_int as libc::c_uint,
        ) {
            0 => return some_copied as libc::c_int,
            -1 => {
                if *__errno_location() == 38 as libc::c_int
                    || is_ENOTSUP(*__errno_location()) as libc::c_int != 0
                    || *__errno_location() == 22 as libc::c_int
                    || *__errno_location() == 9 as libc::c_int
                    || *__errno_location() == 18 as libc::c_int
                    || *__errno_location() == 26 as libc::c_int
                    || *__errno_location() == 1 as libc::c_int
                {
                    return 0 as libc::c_int;
                }
                if 0 != 0 {
                    error(
                        0 as libc::c_int,
                        *__errno_location(),
                        b"%s\0" as *const u8 as *const libc::c_char,
                        quotearg_n_style_colon(
                            0 as libc::c_int,
                            shell_escape_quoting_style,
                            infile,
                        ),
                    );
                    if 0 as libc::c_int != 0 as libc::c_int {
                        unreachable!();
                    } else {};
                } else {
                    ({
                        let __errstatus: libc::c_int = 0 as libc::c_int;
                        error(
                            __errstatus,
                            *__errno_location(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            quotearg_n_style_colon(
                                0 as libc::c_int,
                                shell_escape_quoting_style,
                                infile,
                            ),
                        );
                        if __errstatus != 0 as libc::c_int {
                            unreachable!();
                        } else {};
                        
                    });
                    ({
                        let __errstatus: libc::c_int = 0 as libc::c_int;
                        error(
                            __errstatus,
                            *__errno_location(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            quotearg_n_style_colon(
                                0 as libc::c_int,
                                shell_escape_quoting_style,
                                infile,
                            ),
                        );
                        if __errstatus != 0 as libc::c_int {
                            unreachable!();
                        } else {};
                        
                    });
                };
                return -(1 as libc::c_int);
            }
            _ => {}
        }
        some_copied = 1 as libc::c_int != 0;
    };
}
```
Here are its call sites
Call site 1:
```rust
{
                                    copy_cat()
                                }
```
The function uses the following global variables:
```rust
pub const shell_escape_quoting_style: quoting_style = 3;
```
```rust
static mut infile: *const libc::c_char = 0 as *const libc::c_char;
```
```rust
static mut input_desc: libc::c_int = 0;
```
The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use ::rust::*;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::io::Write;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:123 ~ cat[4a5d]::simple_cat)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn simple_cat(mut buf: *mut libc::c_char, mut bufsize: idx_t) -> bool {
    loop {
        let mut n_read: size_t = safe_read(
            input_desc,
            buf as *mut libc::c_void,
            bufsize as size_t,
        );
        if n_read == -(1 as libc::c_int) as size_t {
            if 0 != 0 {
                error(
                    0 as libc::c_int,
                    *__errno_location(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    quotearg_n_style_colon(
                        0 as libc::c_int,
                        shell_escape_quoting_style,
                        infile,
                    ),
                );
                if 0 as libc::c_int != 0 as libc::c_int {
                    unreachable!();
                } else {};
            } else {
                ({
                    let __errstatus: libc::c_int = 0 as libc::c_int;
                    error(
                        __errstatus,
                        *__errno_location(),
                        b"%s\0" as *const u8 as *const libc::c_char,
                        quotearg_n_style_colon(
                            0 as libc::c_int,
                            shell_escape_quoting_style,
                            infile,
                        ),
                    );
                    if __errstatus != 0 as libc::c_int {
                        unreachable!();
                    } else {};
                    
                });
                ({
                    let __errstatus: libc::c_int = 0 as libc::c_int;
                    error(
                        __errstatus,
                        *__errno_location(),
                        b"%s\0" as *const u8 as *const libc::c_char,
                        quotearg_n_style_colon(
                            0 as libc::c_int,
                            shell_escape_quoting_style,
                            infile,
                        ),
                    );
                    if __errstatus != 0 as libc::c_int {
                        unreachable!();
                    } else {};
                    
                });
            };
            return 0 as libc::c_int != 0;
        }
        if n_read == 0 as libc::c_int as libc::c_ulong {
            return 1 as libc::c_int != 0;
        }
        if full_write(1 as libc::c_int, buf as *const libc::c_void, n_read) != n_read {
            write_error();
        }
    };
}
```
Here are its call sites
Call site 1:
```rust
ok = (ok as libc::c_int
                                        & simple_cat(inbuf, insize) as libc::c_int) != 0;
```
The function uses the following global variables:
```rust
static mut input_desc: libc::c_int = 0;
```
```rust
pub const shell_escape_quoting_style: quoting_style = 3;
```
```rust
static mut infile: *const libc::c_char = 0 as *const libc::c_char;
```
The file contains the following imports:
```rust
use ::rust::*;
```
```rust
use std::ffi::CStr;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::io::Write;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:125 ~ cat[4a5d]::cat)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn cat(
    mut inbuf: *mut libc::c_char,
    mut insize: idx_t,
    mut outbuf: *mut libc::c_char,
    mut outsize: idx_t,
    mut show_nonprinting: bool,
    mut show_tabs: bool,
    mut number: bool,
    mut number_nonblank: bool,
    mut show_ends: bool,
    mut squeeze_blank: bool,
) -> bool {
    let mut ch: libc::c_uchar = 0;
    let mut newlines: libc::c_int = newlines2;
    let mut use_fionread: bool = 1 as libc::c_int != 0;
    let mut eob: *mut libc::c_char = inbuf;
    let mut bpin: *mut libc::c_char = eob.offset(1 as libc::c_int as isize);
    let mut bpout: *mut libc::c_char = outbuf;
    loop {
        let mut current_block_52: u64;
        loop {
            if outbuf.offset(outsize as isize) <= bpout {
                let mut wp: *mut libc::c_char = outbuf;
                let mut remaining_bytes: idx_t = 0;
                loop {
                    if full_write(
                        1 as libc::c_int,
                        wp as *const libc::c_void,
                        outsize as size_t,
                    ) != outsize as libc::c_ulong
                    {
                        write_error();
                    }
                    wp = wp.offset(outsize as isize);
                    remaining_bytes = bpout.offset_from(wp) as libc::c_long;
                    if !(outsize <= remaining_bytes) {
                        break;
                    }
                }
                memmove(
                    outbuf as *mut libc::c_void,
                    wp as *const libc::c_void,
                    remaining_bytes as libc::c_ulong,
                );
                bpout = outbuf.offset(remaining_bytes as isize);
            }
            if bpin > eob {
                let mut input_pending: bool = 0 as libc::c_int != 0;
                let mut n_to_read: libc::c_int = 0 as libc::c_int;
                if use_fionread as libc::c_int != 0
                    && ioctl(
                        input_desc,
                        0x541b as libc::c_int as libc::c_ulong,
                        &mut n_to_read as *mut libc::c_int,
                    ) < 0 as libc::c_int
                {
                    if *__errno_location() == 95 as libc::c_int
                        || *__errno_location() == 25 as libc::c_int
                        || *__errno_location() == 22 as libc::c_int
                        || *__errno_location() == 19 as libc::c_int
                        || *__errno_location() == 38 as libc::c_int
                    {
                        use_fionread = 0 as libc::c_int != 0;
                    } else {
                        if 0 != 0 {
                            error(
                                0 as libc::c_int,
                                *__errno_location(),
                                gettext(
                                    b"cannot do ioctl on %s\0" as *const u8
                                        as *const libc::c_char,
                                ),
                                quotearg_style(shell_escape_always_quoting_style, infile),
                            );
                            if 0 as libc::c_int != 0 as libc::c_int {
                                unreachable!();
                            } else {};
                        } else {
                            ({
                                let __errstatus: libc::c_int = 0 as libc::c_int;
                                error(
                                    __errstatus,
                                    *__errno_location(),
                                    gettext(
                                        b"cannot do ioctl on %s\0" as *const u8
                                            as *const libc::c_char,
                                    ),
                                    quotearg_style(shell_escape_always_quoting_style, infile),
                                );
                                if __errstatus != 0 as libc::c_int {
                                    unreachable!();
                                } else {};
                                
                            });
                            ({
                                let __errstatus: libc::c_int = 0 as libc::c_int;
                                error(
                                    __errstatus,
                                    *__errno_location(),
                                    gettext(
                                        b"cannot do ioctl on %s\0" as *const u8
                                            as *const libc::c_char,
                                    ),
                                    quotearg_style(shell_escape_always_quoting_style, infile),
                                );
                                if __errstatus != 0 as libc::c_int {
                                    unreachable!();
                                } else {};
                                
                            });
                        };
                        newlines2 = newlines;
                        return 0 as libc::c_int != 0;
                    }
                }
                if n_to_read != 0 as libc::c_int {
                    input_pending = 1 as libc::c_int != 0;
                }
                if !input_pending {
                    write_pending(outbuf, &mut bpout);
                }
                let mut n_read: size_t = safe_read(
                    input_desc,
                    inbuf as *mut libc::c_void,
                    insize as size_t,
                );
                if n_read == -(1 as libc::c_int) as size_t {
                    if 0 != 0 {
                        error(
                            0 as libc::c_int,
                            *__errno_location(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            quotearg_n_style_colon(
                                0 as libc::c_int,
                                shell_escape_quoting_style,
                                infile,
                            ),
                        );
                        if 0 as libc::c_int != 0 as libc::c_int {
                            unreachable!();
                        } else {};
                    } else {
                        ({
                            let __errstatus: libc::c_int = 0 as libc::c_int;
                            error(
                                __errstatus,
                                *__errno_location(),
                                b"%s\0" as *const u8 as *const libc::c_char,
                                quotearg_n_style_colon(
                                    0 as libc::c_int,
                                    shell_escape_quoting_style,
                                    infile,
                                ),
                            );
                            if __errstatus != 0 as libc::c_int {
                                unreachable!();
                            } else {};
                            
                        });
                        ({
                            let __errstatus: libc::c_int = 0 as libc::c_int;
                            error(
                                __errstatus,
                                *__errno_location(),
                                b"%s\0" as *const u8 as *const libc::c_char,
                                quotearg_n_style_colon(
                                    0 as libc::c_int,
                                    shell_escape_quoting_style,
                                    infile,
                                ),
                            );
                            if __errstatus != 0 as libc::c_int {
                                unreachable!();
                            } else {};
                            
                        });
                    };
                    write_pending(outbuf, &mut bpout);
                    newlines2 = newlines;
                    return 0 as libc::c_int != 0;
                }
                if n_read == 0 as libc::c_int as libc::c_ulong {
                    write_pending(outbuf, &mut bpout);
                    newlines2 = newlines;
                    return 1 as libc::c_int != 0;
                }
                bpin = inbuf;
                eob = bpin.offset(n_read as isize);
                *eob = '\n' as i32 as libc::c_char;
                current_block_52 = 6476622998065200121;
            } else {
                newlines += 1;
                if newlines > 0 as libc::c_int {
                    if newlines >= 2 as libc::c_int {
                        newlines = 2 as libc::c_int;
                        if squeeze_blank {
                            let fresh2 = bpin;
                            bpin = bpin.offset(1);
                            ch = *fresh2 as libc::c_uchar;
                            current_block_52 = 16658872821858055392;
                        } else {
                            current_block_52 = 15597372965620363352;
                        }
                    } else {
                        current_block_52 = 15597372965620363352;
                    }
                    match current_block_52 {
                        16658872821858055392 => {}
                        _ => {
                            if number as libc::c_int != 0 && !number_nonblank {
                                next_line_num();
                                bpout = stpcpy(bpout, line_num_print);
                            }
                            current_block_52 = 17784502470059252271;
                        }
                    }
                } else {
                    current_block_52 = 17784502470059252271;
                }
                match current_block_52 {
                    16658872821858055392 => {}
                    _ => {
                        if show_ends {
                            if pending_cr {
                                let fresh3 = bpout;
                                bpout = bpout.offset(1);
                                *fresh3 = '^' as i32 as libc::c_char;
                                let fresh4 = bpout;
                                bpout = bpout.offset(1);
                                *fresh4 = 'M' as i32 as libc::c_char;
                                pending_cr = 0 as libc::c_int != 0;
                            }
                            let fresh5 = bpout;
                            bpout = bpout.offset(1);
                            *fresh5 = '$' as i32 as libc::c_char;
                        }
                        let fresh6 = bpout;
                        bpout = bpout.offset(1);
                        *fresh6 = '\n' as i32 as libc::c_char;
                        current_block_52 = 6476622998065200121;
                    }
                }
            }
            match current_block_52 {
                6476622998065200121 => {
                    let fresh7 = bpin;
                    bpin = bpin.offset(1);
                    ch = *fresh7 as libc::c_uchar;
                }
                _ => {}
            }
            if !(ch as libc::c_int == '\n' as i32) {
                break;
            }
        }
        if pending_cr {
            let fresh8 = bpout;
            bpout = bpout.offset(1);
            *fresh8 = '\r' as i32 as libc::c_char;
            pending_cr = 0 as libc::c_int != 0;
        }
        if newlines >= 0 as libc::c_int && number as libc::c_int != 0 {
            next_line_num();
            bpout = stpcpy(bpout, line_num_print);
        }
        if show_nonprinting {
            loop {
                if ch as libc::c_int >= 32 as libc::c_int {
                    if (ch as libc::c_int) < 127 as libc::c_int {
                        let fresh9 = bpout;
                        bpout = bpout.offset(1);
                        *fresh9 = ch as libc::c_char;
                    } else if ch as libc::c_int == 127 as libc::c_int {
                        let fresh10 = bpout;
                        bpout = bpout.offset(1);
                        *fresh10 = '^' as i32 as libc::c_char;
                        let fresh11 = bpout;
                        bpout = bpout.offset(1);
                        *fresh11 = '?' as i32 as libc::c_char;
                    } else {
                        let fresh12 = bpout;
                        bpout = bpout.offset(1);
                        *fresh12 = 'M' as i32 as libc::c_char;
                        let fresh13 = bpout;
                        bpout = bpout.offset(1);
                        *fresh13 = '-' as i32 as libc::c_char;
                        if ch as libc::c_int >= 128 as libc::c_int + 32 as libc::c_int {
                            if (ch as libc::c_int)
                                < 128 as libc::c_int + 127 as libc::c_int
                            {
                                let fresh14 = bpout;
                                bpout = bpout.offset(1);
                                *fresh14 = (ch as libc::c_int - 128 as libc::c_int)
                                    as libc::c_char;
                            } else {
                                let fresh15 = bpout;
                                bpout = bpout.offset(1);
                                *fresh15 = '^' as i32 as libc::c_char;
                                let fresh16 = bpout;
                                bpout = bpout.offset(1);
                                *fresh16 = '?' as i32 as libc::c_char;
                            }
                        } else {
                            let fresh17 = bpout;
                            bpout = bpout.offset(1);
                            *fresh17 = '^' as i32 as libc::c_char;
                            let fresh18 = bpout;
                            bpout = bpout.offset(1);
                            *fresh18 = (ch as libc::c_int - 128 as libc::c_int
                                + 64 as libc::c_int) as libc::c_char;
                        }
                    }
                } else if ch as libc::c_int == '\t' as i32 && !show_tabs {
                    let fresh19 = bpout;
                    bpout = bpout.offset(1);
                    *fresh19 = '\t' as i32 as libc::c_char;
                } else if ch as libc::c_int == '\n' as i32 {
                    newlines = -(1 as libc::c_int);
                    break;
                } else {
                    let fresh20 = bpout;
                    bpout = bpout.offset(1);
                    *fresh20 = '^' as i32 as libc::c_char;
                    let fresh21 = bpout;
                    bpout = bpout.offset(1);
                    *fresh21 = (ch as libc::c_int + 64 as libc::c_int) as libc::c_char;
                }
                let fresh22 = bpin;
                bpin = bpin.offset(1);
                ch = *fresh22 as libc::c_uchar;
            }
        } else {
            loop {
                if ch as libc::c_int == '\t' as i32 && show_tabs as libc::c_int != 0 {
                    let fresh23 = bpout;
                    bpout = bpout.offset(1);
                    *fresh23 = '^' as i32 as libc::c_char;
                    let fresh24 = bpout;
                    bpout = bpout.offset(1);
                    *fresh24 = (ch as libc::c_int + 64 as libc::c_int) as libc::c_char;
                } else if ch as libc::c_int != '\n' as i32 {
                    if ch as libc::c_int == '\r' as i32
                        && *bpin as libc::c_int == '\n' as i32
                        && show_ends as libc::c_int != 0
                    {
                        if bpin == eob {
                            pending_cr = 1 as libc::c_int != 0;
                        } else {
                            let fresh25 = bpout;
                            bpout = bpout.offset(1);
                            *fresh25 = '^' as i32 as libc::c_char;
                            let fresh26 = bpout;
                            bpout = bpout.offset(1);
                            *fresh26 = 'M' as i32 as libc::c_char;
                        }
                    } else {
                        let fresh27 = bpout;
                        bpout = bpout.offset(1);
                        *fresh27 = ch as libc::c_char;
                    }
                } else {
                    newlines = -(1 as libc::c_int);
                    break;
                }
                let fresh28 = bpin;
                bpin = bpin.offset(1);
                ch = *fresh28 as libc::c_uchar;
            }
        }
    };
}
```
Here are its call sites
Call site 1:
```rust
ok = (ok as libc::c_int
                                    & cat(
                                        inbuf,
                                        insize,
                                        outbuf,
                                        outsize,
                                        show_nonprinting,
                                        show_tabs,
                                        number,
                                        number_nonblank,
                                        show_ends,
                                        squeeze_blank,
                                    ) as libc::c_int) != 0;
```
The function uses the following global variables:
```rust
static mut input_desc: libc::c_int = 0;
```
```rust
static mut line_num_print: *mut libc::c_char = 0 as *const libc::c_char
    as *mut libc::c_char;
```
```rust
static mut pending_cr: bool = 0 as libc::c_int != 0;
```
```rust
pub const shell_escape_always_quoting_style: quoting_style = 4;
```
```rust
pub const shell_escape_quoting_style: quoting_style = 3;
```
```rust
static mut infile: *const libc::c_char = 0 as *const libc::c_char;
```
```rust
static mut newlines2: libc::c_int = 0 as libc::c_int;
```
The file contains the following imports:
```rust
use std::io::Write;
```
```rust
use ::rust::*;
```
```rust
use std::ffi::CStr;
```
```rust
use std::os::raw::c_char;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:104 ~ cat[4a5d]::alignfree)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn alignfree(mut ptr: *mut libc::c_void) {
    free(ptr);
}
```
Here are its call sites
Call site 1:
```rust
alignfree(outbuf as *mut libc::c_void);
```
Call site 2:
```rust
alignfree(inbuf as *mut libc::c_void);
```

The file contains the following imports:
```rust
use ::rust::*;
```
```rust
use std::ffi::CStr;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::io::Write;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:127 ~ cat[4a5d]::main_0)
Chunk root
Here is a function:
```rust
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut insize: idx_t = 0;
    let mut inbuf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut current_block: u64;
    let mut have_read_stdin: bool = 0 as libc::c_int != 0;
    let mut stat_buf: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_mode: 0,
        st_nlink: 0,
        st_uid: 0,
        st_gid: 0,
        st_rdev: 0,
        __pad1: 0,
        st_size: 0,
        st_blksize: 0,
        __pad2: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 2],
    };
    let mut number: bool = 0 as libc::c_int != 0;
    let mut number_nonblank: bool = 0 as libc::c_int != 0;
    let mut squeeze_blank: bool = 0 as libc::c_int != 0;
    let mut show_ends: bool = 0 as libc::c_int != 0;
    let mut show_nonprinting: bool = 0 as libc::c_int != 0;
    let mut show_tabs: bool = 0 as libc::c_int != 0;
    let mut file_open_mode: libc::c_int = 0 as libc::c_int;
    static mut long_options: [option; 10] = [
        {
            let mut init = option {
                name: b"number-nonblank\0" as *const u8 as *const libc::c_char,
                has_arg: 0 as libc::c_int,
                flag: 0 as *const libc::c_int as *mut libc::c_int,
                val: 'b' as i32,
            };
            init
        },
        {
            let mut init = option {
                name: b"number\0" as *const u8 as *const libc::c_char,
                has_arg: 0 as libc::c_int,
                flag: 0 as *const libc::c_int as *mut libc::c_int,
                val: 'n' as i32,
            };
            init
        },
        {
            let mut init = option {
                name: b"squeeze-blank\0" as *const u8 as *const libc::c_char,
                has_arg: 0 as libc::c_int,
                flag: 0 as *const libc::c_int as *mut libc::c_int,
                val: 's' as i32,
            };
            init
        },
        {
            let mut init = option {
                name: b"show-nonprinting\0" as *const u8 as *const libc::c_char,
                has_arg: 0 as libc::c_int,
                flag: 0 as *const libc::c_int as *mut libc::c_int,
                val: 'v' as i32,
            };
            init
        },
        {
            let mut init = option {
                name: b"show-ends\0" as *const u8 as *const libc::c_char,
                has_arg: 0 as libc::c_int,
                flag: 0 as *const libc::c_int as *mut libc::c_int,
                val: 'E' as i32,
            };
            init
        },
        {
            let mut init = option {
                name: b"show-tabs\0" as *const u8 as *const libc::c_char,
                has_arg: 0 as libc::c_int,
                flag: 0 as *const libc::c_int as *mut libc::c_int,
                val: 'T' as i32,
            };
            init
        },
        {
            let mut init = option {
                name: b"show-all\0" as *const u8 as *const libc::c_char,
                has_arg: 0 as libc::c_int,
                flag: 0 as *const libc::c_int as *mut libc::c_int,
                val: 'A' as i32,
            };
            init
        },
        {
            let mut init = option {
                name: b"help\0" as *const u8 as *const libc::c_char,
                has_arg: 0 as libc::c_int,
                flag: 0 as *const libc::c_int as *mut libc::c_int,
                val: GETOPT_HELP_CHAR as libc::c_int,
            };
            init
        },
        {
            let mut init = option {
                name: b"version\0" as *const u8 as *const libc::c_char,
                has_arg: 0 as libc::c_int,
                flag: 0 as *const libc::c_int as *mut libc::c_int,
                val: GETOPT_VERSION_CHAR as libc::c_int,
            };
            init
        },
        {
            let mut init = option {
                name: 0 as *const libc::c_char,
                has_arg: 0 as libc::c_int,
                flag: 0 as *const libc::c_int as *mut libc::c_int,
                val: 0 as libc::c_int,
            };
            init
        },
    ];
    set_program_name(*argv.offset(0 as libc::c_int as isize));
    setlocale(6 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
    bindtextdomain(
        b"coreutils\0" as *const u8 as *const libc::c_char,
        b"/usr/local/share/locale\0" as *const u8 as *const libc::c_char,
    );
    textdomain(b"coreutils\0" as *const u8 as *const libc::c_char);
    atexit(Some(close_stdout as unsafe extern "C" fn() -> ()));
    let mut c: libc::c_int = 0;
    loop {
        c = getopt_long(
            argc,
            argv,
            b"benstuvAET\0" as *const u8 as *const libc::c_char,
            long_options.as_ptr(),
            0 as *mut libc::c_int,
        );
        if !(c != -(1 as libc::c_int)) {
            break;
        }
        match c {
            98 => {
                number = 1 as libc::c_int != 0;
                number_nonblank = 1 as libc::c_int != 0;
            }
            101 => {
                show_ends = 1 as libc::c_int != 0;
                show_nonprinting = 1 as libc::c_int != 0;
            }
            110 => {
                number = 1 as libc::c_int != 0;
            }
            115 => {
                squeeze_blank = 1 as libc::c_int != 0;
            }
            116 => {
                show_tabs = 1 as libc::c_int != 0;
                show_nonprinting = 1 as libc::c_int != 0;
            }
            117 => {}
            118 => {
                show_nonprinting = 1 as libc::c_int != 0;
            }
            65 => {
                show_nonprinting = 1 as libc::c_int != 0;
                show_ends = 1 as libc::c_int != 0;
                show_tabs = 1 as libc::c_int != 0;
            }
            69 => {
                show_ends = 1 as libc::c_int != 0;
            }
            84 => {
                show_tabs = 1 as libc::c_int != 0;
            }
            -2 => {
                usage(0 as libc::c_int);
            }
            -3 => {
                version_etc(
                    stdout,
                    b"cat\0" as *const u8 as *const libc::c_char,
                    b"GNU coreutils\0" as *const u8 as *const libc::c_char,
                    Version,
                    proper_name_lite(
                        b"Torbjorn Granlund\0" as *const u8 as *const libc::c_char,
                        b"Torbj\xC3\xB6rn Granlund\0" as *const u8 as *const libc::c_char,
                    ),
                    proper_name_lite(
                        b"Richard M. Stallman\0" as *const u8 as *const libc::c_char,
                        b"Richard M. Stallman\0" as *const u8 as *const libc::c_char,
                    ),
                    0 as *mut libc::c_void as *mut libc::c_char,
                );
                exit(0 as libc::c_int);
            }
            _ => {
                usage(1 as libc::c_int);
            }
        }
    }
    if fstat(1 as libc::c_int, &mut stat_buf) < 0 as libc::c_int {
        if 0 != 0 {
            error(
                1 as libc::c_int,
                *__errno_location(),
                gettext(b"standard output\0" as *const u8 as *const libc::c_char),
            );
            if 1 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    gettext(b"standard output\0" as *const u8 as *const libc::c_char),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    gettext(b"standard output\0" as *const u8 as *const libc::c_char),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
    }
    let mut outsize: idx_t = io_blksize(&mut stat_buf);
    let mut out_dev: dev_t = stat_buf.st_dev;
    let mut out_ino: ino_t = stat_buf.st_ino;
    let mut out_flags: libc::c_int = -(2 as libc::c_int);
    let mut out_isreg: bool = (stat_buf.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o100000 as libc::c_int as libc::c_uint) as libc::c_int != 0 as libc::c_int;
    if !(number as libc::c_int != 0 || show_ends as libc::c_int != 0
        || squeeze_blank as libc::c_int != 0)
    {
        file_open_mode |= 0 as libc::c_int;
        xset_binary_mode(1 as libc::c_int, 0 as libc::c_int);
    }
    infile = b"-\0" as *const u8 as *const libc::c_char;
    let mut argind: libc::c_int = optind;
    let mut ok: bool = 1 as libc::c_int != 0;
    let mut page_size: idx_t = getpagesize() as idx_t;
    loop {
        if argind < argc {
            infile = *argv.offset(argind as isize);
        }
        let mut reading_stdin: bool = strcmp(
            infile,
            b"-\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int;
        if reading_stdin {
            have_read_stdin = 1 as libc::c_int != 0;
            input_desc = 0 as libc::c_int;
            if file_open_mode & 0 as libc::c_int != 0 {
                xset_binary_mode(0 as libc::c_int, 0 as libc::c_int);
            }
            current_block = 13321564401369230990;
        } else {
            input_desc = open(infile, file_open_mode);
            if input_desc < 0 as libc::c_int {
                if 0 != 0 {
                    error(
                        0 as libc::c_int,
                        *__errno_location(),
                        b"%s\0" as *const u8 as *const libc::c_char,
                        quotearg_n_style_colon(
                            0 as libc::c_int,
                            shell_escape_quoting_style,
                            infile,
                        ),
                    );
                    if 0 as libc::c_int != 0 as libc::c_int {
                        unreachable!();
                    } else {};
                } else {
                    ({
                        let __errstatus: libc::c_int = 0 as libc::c_int;
                        error(
                            __errstatus,
                            *__errno_location(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            quotearg_n_style_colon(
                                0 as libc::c_int,
                                shell_escape_quoting_style,
                                infile,
                            ),
                        );
                        if __errstatus != 0 as libc::c_int {
                            unreachable!();
                        } else {};
                        
                    });
                    ({
                        let __errstatus: libc::c_int = 0 as libc::c_int;
                        error(
                            __errstatus,
                            *__errno_location(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            quotearg_n_style_colon(
                                0 as libc::c_int,
                                shell_escape_quoting_style,
                                infile,
                            ),
                        );
                        if __errstatus != 0 as libc::c_int {
                            unreachable!();
                        } else {};
                        
                    });
                };
                ok = 0 as libc::c_int != 0;
                current_block = 4567019141635105728;
            } else {
                current_block = 13321564401369230990;
            }
        }
        match current_block {
            13321564401369230990 => {
                if fstat(input_desc, &mut stat_buf) < 0 as libc::c_int {
                    if 0 != 0 {
                        error(
                            0 as libc::c_int,
                            *__errno_location(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            quotearg_n_style_colon(
                                0 as libc::c_int,
                                shell_escape_quoting_style,
                                infile,
                            ),
                        );
                        if 0 as libc::c_int != 0 as libc::c_int {
                            unreachable!();
                        } else {};
                    } else {
                        ({
                            let __errstatus: libc::c_int = 0 as libc::c_int;
                            error(
                                __errstatus,
                                *__errno_location(),
                                b"%s\0" as *const u8 as *const libc::c_char,
                                quotearg_n_style_colon(
                                    0 as libc::c_int,
                                    shell_escape_quoting_style,
                                    infile,
                                ),
                            );
                            if __errstatus != 0 as libc::c_int {
                                unreachable!();
                            } else {};
                            
                        });
                        ({
                            let __errstatus: libc::c_int = 0 as libc::c_int;
                            error(
                                __errstatus,
                                *__errno_location(),
                                b"%s\0" as *const u8 as *const libc::c_char,
                                quotearg_n_style_colon(
                                    0 as libc::c_int,
                                    shell_escape_quoting_style,
                                    infile,
                                ),
                            );
                            if __errstatus != 0 as libc::c_int {
                                unreachable!();
                            } else {};
                            
                        });
                    };
                    ok = 0 as libc::c_int != 0;
                } else {
                    insize = io_blksize(&mut stat_buf);
                    fdadvise(
                        input_desc,
                        0 as libc::c_int as off_t,
                        0 as libc::c_int as off_t,
                        FADVISE_SEQUENTIAL,
                    );
                    if stat_buf.st_dev == out_dev && stat_buf.st_ino == out_ino {
                        if out_flags < -(1 as libc::c_int) {
                            out_flags = rpl_fcntl(1 as libc::c_int, 3 as libc::c_int);
                        }
                        let mut exhausting: bool = 0 as libc::c_int <= out_flags
                            && out_flags & 0o2000 as libc::c_int != 0;
                        if !exhausting {
                            let mut in_pos: off_t = lseek(
                                input_desc,
                                0 as libc::c_int as __off_t,
                                1 as libc::c_int,
                            );
                            if 0 as libc::c_int as libc::c_long <= in_pos {
                                exhausting = in_pos
                                    < lseek(
                                        1 as libc::c_int,
                                        0 as libc::c_int as __off_t,
                                        1 as libc::c_int,
                                    );
                            }
                        }
                        if exhausting {
                            if 0 != 0 {
                                error(
                                    0 as libc::c_int,
                                    0 as libc::c_int,
                                    gettext(
                                        b"%s: input file is output file\0" as *const u8
                                            as *const libc::c_char,
                                    ),
                                    quotearg_n_style_colon(
                                        0 as libc::c_int,
                                        shell_escape_quoting_style,
                                        infile,
                                    ),
                                );
                                if 0 as libc::c_int != 0 as libc::c_int {
                                    unreachable!();
                                } else {};
                            } else {
                                ({
                                    let __errstatus: libc::c_int = 0 as libc::c_int;
                                    error(
                                        __errstatus,
                                        0 as libc::c_int,
                                        gettext(
                                            b"%s: input file is output file\0" as *const u8
                                                as *const libc::c_char,
                                        ),
                                        quotearg_n_style_colon(
                                            0 as libc::c_int,
                                            shell_escape_quoting_style,
                                            infile,
                                        ),
                                    );
                                    if __errstatus != 0 as libc::c_int {
                                        unreachable!();
                                    } else {};
                                    
                                });
                                ({
                                    let __errstatus: libc::c_int = 0 as libc::c_int;
                                    error(
                                        __errstatus,
                                        0 as libc::c_int,
                                        gettext(
                                            b"%s: input file is output file\0" as *const u8
                                                as *const libc::c_char,
                                        ),
                                        quotearg_n_style_colon(
                                            0 as libc::c_int,
                                            shell_escape_quoting_style,
                                            infile,
                                        ),
                                    );
                                    if __errstatus != 0 as libc::c_int {
                                        unreachable!();
                                    } else {};
                                    
                                });
                            };
                            ok = 0 as libc::c_int != 0;
                            current_block = 7239751344758050955;
                        } else {
                            current_block = 5372832139739605200;
                        }
                    } else {
                        current_block = 5372832139739605200;
                    }
                    match current_block {
                        7239751344758050955 => {}
                        _ => {
                            inbuf = 0 as *mut libc::c_char;
                            if !(number as libc::c_int != 0
                                || show_ends as libc::c_int != 0
                                || show_nonprinting as libc::c_int != 0
                                || show_tabs as libc::c_int != 0
                                || squeeze_blank as libc::c_int != 0)
                            {
                                let mut copy_cat_status: libc::c_int = if out_isreg
                                    as libc::c_int != 0
                                    && stat_buf.st_mode
                                        & 0o170000 as libc::c_int as libc::c_uint
                                        == 0o100000 as libc::c_int as libc::c_uint
                                {
                                    copy_cat()
                                } else {
                                    0 as libc::c_int
                                };
                                if copy_cat_status != 0 as libc::c_int {
                                    inbuf = 0 as *mut libc::c_char;
                                    ok = (ok as libc::c_int
                                        & ((0 as libc::c_int) < copy_cat_status) as libc::c_int) != 0;
                                } else {
                                    insize = if insize > outsize { insize } else { outsize };
                                    inbuf = xalignalloc(page_size, insize) as *mut libc::c_char;
                                    ok = (ok as libc::c_int
                                        & simple_cat(inbuf, insize) as libc::c_int) != 0;
                                }
                            } else {
                                inbuf = xalignalloc(
                                    page_size,
                                    insize + 1 as libc::c_int as libc::c_long,
                                ) as *mut libc::c_char;
                                let mut bufsize: idx_t = 0;
                                if (if (0 as libc::c_int as idx_t)
                                    < -(1 as libc::c_int) as idx_t
                                    && ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int as libc::c_long
                                    } else {
                                        insize
                                    }) - 1 as libc::c_int as libc::c_long)
                                        < 0 as libc::c_int as libc::c_long
                                    && ((if 1 as libc::c_int != 0 {
                                        0 as libc::c_int
                                    } else {
                                        4 as libc::c_int
                                    }) - 1 as libc::c_int) < 0 as libc::c_int
                                    && (if (4 as libc::c_int) < 0 as libc::c_int {
                                        if insize < 0 as libc::c_int as libc::c_long {
                                            if ((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    -(1 as libc::c_int) as idx_t
                                                }) + 4 as libc::c_int as libc::c_long
                                            }) - 1 as libc::c_int as libc::c_long)
                                                < 0 as libc::c_int as libc::c_long
                                            {
                                                (insize
                                                    < -(1 as libc::c_int) as idx_t
                                                        / 4 as libc::c_int as libc::c_long) as libc::c_int
                                            } else {
                                                ((if (if (if ((if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    4 as libc::c_int
                                                }) - 1 as libc::c_int) < 0 as libc::c_int
                                                {
                                                    !(((((if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int
                                                    } else {
                                                        4 as libc::c_int
                                                    }) + 1 as libc::c_int)
                                                        << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                        - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)
                                                } else {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int
                                                    } else {
                                                        4 as libc::c_int
                                                    }) + 0 as libc::c_int
                                                }) < 0 as libc::c_int
                                                {
                                                    ((4 as libc::c_int)
                                                        < -(if ((if 1 as libc::c_int != 0 {
                                                            0 as libc::c_int
                                                        } else {
                                                            4 as libc::c_int
                                                        }) - 1 as libc::c_int) < 0 as libc::c_int
                                                        {
                                                            ((((if 1 as libc::c_int != 0 {
                                                                0 as libc::c_int
                                                            } else {
                                                                4 as libc::c_int
                                                            }) + 1 as libc::c_int)
                                                                << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                                - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int
                                                        } else {
                                                            (if 1 as libc::c_int != 0 {
                                                                0 as libc::c_int
                                                            } else {
                                                                4 as libc::c_int
                                                            }) - 1 as libc::c_int
                                                        })) as libc::c_int
                                                } else {
                                                    ((0 as libc::c_int) < 4 as libc::c_int) as libc::c_int
                                                }) != 0
                                                {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int
                                                    } else {
                                                        4 as libc::c_int
                                                    }) as libc::c_long + -(1 as libc::c_int) as idx_t
                                                        >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                                } else {
                                                    -(1 as libc::c_int) as idx_t
                                                        / -(4 as libc::c_int) as libc::c_long
                                                }) <= -(1 as libc::c_int) as libc::c_long - insize)
                                                    as libc::c_int
                                            }
                                        } else {
                                            if (if (if ((if 1 as libc::c_int != 0 {
                                                0 as libc::c_int as libc::c_long
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    4 as libc::c_int
                                                }) as libc::c_long + 0 as libc::c_int as idx_t
                                            }) - 1 as libc::c_int as libc::c_long)
                                                < 0 as libc::c_int as libc::c_long
                                            {
                                                !(((((if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int
                                                    } else {
                                                        4 as libc::c_int
                                                    }) as libc::c_long + 0 as libc::c_int as idx_t
                                                }) + 1 as libc::c_int as libc::c_long)
                                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                    - 1 as libc::c_int as libc::c_long)
                                                    * 2 as libc::c_int as libc::c_long
                                                    + 1 as libc::c_int as libc::c_long)
                                            } else {
                                                (if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int
                                                    } else {
                                                        4 as libc::c_int
                                                    }) as libc::c_long + 0 as libc::c_int as idx_t
                                                }) + 0 as libc::c_int as libc::c_long
                                            }) < 0 as libc::c_int as libc::c_long
                                            {
                                                (((if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int
                                                } else {
                                                    4 as libc::c_int
                                                }) as libc::c_long + 0 as libc::c_int as idx_t)
                                                    < -(if ((if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int as libc::c_long
                                                    } else {
                                                        (if 1 as libc::c_int != 0 {
                                                            0 as libc::c_int
                                                        } else {
                                                            4 as libc::c_int
                                                        }) as libc::c_long + 0 as libc::c_int as idx_t
                                                    }) - 1 as libc::c_int as libc::c_long)
                                                        < 0 as libc::c_int as libc::c_long
                                                    {
                                                        ((((if 1 as libc::c_int != 0 {
                                                            0 as libc::c_int as libc::c_long
                                                        } else {
                                                            (if 1 as libc::c_int != 0 {
                                                                0 as libc::c_int
                                                            } else {
                                                                4 as libc::c_int
                                                            }) as libc::c_long + 0 as libc::c_int as idx_t
                                                        }) + 1 as libc::c_int as libc::c_long)
                                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                            - 1 as libc::c_int as libc::c_long)
                                                            * 2 as libc::c_int as libc::c_long
                                                            + 1 as libc::c_int as libc::c_long
                                                    } else {
                                                        (if 1 as libc::c_int != 0 {
                                                            0 as libc::c_int as libc::c_long
                                                        } else {
                                                            (if 1 as libc::c_int != 0 {
                                                                0 as libc::c_int
                                                            } else {
                                                                4 as libc::c_int
                                                            }) as libc::c_long + 0 as libc::c_int as idx_t
                                                        }) - 1 as libc::c_int as libc::c_long
                                                    })) as libc::c_int
                                            } else {
                                                ((0 as libc::c_int as libc::c_long)
                                                    < (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int
                                                    } else {
                                                        4 as libc::c_int
                                                    }) as libc::c_long + 0 as libc::c_int as idx_t)
                                                    as libc::c_int
                                            }) != 0 && 4 as libc::c_int == -(1 as libc::c_int)
                                            {
                                                if ((if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    insize
                                                }) - 1 as libc::c_int as libc::c_long)
                                                    < 0 as libc::c_int as libc::c_long
                                                {
                                                    ((0 as libc::c_int as libc::c_long)
                                                        < insize + 0 as libc::c_int as idx_t) as libc::c_int
                                                } else {
                                                    ((0 as libc::c_int as libc::c_long) < insize
                                                        && (-(1 as libc::c_int) as libc::c_long
                                                            - 0 as libc::c_int as idx_t)
                                                            < insize - 1 as libc::c_int as libc::c_long) as libc::c_int
                                                }
                                            } else {
                                                ((0 as libc::c_int as idx_t
                                                    / 4 as libc::c_int as libc::c_long) < insize) as libc::c_int
                                            }
                                        }
                                    } else {
                                        if 4 as libc::c_int == 0 as libc::c_int {
                                            0 as libc::c_int
                                        } else {
                                            if insize < 0 as libc::c_int as libc::c_long {
                                                if (if (if ((if 1 as libc::c_int != 0 {
                                                    0 as libc::c_int as libc::c_long
                                                } else {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int as libc::c_long
                                                    } else {
                                                        insize
                                                    }) + 0 as libc::c_int as idx_t
                                                }) - 1 as libc::c_int as libc::c_long)
                                                    < 0 as libc::c_int as libc::c_long
                                                {
                                                    !(((((if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int as libc::c_long
                                                    } else {
                                                        (if 1 as libc::c_int != 0 {
                                                            0 as libc::c_int as libc::c_long
                                                        } else {
                                                            insize
                                                        }) + 0 as libc::c_int as idx_t
                                                    }) + 1 as libc::c_int as libc::c_long)
                                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                        - 1 as libc::c_int as libc::c_long)
                                                        * 2 as libc::c_int as libc::c_long
                                                        + 1 as libc::c_int as libc::c_long)
                                                } else {
                                                    (if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int as libc::c_long
                                                    } else {
                                                        (if 1 as libc::c_int != 0 {
                                                            0 as libc::c_int as libc::c_long
                                                        } else {
                                                            insize
                                                        }) + 0 as libc::c_int as idx_t
                                                    }) + 0 as libc::c_int as libc::c_long
                                                }) < 0 as libc::c_int as libc::c_long
                                                {
                                                    (((if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int as libc::c_long
                                                    } else {
                                                        insize
                                                    }) + 0 as libc::c_int as idx_t)
                                                        < -(if ((if 1 as libc::c_int != 0 {
                                                            0 as libc::c_int as libc::c_long
                                                        } else {
                                                            (if 1 as libc::c_int != 0 {
                                                                0 as libc::c_int as libc::c_long
                                                            } else {
                                                                insize
                                                            }) + 0 as libc::c_int as idx_t
                                                        }) - 1 as libc::c_int as libc::c_long)
                                                            < 0 as libc::c_int as libc::c_long
                                                        {
                                                            ((((if 1 as libc::c_int != 0 {
                                                                0 as libc::c_int as libc::c_long
                                                            } else {
                                                                (if 1 as libc::c_int != 0 {
                                                                    0 as libc::c_int as libc::c_long
                                                                } else {
                                                                    insize
                                                                }) + 0 as libc::c_int as idx_t
                                                            }) + 1 as libc::c_int as libc::c_long)
                                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)
                                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)
                                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))
                                                                - 1 as libc::c_int as libc::c_long)
                                                                * 2 as libc::c_int as libc::c_long
                                                                + 1 as libc::c_int as libc::c_long
                                                        } else {
                                                            (if 1 as libc::c_int != 0 {
                                                                0 as libc::c_int as libc::c_long
                                                            } else {
                                                                (if 1 as libc::c_int != 0 {
                                                                    0 as libc::c_int as libc::c_long
                                                                } else {
                                                                    insize
                                                                }) + 0 as libc::c_int as idx_t
                                                            }) - 1 as libc::c_int as libc::c_long
                                                        })) as libc::c_int
                                                } else {
                                                    ((0 as libc::c_int as libc::c_long)
                                                        < (if 1 as libc::c_int != 0 {
                                                            0 as libc::c_int as libc::c_long
                                                        } else {
                                                            insize
                                                        }) + 0 as libc::c_int as idx_t) as libc::c_int
                                                }) != 0 && insize == -(1 as libc::c_int) as libc::c_long
                                                {
                                                    if ((if 1 as libc::c_int != 0 {
                                                        0 as libc::c_int
                                                    } else {
                                                        4 as libc::c_int
                                                    }) - 1 as libc::c_int) < 0 as libc::c_int
                                                    {
                                                        ((0 as libc::c_int as libc::c_long)
                                                            < 4 as libc::c_int as libc::c_long
                                                                + 0 as libc::c_int as idx_t) as libc::c_int
                                                    } else {
                                                        ((-(1 as libc::c_int) as libc::c_long
                                                            - 0 as libc::c_int as idx_t)
                                                            < (4 as libc::c_int - 1 as libc::c_int) as libc::c_long)
                                                            as libc::c_int
                                                    }
                                                } else {
                                                    (0 as libc::c_int as idx_t / insize
                                                        < 4 as libc::c_int as libc::c_long) as libc::c_int
                                                }
                                            } else {
                                                ((-(1 as libc::c_int) as idx_t
                                                    / 4 as libc::c_int as libc::c_long) < insize) as libc::c_int
                                            }
                                        }
                                    }) != 0
                                {
                                    let (fresh33, _fresh34) = insize
                                        .overflowing_mul((4 as libc::c_int).into());
                                    *(&mut bufsize as *mut idx_t) = fresh33;
                                    1 as libc::c_int
                                } else {
                                    let (fresh35, fresh36) = insize
                                        .overflowing_mul((4 as libc::c_int).into());
                                    *(&mut bufsize as *mut idx_t) = fresh35;
                                    fresh36 as libc::c_int
                                }) != 0
                                    || {
                                        let (fresh37, fresh38) = bufsize.overflowing_add(outsize);
                                        *(&mut bufsize as *mut idx_t) = fresh37;
                                        fresh38 as libc::c_int != 0
                                    }
                                    || {
                                        let (fresh39, fresh40) = bufsize
                                            .overflowing_add((20 as libc::c_int - 1 as libc::c_int).into());
                                        *(&mut bufsize as *mut idx_t) = fresh39;
                                        fresh40 as libc::c_int != 0
                                    }
                                {
                                    xalloc_die();
                                }
                                let mut outbuf: *mut libc::c_char = xalignalloc(
                                    page_size,
                                    bufsize,
                                ) as *mut libc::c_char;
                                ok = (ok as libc::c_int
                                    & cat(
                                        inbuf,
                                        insize,
                                        outbuf,
                                        outsize,
                                        show_nonprinting,
                                        show_tabs,
                                        number,
                                        number_nonblank,
                                        show_ends,
                                        squeeze_blank,
                                    ) as libc::c_int) != 0;
                                alignfree(outbuf as *mut libc::c_void);
                            }
                            alignfree(inbuf as *mut libc::c_void);
                        }
                    }
                }
                if !reading_stdin && close(input_desc) < 0 as libc::c_int {
                    if 0 != 0 {
                        error(
                            0 as libc::c_int,
                            *__errno_location(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            quotearg_n_style_colon(
                                0 as libc::c_int,
                                shell_escape_quoting_style,
                                infile,
                            ),
                        );
                        if 0 as libc::c_int != 0 as libc::c_int {
                            unreachable!();
                        } else {};
                    } else {
                        ({
                            let __errstatus: libc::c_int = 0 as libc::c_int;
                            error(
                                __errstatus,
                                *__errno_location(),
                                b"%s\0" as *const u8 as *const libc::c_char,
                                quotearg_n_style_colon(
                                    0 as libc::c_int,
                                    shell_escape_quoting_style,
                                    infile,
                                ),
                            );
                            if __errstatus != 0 as libc::c_int {
                                unreachable!();
                            } else {};
                            
                        });
                        ({
                            let __errstatus: libc::c_int = 0 as libc::c_int;
                            error(
                                __errstatus,
                                *__errno_location(),
                                b"%s\0" as *const u8 as *const libc::c_char,
                                quotearg_n_style_colon(
                                    0 as libc::c_int,
                                    shell_escape_quoting_style,
                                    infile,
                                ),
                            );
                            if __errstatus != 0 as libc::c_int {
                                unreachable!();
                            } else {};
                            
                        });
                    };
                    ok = 0 as libc::c_int != 0;
                }
            }
            _ => {}
        }
        argind += 1;
        if !(argind < argc) {
            break;
        }
    }
    if pending_cr {
        if full_write(
            1 as libc::c_int,
            b"\r\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            1 as libc::c_int as size_t,
        ) != 1 as libc::c_int as libc::c_ulong
        {
            write_error();
        }
    }
    if have_read_stdin as libc::c_int != 0 && close(0 as libc::c_int) < 0 as libc::c_int
    {
        if 0 != 0 {
            error(
                1 as libc::c_int,
                *__errno_location(),
                gettext(b"closing standard input\0" as *const u8 as *const libc::c_char),
            );
            if 1 as libc::c_int != 0 as libc::c_int {
                unreachable!();
            } else {};
        } else {
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    gettext(
                        b"closing standard input\0" as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
            ({
                let __errstatus: libc::c_int = 1 as libc::c_int;
                error(
                    __errstatus,
                    *__errno_location(),
                    gettext(
                        b"closing standard input\0" as *const u8 as *const libc::c_char,
                    ),
                );
                if __errstatus != 0 as libc::c_int {
                    unreachable!();
                } else {};
                
            });
        };
    }
    return if ok as libc::c_int != 0 { 0 as libc::c_int } else { 1 as libc::c_int };
}
```
Here are its call sites
Call site 1:
```rust
unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
```
The function uses the following global variables:
```rust
pub const FADVISE_SEQUENTIAL: fadvice_t = 2;
```
```rust
pub const shell_escape_quoting_style: quoting_style = 3;
```
```rust
static mut input_desc: libc::c_int = 0;
```
```rust
static mut infile: *const libc::c_char = 0 as *const libc::c_char;
```
The file contains the following imports:
```rust
use std::io::Write;
```
```rust
use std::os::raw::c_char;
```
```rust
use ::rust::*;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:131 ~ cat[4a5d]::main)
Chunk root
Here is a function:
```rust
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::core::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
}
```


The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use std::os::raw::c_char;
```
```rust
use ::rust::*;
```
```rust
use std::io::Write;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:132 ~ cat[4a5d]::run_static_initializers)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn run_static_initializers() {
    line_num_print = line_buf
        .as_mut_ptr()
        .offset(20 as libc::c_int as isize)
        .offset(-(8 as libc::c_int as isize));
    line_num_start = line_buf
        .as_mut_ptr()
        .offset(20 as libc::c_int as isize)
        .offset(-(3 as libc::c_int as isize));
    line_num_end = line_buf
        .as_mut_ptr()
        .offset(20 as libc::c_int as isize)
        .offset(-(3 as libc::c_int as isize));
}
```

The function uses the following global variables:
```rust
static mut line_num_end: *mut libc::c_char = 0 as *const libc::c_char
    as *mut libc::c_char;
```
```rust
static mut line_num_start: *mut libc::c_char = 0 as *const libc::c_char
    as *mut libc::c_char;
```
```rust
static mut line_buf: [libc::c_char; 20] = [
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    ' ' as i32 as libc::c_char,
    '0' as i32 as libc::c_char,
    '\t' as i32 as libc::c_char,
    '\0' as i32 as libc::c_char,
];
```
```rust
static mut line_num_print: *mut libc::c_char = 0 as *const libc::c_char
    as *mut libc::c_char;
```
The file contains the following imports:
```rust
use ::rust::*;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::io::Write;
```
```rust
use std::ffi::CStr;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:98 ~ cat[4a5d]::is_ENOTSUP)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn is_ENOTSUP(mut err: libc::c_int) -> bool {
    return err == 95 as libc::c_int
        || 95 as libc::c_int != 95 as libc::c_int && err == 95 as libc::c_int;
}
```


The file contains the following imports:
```rust
use std::ffi::CStr;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::io::Write;
```
```rust
use ::rust::*;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:108 ~ cat[4a5d]::__gl_setmode)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn __gl_setmode(
    mut _fd: libc::c_int,
    mut _mode: libc::c_int,
) -> libc::c_int {
    return 0 as libc::c_int;
}
```
Here are its call sites
Call site 1:
```rust
return __gl_setmode(fd, mode);
```

The file contains the following imports:
```rust
use ::rust::*;
```
```rust
use std::os::raw::c_char;
```
```rust
use std::ffi::CStr;
```
```rust
use std::io::Write;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. If the function signature changed in translation, its callsites will need to be modified as well. Place each callsite translation (in the same order it appears above) between <CALL> and </CALL>. Note that even if the callsite is only a single statement, the translation can be mutiple statements. For example, you may need to declare new variables, or convert between types, either before or after the call. The translation should be such that the surrounding code is not affected by the changes.


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


DefId(0:109 ~ cat[4a5d]::set_binary_mode)
Chunk root
Here is a function:
```rust
unsafe extern "C" fn set_binary_mode(
    mut fd: libc::c_int,
    mut mode: libc::c_int,
) -> libc::c_int {
    return __gl_setmode(fd, mode);
}
```


The file contains the following imports:
```rust
use std::os::raw::c_char;
```
```rust
use std::ffi::CStr;
```
```rust
use std::io::Write;
```
```rust
use ::rust::*;
```
Convert the function to idiomatic Rust, meaning Rust code that does not make use of features like unsafe, raw pointers, and the C API whenever possible. Do not change the function name.

Follow the following format for your output: Place the function translation between the tags <FUNC> and </FUNC>. 


Any functions or variables without definitions are defined elsewhere in the code. Do not attempt to redefine them or import them.
If you are using any new functions and you need new imports for those, place them between the tags <IMPORTS> and </IMPORTS>. This should be only *new* imports. Do not include existing imports.
DO NOT include markdown characters like "```" or "```rust" in your translation.


