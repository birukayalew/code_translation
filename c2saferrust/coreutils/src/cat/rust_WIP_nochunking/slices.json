[
  {
    "func_defid": "DefId(0:899 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clzl)",
    "span": "src/stdc_leading_zeros.rs:22:1: 28:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:22:1: 28:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:1025 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ul)",
        "span": "src/stdc_leading_zeros.rs:69:5: 69:39 (#0)",
        "source": "return __gl_stdbit_clzl(n) as u32;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:7:1: 7:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:904 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ul)",
    "span": "src/stdc_leading_zeros.rs:68:1: 70:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:68:1: 70:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_ul(mut n: libc::c_ulong) -> libc::c_uint {\n    return __gl_stdbit_clzl(n) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:7:1: 7:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1003 ~ rust[fc84]::src::xmalloc::_gl_alloc_nomem)",
    "span": "src/xmalloc.rs:109:1: 114:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:109:1: 114:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:1160 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:70:13: 70:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1160 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:76:13: 76:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1159 ~ rust[fc84]::src::xmalloc::irealloc)",
        "span": "src/xmalloc.rs:58:12: 60:6 (#0)",
        "source": "{\n        _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:1161 ~ rust[fc84]::src::xmalloc::ireallocarray)",
        "span": "src/xmalloc.rs:102:12: 104:6 (#0)",
        "source": "{\n        _gl_alloc_nomem()\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1001 ~ rust[fc84]::src::xmalloc::icalloc)",
    "span": "src/xmalloc.rs:64:1: 84:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:64:1: 84:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1005 ~ rust[fc84]::src::xmalloc::check_nonnull)",
    "span": "src/xmalloc.rs:131:1: 136:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:131:1: 136:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:1166 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:148:1: 148:61 (#0)",
        "source": "return check_nonnull(allocated_memory as *mut libc::c_void);"
      },
      {
        "caller": "DefId(0:1171 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:207:24: 210:2 (#0)",
        "source": "{\n    let new_p = ireallocarray(p, n as usize, s as usize);\ncheck_nonnull(new_p)\n}"
      },
      {
        "caller": "DefId(0:1165 ~ rust[fc84]::src::xmalloc::xmalloc)",
        "span": "src/xmalloc.rs:140:5: 140:37 (#0)",
        "source": "return check_nonnull(malloc(s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1021 ~ rust[fc84]::src::xmalloc::xicalloc)",
    "span": "src/xmalloc.rs:335:1: 339:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:335:1: 339:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:275 ~ rust[fc84]::src::ialloc::_gl_alloc_nomem)",
    "span": "src/ialloc.rs:106:1: 112:2 (#0)",
    "pieces": [
      "src/ialloc.rs:106:1: 112:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:336 ~ rust[fc84]::src::ialloc::imalloc)",
        "span": "src/ialloc.rs:97:9: 97:27 (#0)",
        "source": "_gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:330 ~ rust[fc84]::src::ialloc::ireallocarray)",
        "span": "src/ialloc.rs:50:9: 50:27 (#0)",
        "source": "_gl_alloc_nomem();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:24 (#0)",
        "source": "use std::alloc::Layout;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:274 ~ rust[fc84]::src::ialloc::imalloc)",
    "span": "src/ialloc.rs:92:1: 100:2 (#0)",
    "pieces": [
      "src/ialloc.rs:92:1: 100:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:24 (#0)",
        "source": "use std::alloc::Layout;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:971 ~ rust[fc84]::src::xalloc_die::xalloc_die)",
    "span": "src/xalloc_die.rs:16:1: 53:2 (#0)",
    "pieces": [
      "src/xalloc_die.rs:16:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "pub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalloc_die.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xalloc_die.rs:1:1: 1:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:683 ~ rust[fc84]::src::mbrtoc32::mbszero)",
    "span": "src/mbrtoc32.rs:37:1: 41:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:37:1: 41:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:753 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
        "span": "src/mbrtoc32.rs:65:1: 65:17 (#0)",
        "source": "mbszero(ps_ref);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1011 ~ rust[fc84]::src::xmalloc::xreallocarray)",
    "span": "src/xmalloc.rs:191:1: 201:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:191:1: 201:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1172 ~ rust[fc84]::src::xmalloc::xnmalloc)",
        "span": "src/xmalloc.rs:213:5: 213:56 (#0)",
        "source": "return xreallocarray(0 as *mut libc::c_void, n, s);"
      },
      {
        "caller": "DefId(0:1175 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
        "span": "src/xmalloc.rs:257:5: 257:32 (#0)",
        "source": "p = xreallocarray(p, n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1016 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
    "span": "src/xmalloc.rs:234:1: 260:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:234:1: 260:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:48:1: 48:47 (#0)",
        "source": "pub const DEFAULT_MXFAST: C2RustUnnamed = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:39 ~ rust[fc84]::src::c_ctype::c_isupper)",
    "span": "src/c_ctype.rs:113:1: 115:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:113:1: 115:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:798 ~ rust[fc84]::src::quotearg::gettext_quote)",
    "span": "src/quotearg.rs:284:1: 317:2 (#0)",
    "pieces": [
      "src/quotearg.rs:284:1: 317:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "unsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:896 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:365:21: 365:72 (#0)",
        "source": "let left_quote = gettext_quote(\"`\", quoting_style);"
      },
      {
        "caller": "DefId(0:896 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:366:21: 366:73 (#0)",
        "source": "let right_quote = gettext_quote(\"'\", quoting_style);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:799 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
    "span": "src/quotearg.rs:319:1: 1214:2 (#0)",
    "pieces": [
      "src/quotearg.rs:319:1: 1214:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 902,
    "source": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:896 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1155:41: 1167:10 (#0)",
        "source": "{\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        }"
      },
      {
        "caller": "DefId(0:909 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1408:9: 1418:11 (#0)",
        "source": "quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );"
      },
      {
        "caller": "DefId(0:896 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1184:13: 1194:15 (#0)",
        "source": "return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );"
      },
      {
        "caller": "DefId(0:899 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1278:5: 1289:58 (#0)",
        "source": "let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:897 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
        "span": "src/quotearg.rs:1231:9: 1241:11 (#0)",
        "source": "r = quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffer.len().try_into().unwrap(),\n            arg.as_ptr(),\n            arg.len().try_into().unwrap(),\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        );"
      },
      {
        "caller": "DefId(0:909 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1388:5: 1398:7 (#0)",
        "source": "let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:899 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1291:5: 1301:7 (#0)",
        "source": "quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:85:1: 85:46 (#0)",
        "source": "pub const c_quoting_style: quoting_style = 5;"
      },
      {
        "span": "src/quotearg.rs:93:1: 93:52 (#0)",
        "source": "pub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;"
      },
      {
        "span": "src/quotearg.rs:88:1: 88:57 (#0)",
        "source": "pub const shell_always_quoting_style: quoting_style = 2;"
      },
      {
        "span": "src/quotearg.rs:86:1: 86:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:812 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
    "span": "src/quotearg.rs:1344:1: 1422:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1344:1: 1422:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 79,
    "source": "unsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}",
    "calls": [
      {
        "caller": "DefId(0:910 ~ rust[fc84]::src::quotearg::quotearg_n)",
        "span": "src/quotearg.rs:1425:5: 1433:6 (#0)",
        "source": "unsafe {\n        let options = &default_quoting_options;\n        quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            options,\n        )\n    }"
      },
      {
        "caller": "DefId(0:915 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1482:5: 1484:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr(), argsize, &o)\n    }"
      },
      {
        "caller": "DefId(0:923 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1564:22: 1571:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            &mut options,\n        )\n    }"
      },
      {
        "caller": "DefId(0:918 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1521:5: 1521:77 (#0)",
        "source": "return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);"
      },
      {
        "caller": "DefId(0:911 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
        "span": "src/quotearg.rs:1442:5: 1444:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr(), argsize, &default_quoting_options)\n    }"
      },
      {
        "caller": "DefId(0:926 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1604:5: 1604:56 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut o);"
      },
      {
        "caller": "DefId(0:914 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1468:5: 1470:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr(), u64::MAX, &o)\n    }"
      },
      {
        "caller": "DefId(0:930 ~ rust[fc84]::src::quotearg::quote_n_mem)",
        "span": "src/quotearg.rs:1659:5: 1659:76 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1309:1: 1309:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:1319:1: 1321:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1310:1: 1318:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:94:1: 94:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:833 ~ rust[fc84]::src::quotearg::quote_n_mem)",
    "span": "src/quotearg.rs:1654:1: 1660:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1654:1: 1660:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:931 ~ rust[fc84]::src::quotearg::quote_mem)",
        "span": "src/quotearg.rs:1664:18: 1664:86 (#0)",
        "source": "unsafe { quote_n_mem(0, arg.as_ptr(), argsize.try_into().unwrap()) }"
      },
      {
        "caller": "DefId(0:932 ~ rust[fc84]::src::quotearg::quote_n)",
        "span": "src/quotearg.rs:1670:5: 1672:6 (#0)",
        "source": "unsafe {\n        quote_n_mem(n, arg.as_ptr(), u64::MAX)\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1643:1: 1652:3 (#0)",
        "source": "pub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:835 ~ rust[fc84]::src::quotearg::quote_n)",
    "span": "src/quotearg.rs:1669:1: 1673:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1669:1: 1673:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:933 ~ rust[fc84]::src::quotearg::quote)",
        "span": "src/quotearg.rs:1677:5: 1677:38 (#0)",
        "source": "let result_ptr = quote_n(0, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:797 ~ rust[fc84]::src::quotearg::quoting_options_from_style)",
    "span": "src/quotearg.rs:267:1: 282:2 (#0)",
    "pieces": [
      "src/quotearg.rs:267:1: 282:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}",
    "calls": [
      {
        "caller": "DefId(0:915 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1479:5: 1479:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:923 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1561:5: 1561:45 (#0)",
        "source": "options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:914 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1467:5: 1467:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:90:1: 90:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:818 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
    "span": "src/quotearg.rs:1474:1: 1485:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1474:1: 1485:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:917 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
        "span": "src/quotearg.rs:1502:5: 1502:54 (#0)",
        "source": "let result_ptr = quotearg_n_style_mem(0, s, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:34 ~ rust[fc84]::src::c_ctype::c_isgraph)",
    "span": "src/c_ctype.rs:64:1: 70:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:64:1: 70:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:810 ~ rust[fc84]::src::quotearg::quotearg_free)",
    "span": "src/quotearg.rs:1323:1: 1342:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1323:1: 1342:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:1309:1: 1309:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:1319:1: 1321:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1310:1: 1318:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:1308:1: 1308:50 (#0)",
        "source": "static mut slot0: [libc::c_char; 256] = [0; 256];"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:110 ~ rust[fc84]::src::copy_file_range::rpl_copy_file_range)",
    "span": "src/copy_file_range.rs:33:1: 77:2 (#0)",
    "pieces": [
      "src/copy_file_range.rs:33:1: 77:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "pub unsafe extern \"C\" fn rpl_copy_file_range(\n    mut infd: libc::c_int,\n    mut pinoff: *mut off_t,\n    mut outfd: libc::c_int,\n    mut poutoff: *mut off_t,\n    mut length: size_t,\n    mut flags: libc::c_uint,\n) -> ssize_t {\n    static mut ok: libc::c_schar = 0;\n    if ok == 0 {\n        let mut name: utsname = utsname {\n            sysname: [0; 65],\n            nodename: [0; 65],\n            release: [0; 65],\n            version: [0; 65],\n            machine: [0; 65],\n            domainname: [0; 65],\n        };\n        uname(&mut name);\n        let mut p: *mut libc::c_char = (name.release).as_mut_ptr();\n        ok = (if *p.offset(1 as libc::c_int as isize) as libc::c_int != '.' as i32\n            || ('5' as i32) < *p.offset(0 as libc::c_int as isize) as libc::c_int\n            || *p.offset(0 as libc::c_int as isize) as libc::c_int == '5' as i32\n                && (*p.offset(3 as libc::c_int as isize) as libc::c_int != '.' as i32\n                    || ('2' as i32)\n                        < *p.offset(2 as libc::c_int as isize) as libc::c_int)\n        {\n            1 as libc::c_int\n        } else {\n            -(1 as libc::c_int)\n        }) as libc::c_schar;\n    }\n    if (0 as libc::c_int) < ok as libc::c_int {\n        return copy_file_range(infd, pinoff, outfd, poutoff, length, flags);\n    }\n    *__errno_location() = 38 as libc::c_int;\n    return -(1 as libc::c_int) as ssize_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/copy_file_range.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/copy_file_range.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:202 ~ rust[fc84]::src::fflush::clear_ungetc_buffer_preserving_position)",
    "span": "src/fflush.rs:52:1: 58:2 (#0)",
    "pieces": [
      "src/fflush.rs:52:1: 58:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:241 ~ rust[fc84]::src::fflush::rpl_fflush)",
        "span": "src/fflush.rs:65:17: 65:60 (#0)",
        "source": "clear_ungetc_buffer_preserving_position(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fflush.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:882 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:18:1: 23:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:18:1: 23:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:986 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
        "span": "src/setlocale_null_unlocked.rs:29:39: 29:83 (#0)",
        "source": "unsafe { setlocale_null_unlocked(category) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:791 ~ rust[fc84]::src::quotearg::clone_quoting_options)",
    "span": "src/quotearg.rs:187:1: 191:2 (#0)",
    "pieces": [
      "src/quotearg.rs:187:1: 191:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:849 ~ rust[fc84]::src::safe_read::safe_read)",
    "span": "src/safe_read.rs:12:1: 34:2 (#0)",
    "pieces": [
      "src/safe_read.rs:12:1: 34:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn safe_read(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = read(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/safe_read.rs:9:1: 9:55 (#0)",
        "source": "pub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;"
      }
    ],
    "imports": [
      {
        "span": "src/safe_read.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:203 ~ rust[fc84]::src::fflush::rpl_fflush)",
    "span": "src/fflush.rs:61:1: 71:2 (#0)",
    "pieces": [
      "src/fflush.rs:61:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/fflush.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:794 ~ rust[fc84]::src::quotearg::set_char_quoting)",
    "span": "src/quotearg.rs:215:1: 233:2 (#0)",
    "pieces": [
      "src/quotearg.rs:215:1: 233:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 30,
    "source": "pub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:923 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1562:5: 1562:56 (#0)",
        "source": "set_char_quoting(Some(&mut options), ':' as i8, 1);"
      },
      {
        "caller": "DefId(0:918 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1520:5: 1520:68 (#0)",
        "source": "let result = set_char_quoting(Some(&mut options), ch as i8, 1);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:826 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
    "span": "src/quotearg.rs:1549:1: 1574:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1549:1: 1574:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:90:1: 90:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1004 ~ rust[fc84]::src::xmalloc::imalloc)",
    "span": "src/xmalloc.rs:117:1: 129:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:117:1: 129:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1166 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:144:5: 144:78 (#0)",
        "source": "let allocated_memory = imalloc(s.try_into().expect(\"Conversion failed\"));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1007 ~ rust[fc84]::src::xmalloc::ximalloc)",
    "span": "src/xmalloc.rs:143:1: 149:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:143:1: 149:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1024 ~ rust[fc84]::src::xmalloc::ximemdup0)",
    "span": "src/xmalloc.rs:356:1: 361:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:356:1: 361:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:271 ~ rust[fc84]::src::ialloc::ireallocarray)",
    "span": "src/ialloc.rs:28:1: 53:2 (#0)",
    "pieces": [
      "src/ialloc.rs:28:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:24 (#0)",
        "source": "use std::alloc::Layout;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:872 ~ rust[fc84]::src::setlocale_null::setlocale_null)",
    "span": "src/setlocale_null.rs:27:1: 34:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:27:1: 34:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:977 ~ rust[fc84]::src::xbinary_io::xset_binary_mode_error)",
    "span": "src/xbinary_io.rs:20:1: 25:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:20:1: 25:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "pub unsafe extern \"C\" fn xset_binary_mode_error() {}",
    "calls": [
      {
        "caller": "DefId(0:1113 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)",
        "span": "src/xbinary_io.rs:12:13: 12:38 (#0)",
        "source": "xset_binary_mode_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:900 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clzll)",
    "span": "src/stdc_leading_zeros.rs:31:1: 37:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:31:1: 37:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:7:1: 7:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:796 ~ rust[fc84]::src::quotearg::set_custom_quoting)",
    "span": "src/quotearg.rs:252:1: 266:2 (#0)",
    "pieces": [
      "src/quotearg.rs:252:1: 266:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}",
    "calls": [
      {
        "caller": "DefId(0:926 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1603:5: 1603:57 (#0)",
        "source": "set_custom_quoting(&mut o, left_quote, right_quote);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:80:1: 80:52 (#0)",
        "source": "pub const custom_quoting_style: quoting_style = 10;"
      },
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:829 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
    "span": "src/quotearg.rs:1595:1: 1605:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1595:1: 1605:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}",
    "calls": [
      {
        "caller": "DefId(0:928 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
        "span": "src/quotearg.rs:1630:22: 1638:6 (#0)",
        "source": "unsafe {\n        quotearg_n_custom_mem(\n            0,\n            left_quote.as_ptr(),\n            right_quote.as_ptr(),\n            arg.as_ptr(),\n            argsize,\n        )\n    }"
      },
      {
        "caller": "DefId(0:925 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
        "span": "src/quotearg.rs:1583:5: 1591:6 (#0)",
        "source": "unsafe {\n        quotearg_n_custom_mem(\n            n,\n            left_quote,\n            right_quote,\n            arg,\n            u64::MAX,\n        )\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:828 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
    "span": "src/quotearg.rs:1577:1: 1592:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1577:1: 1592:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:927 ~ rust[fc84]::src::quotearg::quotearg_custom)",
        "span": "src/quotearg.rs:1616:5: 1616:106 (#0)",
        "source": "let result_ptr = quotearg_n_custom(0, left_quote_c.as_ptr(), right_quote_c.as_ptr(), arg_c.as_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:47 ~ rust[fc84]::src::c_strcasecmp::c_tolower)",
    "span": "src/c_strcasecmp.rs:6:1: 11:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:6:1: 11:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:63 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:15:5: 15:54 (#0)",
        "source": "let c1 = s1.chars().map(|c| c_tolower(c as i32));"
      },
      {
        "caller": "DefId(0:63 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:16:5: 16:54 (#0)",
        "source": "let c2 = s2.chars().map(|c| c_tolower(c as i32));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_strcasecmp.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:871 ~ rust[fc84]::src::setlocale_null::setlocale_null_r)",
    "span": "src/setlocale_null.rs:15:1: 24:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:15:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/setlocale_null.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:42 ~ rust[fc84]::src::c_ctype::c_toupper)",
    "span": "src/c_ctype.rs:137:1: 142:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:137:1: 142:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:800 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
    "span": "src/quotearg.rs:1216:1: 1246:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1216:1: 1246:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1002 ~ rust[fc84]::src::xmalloc::ireallocarray)",
    "span": "src/xmalloc.rs:87:1: 105:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:87:1: 105:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1171 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:208:5: 208:58 (#0)",
        "source": "let new_p = ireallocarray(p, n as usize, s as usize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:38 ~ rust[fc84]::src::c_ctype::c_isspace)",
    "span": "src/c_ctype.rs:106:1: 108:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:106:1: 108:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:935 ~ rust[fc84]::src::version_etc::version_etc_arn)",
    "span": "src/version_etc.rs:68:1: 250:2 (#0)",
    "pieces": [
      "src/version_etc.rs:68:1: 250:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 183,
    "source": "pub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1064 ~ rust[fc84]::src::version_etc::version_etc_va)",
        "span": "src/version_etc.rs:287:5: 294:7 (#0)",
        "source": "version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );"
      },
      {
        "caller": "DefId(0:1063 ~ rust[fc84]::src::version_etc::version_etc_ar)",
        "span": "src/version_etc.rs:265:5: 265:81 (#0)",
        "source": "version_etc_arn(stream, command_name, package, version, authors, n_authors);"
      }
    ],
    "globals": [
      {
        "span": "src/version_etc.rs:65:1: 65:48 (#0)",
        "source": "pub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;"
      }
    ],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:937 ~ rust[fc84]::src::version_etc::version_etc_va)",
    "span": "src/version_etc.rs:268:1: 295:2 (#0)",
    "pieces": [
      "src/version_etc.rs:268:1: 295:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "pub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:1067 ~ rust[fc84]::src::version_etc::version_etc)",
        "span": "src/version_etc.rs:306:5: 306:82 (#0)",
        "source": "version_etc_va(stream, command_name, package, version, authors.as_va_list());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:940 ~ rust[fc84]::src::version_etc::version_etc)",
    "span": "src/version_etc.rs:297:1: 307:2 (#0)",
    "pieces": [
      "src/version_etc.rs:297:1: 307:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:2:1: 2:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1000 ~ rust[fc84]::src::xmalloc::irealloc)",
    "span": "src/xmalloc.rs:53:1: 61:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:53:1: 61:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:22 ~ rust[fc84]::src::binary_io::__gl_setmode)",
    "span": "src/binary_io.rs:15:1: 17:2 (#0)",
    "pieces": [
      "src/binary_io.rs:15:1: 17:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:27 ~ rust[fc84]::src::binary_io::set_binary_mode)",
        "span": "src/binary_io.rs:8:51: 10:2 (#0)",
        "source": "{\n    __gl_setmode(fd, mode)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/binary_io.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/binary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:21 ~ rust[fc84]::src::binary_io::set_binary_mode)",
    "span": "src/binary_io.rs:8:1: 10:2 (#0)",
    "pieces": [
      "src/binary_io.rs:8:1: 10:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/binary_io.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/binary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:979 ~ rust[fc84]::src::xbinary_io::__gl_setmode)",
    "span": "src/xbinary_io.rs:33:1: 35:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:33:1: 35:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:1115 ~ rust[fc84]::src::xbinary_io::set_binary_mode)",
        "span": "src/xbinary_io.rs:28:47: 30:2 (#0)",
        "source": "{\n    __gl_setmode(fd, mode)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:978 ~ rust[fc84]::src::xbinary_io::set_binary_mode)",
    "span": "src/xbinary_io.rs:28:1: 30:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:28:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1010 ~ rust[fc84]::src::xmalloc::xirealloc)",
    "span": "src/xmalloc.rs:179:1: 188:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:179:1: 188:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:834 ~ rust[fc84]::src::quotearg::quote_mem)",
    "span": "src/quotearg.rs:1662:1: 1666:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1662:1: 1666:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1006 ~ rust[fc84]::src::xmalloc::xmalloc)",
    "span": "src/xmalloc.rs:139:1: 141:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:139:1: 141:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1022 ~ rust[fc84]::src::xmalloc::xmemdup)",
    "span": "src/xmalloc.rs:342:1: 346:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:342:1: 346:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1025 ~ rust[fc84]::src::xmalloc::xstrdup)",
    "span": "src/xmalloc.rs:364:1: 370:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:364:1: 370:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:889 ~ rust[fc84]::src::stdbit::__gl_stdbit_clzl)",
    "span": "src/stdbit.rs:26:1: 32:2 (#0)",
    "pieces": [
      "src/stdbit.rs:26:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:9:1: 9:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdbit.rs:7:1: 7:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::u64;"
      },
      {
        "span": "src/stdbit.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:29 ~ rust[fc84]::src::c_ctype::c_isalpha)",
    "span": "src/c_ctype.rs:29:1: 31:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:29:1: 31:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:862 ~ rust[fc84]::src::safe_write::safe_write)",
    "span": "src/safe_write.rs:12:1: 34:2 (#0)",
    "pieces": [
      "src/safe_write.rs:12:1: 34:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn safe_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = write(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/safe_write.rs:9:1: 9:55 (#0)",
        "source": "pub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;"
      }
    ],
    "imports": [
      {
        "span": "src/safe_write.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:888 ~ rust[fc84]::src::stdbit::__gl_stdbit_clz)",
    "span": "src/stdbit.rs:15:1: 21:2 (#0)",
    "pieces": [
      "src/stdbit.rs:15:1: 21:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:7:1: 7:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdbit.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:9:1: 9:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::u64;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:30 ~ rust[fc84]::src::c_ctype::c_isascii)",
    "span": "src/c_ctype.rs:36:1: 38:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:36:1: 38:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:31 ~ rust[fc84]::src::c_ctype::c_isblank)",
    "span": "src/c_ctype.rs:43:1: 45:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:43:1: 45:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1023 ~ rust[fc84]::src::xmalloc::ximemdup)",
    "span": "src/xmalloc.rs:349:1: 353:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:349:1: 353:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:892 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctzl)",
    "span": "src/stdbit.rs:59:1: 65:2 (#0)",
    "pieces": [
      "src/stdbit.rs:59:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_ctzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::u64;"
      },
      {
        "span": "src/stdbit.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:9:1: 9:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdbit.rs:7:1: 7:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:814 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
    "span": "src/quotearg.rs:1437:1: 1445:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1437:1: 1445:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:913 ~ rust[fc84]::src::quotearg::quotearg_mem)",
        "span": "src/quotearg.rs:1459:1: 1459:36 (#0)",
        "source": "return quotearg_n_mem(0, arg_cstr);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:816 ~ rust[fc84]::src::quotearg::quotearg_mem)",
    "span": "src/quotearg.rs:1454:1: 1460:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1454:1: 1460:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1012 ~ rust[fc84]::src::xmalloc::xireallocarray)",
    "span": "src/xmalloc.rs:203:1: 210:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:203:1: 210:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:831 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
    "span": "src/quotearg.rs:1624:1: 1640:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1624:1: 1640:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:960 ~ rust[fc84]::src::xalignalloc::alignalloc)",
    "span": "src/xalignalloc.rs:13:1: 39:2 (#0)",
    "pieces": [
      "src/xalignalloc.rs:13:1: 39:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn alignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {\n        alignment = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {\n        size = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalignalloc.rs:2:1: 2:33 (#0)",
        "source": "use std::alloc::{alloc, Layout};"
      },
      {
        "span": "src/xalignalloc.rs:2:25: 2:31 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xalignalloc.rs:2:18: 2:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xalignalloc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:961 ~ rust[fc84]::src::xalignalloc::xalignalloc)",
    "span": "src/xalignalloc.rs:42:1: 50:2 (#0)",
    "pieces": [
      "src/xalignalloc.rs:42:1: 50:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xalignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    let mut p: *mut libc::c_void = alignalloc(alignment, size);\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalignalloc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xalignalloc.rs:2:1: 2:33 (#0)",
        "source": "use std::alloc::{alloc, Layout};"
      },
      {
        "span": "src/xalignalloc.rs:2:25: 2:31 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xalignalloc.rs:2:18: 2:23 (#0)",
        "source": "alloc"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1020 ~ rust[fc84]::src::xmalloc::xcalloc)",
    "span": "src/xmalloc.rs:327:1: 332:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:327:1: 332:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1018 ~ rust[fc84]::src::xmalloc::xzalloc)",
    "span": "src/xmalloc.rs:309:1: 317:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:309:1: 317:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:976 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)",
    "span": "src/xbinary_io.rs:9:1: 15:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:9:1: 15:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:41 ~ rust[fc84]::src::c_ctype::c_tolower)",
    "span": "src/c_ctype.rs:127:1: 132:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:127:1: 132:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:48 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
    "span": "src/c_strcasecmp.rs:14:1: 35:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:14:1: 35:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "pub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:92 ~ rust[fc84]::src::closeout::close_stdout_set_file_name)",
    "span": "src/closeout.rs:69:1: 74:2 (#0)",
    "pieces": [
      "src/closeout.rs:69:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:67:1: 67:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:3:1: 3:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/closeout.rs:5:1: 5:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:2:1: 2:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:32 ~ rust[fc84]::src::c_ctype::c_iscntrl)",
    "span": "src/c_ctype.rs:50:1: 52:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:50:1: 52:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:693 ~ rust[fc84]::src::mbszero::mbszero)",
    "span": "src/mbszero.rs:27:1: 32:2 (#0)",
    "pieces": [
      "src/mbszero.rs:27:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mbszero.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/mbszero.rs:1:1: 1:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:817 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
    "span": "src/quotearg.rs:1462:1: 1471:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1462:1: 1471:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:916 ~ rust[fc84]::src::quotearg::quotearg_style)",
        "span": "src/quotearg.rs:1493:5: 1493:57 (#0)",
        "source": "let result = quotearg_n_style(0, s, c_str.as_ref());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:819 ~ rust[fc84]::src::quotearg::quotearg_style)",
    "span": "src/quotearg.rs:1488:1: 1495:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1488:1: 1495:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1019 ~ rust[fc84]::src::xmalloc::xizalloc)",
    "span": "src/xmalloc.rs:320:1: 324:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:320:1: 324:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:821 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
    "span": "src/quotearg.rs:1507:1: 1522:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1507:1: 1522:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}",
    "calls": [
      {
        "caller": "DefId(0:920 ~ rust[fc84]::src::quotearg::quotearg_char)",
        "span": "src/quotearg.rs:1526:5: 1528:6 (#0)",
        "source": "unsafe {\n        quotearg_char_mem(arg.as_ptr(), u64::MAX, ch_as_i8)\n    }"
      },
      {
        "caller": "DefId(0:922 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
        "span": "src/quotearg.rs:1543:9: 1543:105 (#0)",
        "source": "result_ptr = quotearg_char_mem(arg.as_ptr(), argsize.try_into().unwrap(), ':' as i32 as c_char);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:90:1: 90:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:825 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
    "span": "src/quotearg.rs:1539:1: 1546:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1539:1: 1546:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:272 ~ rust[fc84]::src::ialloc::icalloc)",
    "span": "src/ialloc.rs:58:1: 73:2 (#0)",
    "pieces": [
      "src/ialloc.rs:58:1: 73:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:6:1: 6:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:24 (#0)",
        "source": "use std::alloc::Layout;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:715 ~ rust[fc84]::src::progname::set_program_name)",
    "span": "src/progname.rs:59:1: 96:2 (#0)",
    "pieces": [
      "src/progname.rs:59:1: 96:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "pub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/progname.rs:57:1: 57:77 (#0)",
        "source": "pub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/progname.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:898 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clz)",
    "span": "src/stdc_leading_zeros.rs:13:1: 19:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:13:1: 19:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:7:1: 7:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:901 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ui)",
    "span": "src/stdc_leading_zeros.rs:42:1: 45:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:42:1: 45:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_ui(mut n: libc::c_uint) -> libc::c_uint {\n    return __gl_stdbit_clz(n) as libc::c_uint;\n}",
    "calls": [
      {
        "caller": "DefId(0:1023 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_uc)",
        "span": "src/stdc_leading_zeros.rs:51:5: 51:57 (#0)",
        "source": "let leading_zeros = stdc_leading_zeros_ui(n as u32);"
      },
      {
        "caller": "DefId(0:1024 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_us)",
        "span": "src/stdc_leading_zeros.rs:60:5: 60:57 (#0)",
        "source": "let leading_zeros = stdc_leading_zeros_ui(n as u32);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:7:1: 7:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:902 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_uc)",
    "span": "src/stdc_leading_zeros.rs:50:1: 54:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:50:1: 54:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_uc(mut n: libc::c_uchar) -> libc::c_uint {\n    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)\n        .wrapping_sub(\n            (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(\n                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n                        .wrapping_sub(\n                            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong,\n                        ),\n                ),\n        ) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:7:1: 7:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:245 ~ rust[fc84]::src::full_write::full_write)",
    "span": "src/full_write.rs:10:1: 33:2 (#0)",
    "pieces": [
      "src/full_write.rs:10:1: 33:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn full_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    let mut total: size_t = 0 as libc::c_int as size_t;\n    let mut ptr: *const libc::c_char = buf as *const libc::c_char;\n    while count > 0 as libc::c_int as libc::c_ulong {\n        let mut n_rw: size_t = safe_write(fd, ptr as *const libc::c_void, count);\n        if n_rw == -(1 as libc::c_int) as size_t {\n            break;\n        }\n        if n_rw == 0 as libc::c_int as libc::c_ulong {\n            *__errno_location() = 28 as libc::c_int;\n            break;\n        } else {\n            total = (total as libc::c_ulong).wrapping_add(n_rw) as size_t as size_t;\n            ptr = ptr.offset(n_rw as isize);\n            count = (count as libc::c_ulong).wrapping_sub(n_rw) as size_t as size_t;\n        }\n    }\n    return total;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/full_write.rs:1:1: 1:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/full_write.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:16 ~ rust[fc84]::src::alignalloc::alignfree)",
    "span": "src/alignalloc.rs:29:1: 33:2 (#0)",
    "pieces": [
      "src/alignalloc.rs:29:1: 33:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn alignfree(mut ptr: *mut libc::c_void) {\n    free(ptr);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/alignalloc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/alignalloc.rs:1:1: 1:19 (#0)",
        "source": "use std::any::Any;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:890 ~ rust[fc84]::src::stdbit::__gl_stdbit_clzll)",
    "span": "src/stdbit.rs:37:1: 43:2 (#0)",
    "pieces": [
      "src/stdbit.rs:37:1: 43:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:9:1: 9:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::u64;"
      },
      {
        "span": "src/stdbit.rs:7:1: 7:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:37 ~ rust[fc84]::src::c_ctype::c_ispunct)",
    "span": "src/c_ctype.rs:98:1: 101:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:98:1: 101:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:273 ~ rust[fc84]::src::ialloc::irealloc)",
    "span": "src/ialloc.rs:78:1: 87:2 (#0)",
    "pieces": [
      "src/ialloc.rs:78:1: 87:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:24 (#0)",
        "source": "use std::alloc::Layout;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:784 ~ rust[fc84]::src::quotearg::mbszero)",
    "span": "src/quotearg.rs:145:1: 151:2 (#0)",
    "pieces": [
      "src/quotearg.rs:145:1: 151:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:94 ~ rust[fc84]::src::closeout::close_stdout_set_ignore_EPIPE)",
    "span": "src/closeout.rs:78:1: 82:2 (#0)",
    "pieces": [
      "src/closeout.rs:78:1: 82:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:76:1: 76:39 (#0)",
        "source": "static mut ignore_EPIPE: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:3:1: 3:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/closeout.rs:2:1: 2:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/closeout.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:5:1: 5:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:891 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctz)",
    "span": "src/stdbit.rs:48:1: 54:2 (#0)",
    "pieces": [
      "src/stdbit.rs:48:1: 54:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_ctz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::u64;"
      },
      {
        "span": "src/stdbit.rs:9:1: 9:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdbit.rs:7:1: 7:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:236 ~ rust[fc84]::src::fseeko::rpl_fseeko)",
    "span": "src/fseeko.rs:52:1: 74:2 (#0)",
    "pieces": [
      "src/fseeko.rs:52:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fseeko.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fseeko.rs:1:1: 1:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:883 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:25:1: 51:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:25:1: 51:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1015 ~ rust[fc84]::src::xmalloc::x2realloc)",
    "span": "src/xmalloc.rs:223:1: 231:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:223:1: 231:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1013 ~ rust[fc84]::src::xmalloc::xnmalloc)",
    "span": "src/xmalloc.rs:212:1: 214:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:212:1: 214:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1008 ~ rust[fc84]::src::xmalloc::xcharalloc)",
    "span": "src/xmalloc.rs:151:1: 162:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:151:1: 162:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:830 ~ rust[fc84]::src::quotearg::quotearg_custom)",
    "span": "src/quotearg.rs:1607:1: 1621:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1607:1: 1621:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:724 ~ rust[fc84]::src::propername_lite::proper_name_lite)",
    "span": "src/propername_lite.rs:8:1: 24:2 (#0)",
    "pieces": [
      "src/propername_lite.rs:8:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/propername_lite.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:903 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_us)",
    "span": "src/stdc_leading_zeros.rs:59:1: 63:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:59:1: 63:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_us(mut n: libc::c_ushort) -> libc::c_uint {\n    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)\n        .wrapping_sub(\n            (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(\n                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n                        .wrapping_sub(\n                            ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong,\n                        ),\n                ),\n        ) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:7:1: 7:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:802 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
    "span": "src/quotearg.rs:1260:1: 1307:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1260:1: 1307:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}",
    "calls": [
      {
        "caller": "DefId(0:898 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
        "span": "src/quotearg.rs:1255:18: 1255:93 (#0)",
        "source": "unsafe { quotearg_alloc_mem(arg_ptr, argsize as u64, 0 as *mut size_t, o) }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:94:1: 94:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      },
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:801 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
    "span": "src/quotearg.rs:1249:1: 1257:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1249:1: 1257:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:813 ~ rust[fc84]::src::quotearg::quotearg_n)",
    "span": "src/quotearg.rs:1424:1: 1434:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1424:1: 1434:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:912 ~ rust[fc84]::src::quotearg::quotearg)",
        "span": "src/quotearg.rs:1449:5: 1449:41 (#0)",
        "source": "let result_ptr = quotearg_n(0, arg);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:815 ~ rust[fc84]::src::quotearg::quotearg)",
    "span": "src/quotearg.rs:1448:1: 1451:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1448:1: 1451:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:893 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctzll)",
    "span": "src/stdbit.rs:70:1: 76:2 (#0)",
    "pieces": [
      "src/stdbit.rs:70:1: 76:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_ctzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:3:1: 3:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:9:1: 9:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdbit.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:7:1: 7:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdbit.rs:5:1: 5:14 (#0)",
        "source": "use std::u64;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:15 ~ rust[fc84]::src::alignalloc::alignalloc)",
    "span": "src/alignalloc.rs:14:1: 25:2 (#0)",
    "pieces": [
      "src/alignalloc.rs:14:1: 25:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn alignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {\n        alignment = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {\n        size = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/alignalloc.rs:1:1: 1:19 (#0)",
        "source": "use std::any::Any;"
      },
      {
        "span": "src/alignalloc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:905 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ull)",
    "span": "src/stdc_leading_zeros.rs:75:1: 77:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:75:1: 77:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_ull(\n    mut n: libc::c_ulonglong,\n) -> libc::c_uint {\n    return __gl_stdbit_clzll(n) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:11:1: 11:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:9:1: 9:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:7:1: 7:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:941 ~ rust[fc84]::src::version_etc::emit_bug_reporting_address)",
    "span": "src/version_etc.rs:309:1: 324:2 (#0)",
    "pieces": [
      "src/version_etc.rs:309:1: 324:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:2:1: 2:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:793 ~ rust[fc84]::src::quotearg::set_quoting_style)",
    "span": "src/quotearg.rs:203:1: 212:2 (#0)",
    "pieces": [
      "src/quotearg.rs:203:1: 212:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:179 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD)",
    "span": "src/fcntl.rs:69:1: 73:2 (#0)",
    "pieces": [
      "src/fcntl.rs:69:1: 73:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn rpl_fcntl_DUPFD(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    result = fcntl(fd, 0 as libc::c_int, target);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:212 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
        "span": "src/fcntl.rs:34:13: 34:50 (#0)",
        "source": "result = rpl_fcntl_DUPFD(fd, target);"
      },
      {
        "caller": "DefId(0:215 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
        "span": "src/fcntl.rs:98:13: 98:50 (#0)",
        "source": "result = rpl_fcntl_DUPFD(fd, target);"
      },
      {
        "caller": "DefId(0:215 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
        "span": "src/fcntl.rs:92:17: 92:54 (#0)",
        "source": "result = rpl_fcntl_DUPFD(fd, target);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fcntl.rs:4:1: 4:22 (#0)",
        "source": "use std::ffi::VaList;"
      },
      {
        "span": "src/fcntl.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:181 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
    "span": "src/fcntl.rs:76:1: 116:2 (#0)",
    "pieces": [
      "src/fcntl.rs:76:1: 116:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 32,
    "source": "unsafe extern \"C\" fn rpl_fcntl_DUPFD_CLOEXEC(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    if 0 as libc::c_int <= have_dupfd_cloexec {\n        result = fcntl(fd, 1030 as libc::c_int, target);\n        if 0 as libc::c_int <= result || *__errno_location() != 22 as libc::c_int {\n            have_dupfd_cloexec = 1 as libc::c_int;\n        } else {\n            result = rpl_fcntl_DUPFD(fd, target);\n            if result >= 0 as libc::c_int {\n                have_dupfd_cloexec = -(1 as libc::c_int);\n            }\n        }\n    } else {\n        result = rpl_fcntl_DUPFD(fd, target);\n    }\n    if 0 as libc::c_int <= result && have_dupfd_cloexec == -(1 as libc::c_int) {\n        let mut flags: libc::c_int = fcntl(result, 1 as libc::c_int);\n        if flags < 0 as libc::c_int\n            || fcntl(result, 2 as libc::c_int, flags | 1 as libc::c_int)\n                == -(1 as libc::c_int)\n        {\n            let mut saved_errno: libc::c_int = *__errno_location();\n            close(result);\n            *__errno_location() = saved_errno;\n            result = -(1 as libc::c_int);\n        }\n    }\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:212 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
        "span": "src/fcntl.rs:38:13: 38:58 (#0)",
        "source": "result = rpl_fcntl_DUPFD_CLOEXEC(fd, target);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fcntl.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fcntl.rs:4:1: 4:22 (#0)",
        "source": "use std::ffi::VaList;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:823 ~ rust[fc84]::src::quotearg::quotearg_char)",
    "span": "src/quotearg.rs:1524:1: 1529:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1524:1: 1529:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}",
    "calls": [
      {
        "caller": "DefId(0:921 ~ rust[fc84]::src::quotearg::quotearg_colon)",
        "span": "src/quotearg.rs:1534:5: 1534:45 (#0)",
        "source": "let result_ptr = quotearg_char(arg, ch);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:824 ~ rust[fc84]::src::quotearg::quotearg_colon)",
    "span": "src/quotearg.rs:1532:1: 1536:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1532:1: 1536:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:836 ~ rust[fc84]::src::quotearg::quote)",
    "span": "src/quotearg.rs:1676:1: 1679:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1676:1: 1679:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:820 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
    "span": "src/quotearg.rs:1498:1: 1504:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1498:1: 1504:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:254 ~ rust[fc84]::src::hard_locale::hard_locale)",
    "span": "src/hard_locale.rs:14:1: 31:2 (#0)",
    "pieces": [
      "src/hard_locale.rs:14:1: 31:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hard_locale.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hard_locale.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:36 ~ rust[fc84]::src::c_ctype::c_isprint)",
    "span": "src/c_ctype.rs:82:1: 93:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:82:1: 93:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:667 ~ rust[fc84]::src::localcharset::locale_charset)",
    "span": "src/localcharset.rs:394:1: 408:2 (#0)",
    "pieces": [
      "src/localcharset.rs:394:1: 408:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/localcharset.rs:8:1: 8:39 (#0)",
        "source": "pub const CODESET: C2RustUnnamed = 14;"
      }
    ],
    "imports": [
      {
        "span": "src/localcharset.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/localcharset.rs:2:1: 2:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/localcharset.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:40 ~ rust[fc84]::src::c_ctype::c_isxdigit)",
    "span": "src/c_ctype.rs:120:1: 122:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:120:1: 122:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:182 ~ rust[fc84]::src::fcntl::run_static_initializers)",
    "span": "src/fcntl.rs:118:1: 124:2 (#0)",
    "pieces": [
      "src/fcntl.rs:118:1: 124:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn run_static_initializers() {\n    have_dupfd_cloexec = if 0 as libc::c_int != 0 {\n        -(1 as libc::c_int)\n    } else {\n        0 as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/fcntl.rs:75:1: 75:48 (#0)",
        "source": "static mut have_dupfd_cloexec: libc::c_int = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/fcntl.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fcntl.rs:4:1: 4:22 (#0)",
        "source": "use std::ffi::VaList;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:28 ~ rust[fc84]::src::c_ctype::c_isalnum)",
    "span": "src/c_ctype.rs:22:1: 24:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:22:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:35 ~ rust[fc84]::src::c_ctype::c_islower)",
    "span": "src/c_ctype.rs:75:1: 77:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:75:1: 77:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:33 ~ rust[fc84]::src::c_ctype::c_isdigit)",
    "span": "src/c_ctype.rs:57:1: 59:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:57:1: 59:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:685 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
    "span": "src/mbrtoc32.rs:48:1: 79:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:48:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 31,
    "source": "pub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/mbrtoc32.rs:43:1: 46:3 (#0)",
        "source": "static mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};"
      }
    ],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:792 ~ rust[fc84]::src::quotearg::get_quoting_style)",
    "span": "src/quotearg.rs:194:1: 200:2 (#0)",
    "pieces": [
      "src/quotearg.rs:194:1: 200:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:95 ~ rust[fc84]::src::closeout::close_stdout)",
    "span": "src/closeout.rs:85:1: 161:2 (#0)",
    "pieces": [
      "src/closeout.rs:85:1: 161:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:67:1: 67:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:3:1: 3:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/closeout.rs:5:1: 5:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:2:1: 2:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1009 ~ rust[fc84]::src::xmalloc::xrealloc)",
    "span": "src/xmalloc.rs:165:1: 176:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:165:1: 176:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:146 ~ rust[fc84]::src::fadvise::fdadvise)",
    "span": "src/fadvise.rs:64:1: 73:2 (#0)",
    "pieces": [
      "src/fadvise.rs:64:1: 73:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn fdadvise(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut len: off_t,\n    mut advice: fadvice_t,\n) {\n    posix_fadvise(fd, offset, len, advice as libc::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:178 ~ rust[fc84]::src::fadvise::fadvise)",
        "span": "src/fadvise.rs:78:5: 78:32 (#0)",
        "source": "fdadvise(fd, 0, 0, advice);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fadvise.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/fadvise.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:147 ~ rust[fc84]::src::fadvise::fadvise)",
    "span": "src/fadvise.rs:76:1: 79:2 (#0)",
    "pieces": [
      "src/fadvise.rs:76:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn fadvise(mut fp: *mut FILE, mut advice: fadvice_t) {\n    if !fp.is_null() {\n        fdadvise(\n            fileno(fp),\n            0 as libc::c_int as off_t,\n            0 as libc::c_int as off_t,\n            advice,\n        );\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fadvise.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fadvise.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:167 ~ rust[fc84]::src::fclose::rpl_fclose)",
    "span": "src/fclose.rs:53:1: 73:2 (#0)",
    "pieces": [
      "src/fclose.rs:53:1: 73:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fclose.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1017 ~ rust[fc84]::src::xmalloc::xpalloc)",
    "span": "src/xmalloc.rs:262:1: 306:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:262:1: 306:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 706,
    "source": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:783 ~ rust[fc84]::src::quotearg::c32isprint)",
    "span": "src/quotearg.rs:140:1: 142:2 (#0)",
    "pieces": [
      "src/quotearg.rs:140:1: 142:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:795 ~ rust[fc84]::src::quotearg::set_quoting_flags)",
    "span": "src/quotearg.rs:236:1: 249:2 (#0)",
    "pieces": [
      "src/quotearg.rs:236:1: 249:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:22:1: 22:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:24:1: 24:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:35:1: 35:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:178 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
    "span": "src/fcntl.rs:24:1: 67:2 (#0)",
    "pieces": [
      "src/fcntl.rs:24:1: 67:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 136,
    "source": "pub unsafe extern \"C\" fn rpl_fcntl(\n    mut fd: libc::c_int,\n    mut action: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut arg: ::core::ffi::VaListImpl;\n    let mut result: libc::c_int = -(1 as libc::c_int);\n    arg = args.clone();\n    match action {\n        0 => {\n            let mut target: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD(fd, target);\n        }\n        1030 => {\n            let mut target_0: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD_CLOEXEC(fd, target_0);\n        }\n        _ => {\n            let mut current_block_7: u64;\n            match action {\n                1 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                3 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                1025 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                9 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                1032 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                1034 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                11 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                1033 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                0 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                1030 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                1026 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                2 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                4 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                8 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1031 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1024 | 10 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {\n                    let mut p: *mut libc::c_void = arg.arg::<*mut libc::c_void>();\n                    result = fcntl(fd, action, p);\n                    current_block_7 = 7175849428784450219;\n                }\n            }\n            match current_block_7 {\n                4046302689674688614 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                8871774344836507656 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                12013198723313890981 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6453289516101043606 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                5351856672558463576 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                13722137258147953758 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                9332010126091029806 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                12766345184754617216 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                17966572639739034653 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6940526744265269810 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                15280576717888187136 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                7022052692272556539 => {\n                    result = fcntl(fd, action);\n                }\n                14034191772621753005 => {\n                    let mut x: libc::c_int = arg.arg::<libc::c_int>();\n                    result = fcntl(fd, action, x);\n                }\n                _ => {}\n            }\n        }\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fcntl.rs:4:1: 4:22 (#0)",
        "source": "use std::ffi::VaList;"
      },
      {
        "span": "src/fcntl.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:936 ~ rust[fc84]::src::version_etc::version_etc_ar)",
    "span": "src/version_etc.rs:252:1: 266:2 (#0)",
    "pieces": [
      "src/version_etc.rs:252:1: 266:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:2:1: 2:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1014 ~ rust[fc84]::src::xmalloc::xinmalloc)",
    "span": "src/xmalloc.rs:216:1: 220:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:216:1: 220:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:22:1: 22:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:22:25: 22:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:22:34: 22:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/xmalloc.rs:22:18: 22:23 (#0)",
        "source": "alloc"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:218 ~ rust[fc84]::src::fpurge::fpurge)",
    "span": "src/fpurge.rs:47:1: 50:2 (#0)",
    "pieces": [
      "src/fpurge.rs:47:1: 50:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fpurge.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:66 ~ rust[fc84]::src::close_stream::close_stream)",
    "span": "src/close_stream.rs:51:1: 65:2 (#0)",
    "pieces": [
      "src/close_stream.rs:51:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/close_stream.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:100 ~ cat[4a5d]::emit_ancillary_info)",
    "span": "src/cat.rs:249:1: 302:2 (#0)",
    "pieces": [
      "src/cat.rs:249:1: 302:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 115,
    "source": "unsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:132 ~ cat[4a5d]::usage)",
        "span": "src/cat.rs:525:9: 525:36 (#0)",
        "source": "emit_ancillary_info(\"cat\");"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:103 ~ cat[4a5d]::write_error)",
    "span": "src/cat.rs:305:1: 348:2 (#0)",
    "pieces": [
      "src/cat.rs:305:1: 348:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "unsafe extern \"C\" fn write_error() {\n    let mut saved_errno: libc::c_int = *__errno_location();\n    fflush_unlocked(stdout);\n    fpurge(stdout);\n    clearerr_unlocked(stdout);\n    if 0 != 0 {\n        error(\n            1 as libc::c_int,\n            saved_errno,\n            gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n        );\n        if 1 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:134 ~ cat[4a5d]::simple_cat)",
        "span": "src/cat.rs:578:17: 578:31 (#0)",
        "source": "write_error();"
      },
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:630:25: 630:39 (#0)",
        "source": "write_error();"
      },
      {
        "caller": "DefId(0:135 ~ cat[4a5d]::write_pending)",
        "span": "src/cat.rs:594:13: 594:27 (#0)",
        "source": "write_error();"
      },
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:2021:13: 2021:27 (#0)",
        "source": "write_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:104 ~ cat[4a5d]::alignfree)",
    "span": "src/cat.rs:351:1: 354:2 (#0)",
    "pieces": [
      "src/cat.rs:351:1: 354:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn alignfree(mut ptr: *mut libc::c_void) {\n    free(ptr);\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1946:1: 1946:23 (#0)",
        "source": "alignfree(outbuf_box);"
      },
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1949:1: 1949:22 (#0)",
        "source": "alignfree(inbuf_box);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:122 ~ cat[4a5d]::next_line_num)",
    "span": "src/cat.rs:529:1: 554:2 (#0)",
    "pieces": [
      "src/cat.rs:529:1: 554:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 26,
    "source": "unsafe extern \"C\" fn next_line_num() {\n    let mut endp: *mut libc::c_char = line_num_end;\n    loop {\n        let fresh0 = *endp;\n        *endp = *endp + 1;\n        if (fresh0 as libc::c_int) < '9' as i32 {\n            return;\n        }\n        let fresh1 = endp;\n        endp = endp.offset(-1);\n        *fresh1 = '0' as i32 as libc::c_char;\n        if !(endp >= line_num_start) {\n            break;\n        }\n    }\n    if line_num_start > line_buf.as_mut_ptr() {\n        line_num_start = line_num_start.offset(-1);\n        *line_num_start = '1' as i32 as libc::c_char;\n    } else {\n        *line_buf.as_mut_ptr() = '>' as i32 as libc::c_char;\n    }\n    if line_num_start < line_num_print {\n        line_num_print = line_num_print.offset(-1);\n        line_num_print;\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:809:33: 809:49 (#0)",
        "source": "next_line_num();"
      },
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:861:13: 861:29 (#0)",
        "source": "next_line_num();"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:454:1: 455:26 (#0)",
        "source": "static mut line_num_print: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:456:1: 457:26 (#0)",
        "source": "static mut line_num_start: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:458:1: 459:26 (#0)",
        "source": "static mut line_num_end: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:432:1: 453:3 (#0)",
        "source": "static mut line_buf: [libc::c_char; 20] = [\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    '0' as i32 as libc::c_char,\n    '\\t' as i32 as libc::c_char,\n    '\\0' as i32 as libc::c_char,\n];"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:124 ~ cat[4a5d]::write_pending)",
    "span": "src/cat.rs:585:1: 598:2 (#0)",
    "pieces": [
      "src/cat.rs:585:1: 598:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "unsafe extern \"C\" fn write_pending(\n    mut outbuf: *mut libc::c_char,\n    mut bpout: *mut *mut libc::c_char,\n) {\n    let mut n_write: idx_t = (*bpout).offset_from(outbuf) as libc::c_long;\n    if (0 as libc::c_int as libc::c_long) < n_write {\n        if full_write(1 as libc::c_int, outbuf as *const libc::c_void, n_write as size_t)\n            != n_write as libc::c_ulong\n        {\n            write_error();\n        }\n        *bpout = outbuf;\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:776:21: 776:55 (#0)",
        "source": "write_pending(outbuf, &mut bpout);"
      },
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:781:21: 781:55 (#0)",
        "source": "write_pending(outbuf, &mut bpout);"
      },
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:718:21: 718:55 (#0)",
        "source": "write_pending(outbuf, &mut bpout);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:125 ~ cat[4a5d]::cat)",
    "span": "src/cat.rs:599:1: 969:2 (#0)",
    "pieces": [
      "src/cat.rs:599:1: 969:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 371,
    "source": "unsafe extern \"C\" fn cat(\n    mut inbuf: *mut libc::c_char,\n    mut insize: idx_t,\n    mut outbuf: *mut libc::c_char,\n    mut outsize: idx_t,\n    mut show_nonprinting: bool,\n    mut show_tabs: bool,\n    mut number: bool,\n    mut number_nonblank: bool,\n    mut show_ends: bool,\n    mut squeeze_blank: bool,\n) -> bool {\n    let mut ch: libc::c_uchar = 0;\n    let mut newlines: libc::c_int = newlines2;\n    let mut use_fionread: bool = 1 as libc::c_int != 0;\n    let mut eob: *mut libc::c_char = inbuf;\n    let mut bpin: *mut libc::c_char = eob.offset(1 as libc::c_int as isize);\n    let mut bpout: *mut libc::c_char = outbuf;\n    loop {\n        let mut current_block_52: u64;\n        loop {\n            if outbuf.offset(outsize as isize) <= bpout {\n                let mut wp: *mut libc::c_char = outbuf;\n                let mut remaining_bytes: idx_t = 0;\n                loop {\n                    if full_write(\n                        1 as libc::c_int,\n                        wp as *const libc::c_void,\n                        outsize as size_t,\n                    ) != outsize as libc::c_ulong\n                    {\n                        write_error();\n                    }\n                    wp = wp.offset(outsize as isize);\n                    remaining_bytes = bpout.offset_from(wp) as libc::c_long;\n                    if !(outsize <= remaining_bytes) {\n                        break;\n                    }\n                }\n                memmove(\n                    outbuf as *mut libc::c_void,\n                    wp as *const libc::c_void,\n                    remaining_bytes as libc::c_ulong,\n                );\n                bpout = outbuf.offset(remaining_bytes as isize);\n            }\n            if bpin > eob {\n                let mut input_pending: bool = 0 as libc::c_int != 0;\n                let mut n_to_read: libc::c_int = 0 as libc::c_int;\n                if use_fionread as libc::c_int != 0\n                    && ioctl(\n                        input_desc,\n                        0x541b as libc::c_int as libc::c_ulong,\n                        &mut n_to_read as *mut libc::c_int,\n                    ) < 0 as libc::c_int\n                {\n                    if *__errno_location() == 95 as libc::c_int\n                        || *__errno_location() == 25 as libc::c_int\n                        || *__errno_location() == 22 as libc::c_int\n                        || *__errno_location() == 19 as libc::c_int\n                        || *__errno_location() == 38 as libc::c_int\n                    {\n                        use_fionread = 0 as libc::c_int != 0;\n                    } else {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot do ioctl on %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, infile),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    gettext(\n                                        b\"cannot do ioctl on %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_style(shell_escape_always_quoting_style, infile),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    gettext(\n                                        b\"cannot do ioctl on %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_style(shell_escape_always_quoting_style, infile),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        newlines2 = newlines;\n                        return 0 as libc::c_int != 0;\n                    }\n                }\n                if n_to_read != 0 as libc::c_int {\n                    input_pending = 1 as libc::c_int != 0;\n                }\n                if !input_pending {\n                    write_pending(outbuf, &mut bpout);\n                }\n                let mut n_read: size_t = safe_read(\n                    input_desc,\n                    inbuf as *mut libc::c_void,\n                    insize as size_t,\n                );\n                if n_read == -(1 as libc::c_int) as size_t {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    write_pending(outbuf, &mut bpout);\n                    newlines2 = newlines;\n                    return 0 as libc::c_int != 0;\n                }\n                if n_read == 0 as libc::c_int as libc::c_ulong {\n                    write_pending(outbuf, &mut bpout);\n                    newlines2 = newlines;\n                    return 1 as libc::c_int != 0;\n                }\n                bpin = inbuf;\n                eob = bpin.offset(n_read as isize);\n                *eob = '\\n' as i32 as libc::c_char;\n                current_block_52 = 6476622998065200121;\n            } else {\n                newlines += 1;\n                if newlines > 0 as libc::c_int {\n                    if newlines >= 2 as libc::c_int {\n                        newlines = 2 as libc::c_int;\n                        if squeeze_blank {\n                            let fresh2 = bpin;\n                            bpin = bpin.offset(1);\n                            ch = *fresh2 as libc::c_uchar;\n                            current_block_52 = 16658872821858055392;\n                        } else {\n                            current_block_52 = 15597372965620363352;\n                        }\n                    } else {\n                        current_block_52 = 15597372965620363352;\n                    }\n                    match current_block_52 {\n                        16658872821858055392 => {}\n                        _ => {\n                            if number as libc::c_int != 0 && !number_nonblank {\n                                next_line_num();\n                                bpout = stpcpy(bpout, line_num_print);\n                            }\n                            current_block_52 = 17784502470059252271;\n                        }\n                    }\n                } else {\n                    current_block_52 = 17784502470059252271;\n                }\n                match current_block_52 {\n                    16658872821858055392 => {}\n                    _ => {\n                        if show_ends {\n                            if pending_cr {\n                                let fresh3 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh3 = '^' as i32 as libc::c_char;\n                                let fresh4 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh4 = 'M' as i32 as libc::c_char;\n                                pending_cr = 0 as libc::c_int != 0;\n                            }\n                            let fresh5 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh5 = '$' as i32 as libc::c_char;\n                        }\n                        let fresh6 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh6 = '\\n' as i32 as libc::c_char;\n                        current_block_52 = 6476622998065200121;\n                    }\n                }\n            }\n            match current_block_52 {\n                6476622998065200121 => {\n                    let fresh7 = bpin;\n                    bpin = bpin.offset(1);\n                    ch = *fresh7 as libc::c_uchar;\n                }\n                _ => {}\n            }\n            if !(ch as libc::c_int == '\\n' as i32) {\n                break;\n            }\n        }\n        if pending_cr {\n            let fresh8 = bpout;\n            bpout = bpout.offset(1);\n            *fresh8 = '\\r' as i32 as libc::c_char;\n            pending_cr = 0 as libc::c_int != 0;\n        }\n        if newlines >= 0 as libc::c_int && number as libc::c_int != 0 {\n            next_line_num();\n            bpout = stpcpy(bpout, line_num_print);\n        }\n        if show_nonprinting {\n            loop {\n                if ch as libc::c_int >= 32 as libc::c_int {\n                    if (ch as libc::c_int) < 127 as libc::c_int {\n                        let fresh9 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh9 = ch as libc::c_char;\n                    } else if ch as libc::c_int == 127 as libc::c_int {\n                        let fresh10 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh10 = '^' as i32 as libc::c_char;\n                        let fresh11 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh11 = '?' as i32 as libc::c_char;\n                    } else {\n                        let fresh12 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh12 = 'M' as i32 as libc::c_char;\n                        let fresh13 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh13 = '-' as i32 as libc::c_char;\n                        if ch as libc::c_int >= 128 as libc::c_int + 32 as libc::c_int {\n                            if (ch as libc::c_int)\n                                < 128 as libc::c_int + 127 as libc::c_int\n                            {\n                                let fresh14 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh14 = (ch as libc::c_int - 128 as libc::c_int)\n                                    as libc::c_char;\n                            } else {\n                                let fresh15 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh15 = '^' as i32 as libc::c_char;\n                                let fresh16 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh16 = '?' as i32 as libc::c_char;\n                            }\n                        } else {\n                            let fresh17 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh17 = '^' as i32 as libc::c_char;\n                            let fresh18 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh18 = (ch as libc::c_int - 128 as libc::c_int\n                                + 64 as libc::c_int) as libc::c_char;\n                        }\n                    }\n                } else if ch as libc::c_int == '\\t' as i32 && !show_tabs {\n                    let fresh19 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh19 = '\\t' as i32 as libc::c_char;\n                } else if ch as libc::c_int == '\\n' as i32 {\n                    newlines = -(1 as libc::c_int);\n                    break;\n                } else {\n                    let fresh20 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh20 = '^' as i32 as libc::c_char;\n                    let fresh21 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh21 = (ch as libc::c_int + 64 as libc::c_int) as libc::c_char;\n                }\n                let fresh22 = bpin;\n                bpin = bpin.offset(1);\n                ch = *fresh22 as libc::c_uchar;\n            }\n        } else {\n            loop {\n                if ch as libc::c_int == '\\t' as i32 && show_tabs as libc::c_int != 0 {\n                    let fresh23 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh23 = '^' as i32 as libc::c_char;\n                    let fresh24 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh24 = (ch as libc::c_int + 64 as libc::c_int) as libc::c_char;\n                } else if ch as libc::c_int != '\\n' as i32 {\n                    if ch as libc::c_int == '\\r' as i32\n                        && *bpin as libc::c_int == '\\n' as i32\n                        && show_ends as libc::c_int != 0\n                    {\n                        if bpin == eob {\n                            pending_cr = 1 as libc::c_int != 0;\n                        } else {\n                            let fresh25 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh25 = '^' as i32 as libc::c_char;\n                            let fresh26 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh26 = 'M' as i32 as libc::c_char;\n                        }\n                    } else {\n                        let fresh27 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh27 = ch as libc::c_char;\n                    }\n                } else {\n                    newlines = -(1 as libc::c_int);\n                    break;\n                }\n                let fresh28 = bpin;\n                bpin = bpin.offset(1);\n                ch = *fresh28 as libc::c_uchar;\n            }\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1932:33: 1944:60 (#0)",
        "source": "ok = (ok as libc::c_int\n                                    & cat(\n                                        inbuf,\n                                        insize,\n                                        outbuf,\n                                        outsize,\n                                        show_nonprinting,\n                                        show_tabs,\n                                        number,\n                                        number_nonblank,\n                                        show_ends,\n                                        squeeze_blank,\n                                    ) as libc::c_int) != 0;"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:461:1: 461:53 (#0)",
        "source": "static mut pending_cr: bool = 0 as libc::c_int != 0;"
      },
      {
        "span": "src/cat.rs:454:1: 455:26 (#0)",
        "source": "static mut line_num_print: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:460:1: 460:54 (#0)",
        "source": "static mut newlines2: libc::c_int = 0 as libc::c_int;"
      },
      {
        "span": "src/cat.rs:431:1: 431:40 (#0)",
        "source": "static mut input_desc: libc::c_int = 0;"
      },
      {
        "span": "src/cat.rs:222:1: 222:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/cat.rs:430:1: 430:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/cat.rs:221:1: 221:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:123 ~ cat[4a5d]::simple_cat)",
    "span": "src/cat.rs:556:1: 582:2 (#0)",
    "pieces": [
      "src/cat.rs:556:1: 582:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "unsafe extern \"C\" fn simple_cat(mut buf: *mut libc::c_char, mut bufsize: idx_t) -> bool {\n    loop {\n        let mut n_read: size_t = safe_read(\n            input_desc,\n            buf as *mut libc::c_void,\n            bufsize as size_t,\n        );\n        if n_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if n_read == 0 as libc::c_int as libc::c_ulong {\n            return 1 as libc::c_int != 0;\n        }\n        if full_write(1 as libc::c_int, buf as *const libc::c_void, n_read) != n_read {\n            write_error();\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1571:37: 1571:166 (#0)",
        "source": "let ok = (ok as libc::c_int & simple_cat(std::slice::from_raw_parts_mut(inbuf as *mut u8, insize as usize)) as libc::c_int) != 0;"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:222:1: 222:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/cat.rs:430:1: 430:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/cat.rs:431:1: 431:40 (#0)",
        "source": "static mut input_desc: libc::c_int = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:126 ~ cat[4a5d]::copy_cat)",
    "span": "src/cat.rs:970:1: 1056:2 (#0)",
    "pieces": [
      "src/cat.rs:970:1: 1056:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 87,
    "source": "unsafe extern \"C\" fn copy_cat() -> libc::c_int {\n    let mut copy_max: ssize_t = (((if (9223372036854775807 as libc::c_long\n        as libc::c_ulong) < 18446744073709551615 as libc::c_ulong\n    {\n        9223372036854775807 as libc::c_long as libc::c_ulong\n    } else {\n        18446744073709551615 as libc::c_ulong\n    }) >> 30 as libc::c_int) << 30 as libc::c_int) as ssize_t;\n    let mut some_copied: bool = 0 as libc::c_int != 0;\n    loop {\n        match rpl_copy_file_range(\n            input_desc,\n            0 as *mut off_t,\n            1 as libc::c_int,\n            0 as *mut off_t,\n            copy_max as size_t,\n            0 as libc::c_int as libc::c_uint,\n        ) {\n            0 => return some_copied as libc::c_int,\n            -1 => {\n                if *__errno_location() == 38 as libc::c_int\n                    || is_ENOTSUP(*__errno_location()) as libc::c_int != 0\n                    || *__errno_location() == 22 as libc::c_int\n                    || *__errno_location() == 9 as libc::c_int\n                    || *__errno_location() == 18 as libc::c_int\n                    || *__errno_location() == 26 as libc::c_int\n                    || *__errno_location() == 1 as libc::c_int\n                {\n                    return 0 as libc::c_int;\n                }\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return -(1 as libc::c_int);\n            }\n            _ => {}\n        }\n        some_copied = 1 as libc::c_int != 0;\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1559:33: 1561:34 (#0)",
        "source": "{\n                                    copy_cat()\n                                }"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:431:1: 431:40 (#0)",
        "source": "static mut input_desc: libc::c_int = 0;"
      },
      {
        "span": "src/cat.rs:222:1: 222:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/cat.rs:430:1: 430:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:110 ~ cat[4a5d]::xset_binary_mode_error)",
    "span": "src/cat.rs:414:1: 419:2 (#0)",
    "pieces": [
      "src/cat.rs:414:1: 419:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "unsafe extern \"C\" fn xset_binary_mode_error() {}",
    "calls": [
      {
        "caller": "DefId(0:122 ~ cat[4a5d]::xset_binary_mode)",
        "span": "src/cat.rs:425:13: 425:38 (#0)",
        "source": "xset_binary_mode_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:111 ~ cat[4a5d]::xset_binary_mode)",
    "span": "src/cat.rs:422:1: 428:2 (#0)",
    "pieces": [
      "src/cat.rs:422:1: 428:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1331:1: 1331:30 (#0)",
        "source": "xset_binary_mode(fd1, mode1);"
      },
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1311:1: 1311:30 (#0)",
        "source": "xset_binary_mode(fd2, mode2);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:105 ~ cat[4a5d]::__gl_stdbit_clzll)",
    "span": "src/cat.rs:357:1: 363:2 (#0)",
    "pieces": [
      "src/cat.rs:357:1: 363:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:106 ~ cat[4a5d]::stdc_leading_zeros_ull)",
    "span": "src/cat.rs:366:1: 368:2 (#0)",
    "pieces": [
      "src/cat.rs:366:1: 368:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn stdc_leading_zeros_ull(mut n: libc::c_ulonglong) -> libc::c_uint {\n    return __gl_stdbit_clzll(n) as libc::c_uint;\n}",
    "calls": [
      {
        "caller": "DefId(0:118 ~ cat[4a5d]::io_blksize)",
        "span": "src/cat.rs:381:9: 381:86 (#0)",
        "source": "let leading_zeros = stdc_leading_zeros_ull(adjusted_blocksize as u64) as i32;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:107 ~ cat[4a5d]::io_blksize)",
    "span": "src/cat.rs:371:1: 401:2 (#0)",
    "pieces": [
      "src/cat.rs:371:1: 401:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "unsafe extern \"C\" fn io_blksize(mut st: *const stat) -> idx_t {\n    let mut blocksize: idx_t = (if (if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) <= 0 as libc::c_int\n    {\n        IO_BUFSIZE as libc::c_int\n    } else if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) as idx_t;\n    blocksize\n        += (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long\n            - (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long % blocksize;\n    if (*st).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        && blocksize & blocksize - 1 as libc::c_int as libc::c_long != 0\n    {\n        let mut leading_zeros: libc::c_int = stdc_leading_zeros_ull(\n            blocksize as libc::c_ulonglong,\n        ) as libc::c_int;\n        if (9223372036854775807 as libc::c_long as libc::c_ulonglong)\n            < (9223372036854775807 as libc::c_longlong as libc::c_ulonglong)\n                .wrapping_mul(2 as libc::c_ulonglong)\n                .wrapping_add(1 as libc::c_ulonglong) || leading_zeros != 0\n        {\n            let mut power: libc::c_ulonglong = (1 as libc::c_ulonglong)\n                << 64 as libc::c_int - leading_zeros;\n            if power <= 9223372036854775807 as libc::c_long as libc::c_ulonglong {\n                blocksize = power as idx_t;\n            }\n        }\n    }\n    return (if (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n        < 18446744073709551615 as libc::c_ulong\n    {\n        9223372036854775807 as libc::c_long as libc::c_ulong\n    } else {\n        18446744073709551615 as libc::c_ulong\n    })\n        .wrapping_div(2 as libc::c_int as libc::c_ulong)\n        .wrapping_add(1 as libc::c_int as libc::c_ulong) < blocksize as libc::c_ulong\n    {\n        (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        })\n            .wrapping_div(2 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    } else {\n        blocksize as libc::c_ulong\n    }) as idx_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1448:21: 1448:67 (#0)",
        "source": "let mut insize: idx_t = io_blksize(&stat_buf);"
      },
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1299:5: 1299:52 (#0)",
        "source": "let mut outsize: idx_t = io_blksize(&stat_buf);"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:227:1: 227:48 (#0)",
        "source": "pub const IO_BUFSIZE: C2RustUnnamed_0 = 262144;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:99 ~ cat[4a5d]::emit_stdin_note)",
    "span": "src/cat.rs:241:1: 246:2 (#0)",
    "pieces": [
      "src/cat.rs:241:1: 246:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_stdin_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nWith no FILE, or when FILE is -, read standard input.\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:132 ~ cat[4a5d]::usage)",
        "span": "src/cat.rs:488:9: 488:27 (#0)",
        "source": "emit_stdin_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:121 ~ cat[4a5d]::usage)",
    "span": "src/cat.rs:463:1: 528:2 (#0)",
    "pieces": [
      "src/cat.rs:463:1: 528:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 66,
    "source": "pub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [FILE]...\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Concatenate FILE(s) to standard output.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_stdin_note();\n        fputs_unlocked(\n            gettext(\n                b\"\\n  -A, --show-all           equivalent to -vET\\n  -b, --number-nonblank    number nonempty output lines, overrides -n\\n  -e                       equivalent to -vE\\n  -E, --show-ends          display $ at end of each line\\n  -n, --number             number all output lines\\n  -s, --squeeze-blank      suppress repeated empty output lines\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -t                       equivalent to -vT\\n  -T, --show-tabs          display TAB characters as ^I\\n  -u                       (ignored)\\n  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        printf(\n            gettext(\n                b\"\\nExamples:\\n  %s f - g  Output f's contents, then standard input, then g's contents.\\n  %s        Copy standard input to standard output.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            program_name,\n            program_name,\n        );\n        emit_ancillary_info(b\"cat\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1258:17: 1258:41 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1237:17: 1237:41 (#0)",
        "source": "usage(0 as libc::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:127 ~ cat[4a5d]::main_0)",
    "span": "src/cat.rs:1057:1: 2067:2 (#0)",
    "pieces": [
      "src/cat.rs:1057:1: 2067:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1006,
    "source": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut insize: idx_t = 0;\n    let mut inbuf: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut current_block: u64;\n    let mut have_read_stdin: bool = 0 as libc::c_int != 0;\n    let mut stat_buf: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut number: bool = 0 as libc::c_int != 0;\n    let mut number_nonblank: bool = 0 as libc::c_int != 0;\n    let mut squeeze_blank: bool = 0 as libc::c_int != 0;\n    let mut show_ends: bool = 0 as libc::c_int != 0;\n    let mut show_nonprinting: bool = 0 as libc::c_int != 0;\n    let mut show_tabs: bool = 0 as libc::c_int != 0;\n    let mut file_open_mode: libc::c_int = 0 as libc::c_int;\n    static mut long_options: [option; 10] = [\n        {\n            let mut init = option {\n                name: b\"number-nonblank\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'b' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"number\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'n' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"squeeze-blank\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 's' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-nonprinting\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'v' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-ends\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'E' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-tabs\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'T' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-all\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'A' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"help\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: GETOPT_HELP_CHAR as libc::c_int,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"version\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: GETOPT_VERSION_CHAR as libc::c_int,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: 0 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 0 as libc::c_int,\n            };\n            init\n        },\n    ];\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    let mut c: libc::c_int = 0;\n    loop {\n        c = getopt_long(\n            argc,\n            argv,\n            b\"benstuvAET\\0\" as *const u8 as *const libc::c_char,\n            long_options.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        match c {\n            98 => {\n                number = 1 as libc::c_int != 0;\n                number_nonblank = 1 as libc::c_int != 0;\n            }\n            101 => {\n                show_ends = 1 as libc::c_int != 0;\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            110 => {\n                number = 1 as libc::c_int != 0;\n            }\n            115 => {\n                squeeze_blank = 1 as libc::c_int != 0;\n            }\n            116 => {\n                show_tabs = 1 as libc::c_int != 0;\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            117 => {}\n            118 => {\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            65 => {\n                show_nonprinting = 1 as libc::c_int != 0;\n                show_ends = 1 as libc::c_int != 0;\n                show_tabs = 1 as libc::c_int != 0;\n            }\n            69 => {\n                show_ends = 1 as libc::c_int != 0;\n            }\n            84 => {\n                show_tabs = 1 as libc::c_int != 0;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"cat\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Torbjorn Granlund\\0\" as *const u8 as *const libc::c_char,\n                        b\"Torbj\\xC3\\xB6rn Granlund\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                usage(1 as libc::c_int);\n            }\n        }\n    }\n    if fstat(1 as libc::c_int, &mut stat_buf) < 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    let mut outsize: idx_t = io_blksize(&mut stat_buf);\n    let mut out_dev: dev_t = stat_buf.st_dev;\n    let mut out_ino: ino_t = stat_buf.st_ino;\n    let mut out_flags: libc::c_int = -(2 as libc::c_int);\n    let mut out_isreg: bool = (stat_buf.st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint) as libc::c_int != 0 as libc::c_int;\n    if !(number as libc::c_int != 0 || show_ends as libc::c_int != 0\n        || squeeze_blank as libc::c_int != 0)\n    {\n        file_open_mode |= 0 as libc::c_int;\n        xset_binary_mode(1 as libc::c_int, 0 as libc::c_int);\n    }\n    infile = b\"-\\0\" as *const u8 as *const libc::c_char;\n    let mut argind: libc::c_int = optind;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut page_size: idx_t = getpagesize() as idx_t;\n    loop {\n        if argind < argc {\n            infile = *argv.offset(argind as isize);\n        }\n        let mut reading_stdin: bool = strcmp(\n            infile,\n            b\"-\\0\" as *const u8 as *const libc::c_char,\n        ) == 0 as libc::c_int;\n        if reading_stdin {\n            have_read_stdin = 1 as libc::c_int != 0;\n            input_desc = 0 as libc::c_int;\n            if file_open_mode & 0 as libc::c_int != 0 {\n                xset_binary_mode(0 as libc::c_int, 0 as libc::c_int);\n            }\n            current_block = 13321564401369230990;\n        } else {\n            input_desc = open(infile, file_open_mode);\n            if input_desc < 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                ok = 0 as libc::c_int != 0;\n                current_block = 4567019141635105728;\n            } else {\n                current_block = 13321564401369230990;\n            }\n        }\n        match current_block {\n            13321564401369230990 => {\n                if fstat(input_desc, &mut stat_buf) < 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                } else {\n                    insize = io_blksize(&mut stat_buf);\n                    fdadvise(\n                        input_desc,\n                        0 as libc::c_int as off_t,\n                        0 as libc::c_int as off_t,\n                        FADVISE_SEQUENTIAL,\n                    );\n                    if stat_buf.st_dev == out_dev && stat_buf.st_ino == out_ino {\n                        if out_flags < -(1 as libc::c_int) {\n                            out_flags = rpl_fcntl(1 as libc::c_int, 3 as libc::c_int);\n                        }\n                        let mut exhausting: bool = 0 as libc::c_int <= out_flags\n                            && out_flags & 0o2000 as libc::c_int != 0;\n                        if !exhausting {\n                            let mut in_pos: off_t = lseek(\n                                input_desc,\n                                0 as libc::c_int as __off_t,\n                                1 as libc::c_int,\n                            );\n                            if 0 as libc::c_int as libc::c_long <= in_pos {\n                                exhausting = in_pos\n                                    < lseek(\n                                        1 as libc::c_int,\n                                        0 as libc::c_int as __off_t,\n                                        1 as libc::c_int,\n                                    );\n                            }\n                        }\n                        if exhausting {\n                            if 0 != 0 {\n                                error(\n                                    0 as libc::c_int,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"%s: input file is output file\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        infile,\n                                    ),\n                                );\n                                if 0 as libc::c_int != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                            } else {\n                                ({\n                                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                                    error(\n                                        __errstatus,\n                                        0 as libc::c_int,\n                                        gettext(\n                                            b\"%s: input file is output file\\0\" as *const u8\n                                                as *const libc::c_char,\n                                        ),\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            infile,\n                                        ),\n                                    );\n                                    if __errstatus != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                    \n                                });\n                                ({\n                                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                                    error(\n                                        __errstatus,\n                                        0 as libc::c_int,\n                                        gettext(\n                                            b\"%s: input file is output file\\0\" as *const u8\n                                                as *const libc::c_char,\n                                        ),\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            infile,\n                                        ),\n                                    );\n                                    if __errstatus != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                    \n                                });\n                            };\n                            ok = 0 as libc::c_int != 0;\n                            current_block = 7239751344758050955;\n                        } else {\n                            current_block = 5372832139739605200;\n                        }\n                    } else {\n                        current_block = 5372832139739605200;\n                    }\n                    match current_block {\n                        7239751344758050955 => {}\n                        _ => {\n                            inbuf = 0 as *mut libc::c_char;\n                            if !(number as libc::c_int != 0\n                                || show_ends as libc::c_int != 0\n                                || show_nonprinting as libc::c_int != 0\n                                || show_tabs as libc::c_int != 0\n                                || squeeze_blank as libc::c_int != 0)\n                            {\n                                let mut copy_cat_status: libc::c_int = if out_isreg\n                                    as libc::c_int != 0\n                                    && stat_buf.st_mode\n                                        & 0o170000 as libc::c_int as libc::c_uint\n                                        == 0o100000 as libc::c_int as libc::c_uint\n                                {\n                                    copy_cat()\n                                } else {\n                                    0 as libc::c_int\n                                };\n                                if copy_cat_status != 0 as libc::c_int {\n                                    inbuf = 0 as *mut libc::c_char;\n                                    ok = (ok as libc::c_int\n                                        & ((0 as libc::c_int) < copy_cat_status) as libc::c_int) != 0;\n                                } else {\n                                    insize = if insize > outsize { insize } else { outsize };\n                                    inbuf = xalignalloc(page_size, insize) as *mut libc::c_char;\n                                    ok = (ok as libc::c_int\n                                        & simple_cat(inbuf, insize) as libc::c_int) != 0;\n                                }\n                            } else {\n                                inbuf = xalignalloc(\n                                    page_size,\n                                    insize + 1 as libc::c_int as libc::c_long,\n                                ) as *mut libc::c_char;\n                                let mut bufsize: idx_t = 0;\n                                if (if (0 as libc::c_int as idx_t)\n                                    < -(1 as libc::c_int) as idx_t\n                                    && ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        insize\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    && ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        4 as libc::c_int\n                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                    && (if (4 as libc::c_int) < 0 as libc::c_int {\n                                        if insize < 0 as libc::c_int as libc::c_long {\n                                            if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    -(1 as libc::c_int) as idx_t\n                                                }) + 4 as libc::c_int as libc::c_long\n                                            }) - 1 as libc::c_int as libc::c_long)\n                                                < 0 as libc::c_int as libc::c_long\n                                            {\n                                                (insize\n                                                    < -(1 as libc::c_int) as idx_t\n                                                        / 4 as libc::c_int as libc::c_long) as libc::c_int\n                                            } else {\n                                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    4 as libc::c_int\n                                                }) - 1 as libc::c_int) < 0 as libc::c_int\n                                                {\n                                                    !(((((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) + 1 as libc::c_int)\n                                                        << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                        - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) + 0 as libc::c_int\n                                                }) < 0 as libc::c_int\n                                                {\n                                                    ((4 as libc::c_int)\n                                                        < -(if ((if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int\n                                                        } else {\n                                                            4 as libc::c_int\n                                                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                                                        {\n                                                            ((((if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) + 1 as libc::c_int)\n                                                                << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                                - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) - 1 as libc::c_int\n                                                        })) as libc::c_int\n                                                } else {\n                                                    ((0 as libc::c_int) < 4 as libc::c_int) as libc::c_int\n                                                }) != 0\n                                                {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + -(1 as libc::c_int) as idx_t\n                                                        >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                                } else {\n                                                    -(1 as libc::c_int) as idx_t\n                                                        / -(4 as libc::c_int) as libc::c_long\n                                                }) <= -(1 as libc::c_int) as libc::c_long - insize)\n                                                    as libc::c_int\n                                            }\n                                        } else {\n                                            if (if (if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    4 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long)\n                                                < 0 as libc::c_int as libc::c_long\n                                            {\n                                                !(((((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                }) + 1 as libc::c_int as libc::c_long)\n                                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                    - 1 as libc::c_int as libc::c_long)\n                                                    * 2 as libc::c_int as libc::c_long\n                                                    + 1 as libc::c_int as libc::c_long)\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                }) + 0 as libc::c_int as libc::c_long\n                                            }) < 0 as libc::c_int as libc::c_long\n                                            {\n                                                (((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    4 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                                    < -(if ((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int\n                                                        } else {\n                                                            4 as libc::c_int\n                                                        }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                    }) - 1 as libc::c_int as libc::c_long)\n                                                        < 0 as libc::c_int as libc::c_long\n                                                    {\n                                                        ((((if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                        }) + 1 as libc::c_int as libc::c_long)\n                                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                            - 1 as libc::c_int as libc::c_long)\n                                                            * 2 as libc::c_int as libc::c_long\n                                                            + 1 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                        }) - 1 as libc::c_int as libc::c_long\n                                                    })) as libc::c_int\n                                            } else {\n                                                ((0 as libc::c_int as libc::c_long)\n                                                    < (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                                    as libc::c_int\n                                            }) != 0 && 4 as libc::c_int == -(1 as libc::c_int)\n                                            {\n                                                if ((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    insize\n                                                }) - 1 as libc::c_int as libc::c_long)\n                                                    < 0 as libc::c_int as libc::c_long\n                                                {\n                                                    ((0 as libc::c_int as libc::c_long)\n                                                        < insize + 0 as libc::c_int as idx_t) as libc::c_int\n                                                } else {\n                                                    ((0 as libc::c_int as libc::c_long) < insize\n                                                        && (-(1 as libc::c_int) as libc::c_long\n                                                            - 0 as libc::c_int as idx_t)\n                                                            < insize - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                                }\n                                            } else {\n                                                ((0 as libc::c_int as idx_t\n                                                    / 4 as libc::c_int as libc::c_long) < insize) as libc::c_int\n                                            }\n                                        }\n                                    } else {\n                                        if 4 as libc::c_int == 0 as libc::c_int {\n                                            0 as libc::c_int\n                                        } else {\n                                            if insize < 0 as libc::c_int as libc::c_long {\n                                                if (if (if ((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        insize\n                                                    }) + 0 as libc::c_int as idx_t\n                                                }) - 1 as libc::c_int as libc::c_long)\n                                                    < 0 as libc::c_int as libc::c_long\n                                                {\n                                                    !(((((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t\n                                                    }) + 1 as libc::c_int as libc::c_long)\n                                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                        - 1 as libc::c_int as libc::c_long)\n                                                        * 2 as libc::c_int as libc::c_long\n                                                        + 1 as libc::c_int as libc::c_long)\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t\n                                                    }) + 0 as libc::c_int as libc::c_long\n                                                }) < 0 as libc::c_int as libc::c_long\n                                                {\n                                                    (((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        insize\n                                                    }) + 0 as libc::c_int as idx_t)\n                                                        < -(if ((if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                insize\n                                                            }) + 0 as libc::c_int as idx_t\n                                                        }) - 1 as libc::c_int as libc::c_long)\n                                                            < 0 as libc::c_int as libc::c_long\n                                                        {\n                                                            ((((if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                (if 1 as libc::c_int != 0 {\n                                                                    0 as libc::c_int as libc::c_long\n                                                                } else {\n                                                                    insize\n                                                                }) + 0 as libc::c_int as idx_t\n                                                            }) + 1 as libc::c_int as libc::c_long)\n                                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                                - 1 as libc::c_int as libc::c_long)\n                                                                * 2 as libc::c_int as libc::c_long\n                                                                + 1 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                (if 1 as libc::c_int != 0 {\n                                                                    0 as libc::c_int as libc::c_long\n                                                                } else {\n                                                                    insize\n                                                                }) + 0 as libc::c_int as idx_t\n                                                            }) - 1 as libc::c_int as libc::c_long\n                                                        })) as libc::c_int\n                                                } else {\n                                                    ((0 as libc::c_int as libc::c_long)\n                                                        < (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                                }) != 0 && insize == -(1 as libc::c_int) as libc::c_long\n                                                {\n                                                    if ((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                                    {\n                                                        ((0 as libc::c_int as libc::c_long)\n                                                            < 4 as libc::c_int as libc::c_long\n                                                                + 0 as libc::c_int as idx_t) as libc::c_int\n                                                    } else {\n                                                        ((-(1 as libc::c_int) as libc::c_long\n                                                            - 0 as libc::c_int as idx_t)\n                                                            < (4 as libc::c_int - 1 as libc::c_int) as libc::c_long)\n                                                            as libc::c_int\n                                                    }\n                                                } else {\n                                                    (0 as libc::c_int as idx_t / insize\n                                                        < 4 as libc::c_int as libc::c_long) as libc::c_int\n                                                }\n                                            } else {\n                                                ((-(1 as libc::c_int) as idx_t\n                                                    / 4 as libc::c_int as libc::c_long) < insize) as libc::c_int\n                                            }\n                                        }\n                                    }) != 0\n                                {\n                                    let (fresh33, _fresh34) = insize\n                                        .overflowing_mul((4 as libc::c_int).into());\n                                    *(&mut bufsize as *mut idx_t) = fresh33;\n                                    1 as libc::c_int\n                                } else {\n                                    let (fresh35, fresh36) = insize\n                                        .overflowing_mul((4 as libc::c_int).into());\n                                    *(&mut bufsize as *mut idx_t) = fresh35;\n                                    fresh36 as libc::c_int\n                                }) != 0\n                                    || {\n                                        let (fresh37, fresh38) = bufsize.overflowing_add(outsize);\n                                        *(&mut bufsize as *mut idx_t) = fresh37;\n                                        fresh38 as libc::c_int != 0\n                                    }\n                                    || {\n                                        let (fresh39, fresh40) = bufsize\n                                            .overflowing_add((20 as libc::c_int - 1 as libc::c_int).into());\n                                        *(&mut bufsize as *mut idx_t) = fresh39;\n                                        fresh40 as libc::c_int != 0\n                                    }\n                                {\n                                    xalloc_die();\n                                }\n                                let mut outbuf: *mut libc::c_char = xalignalloc(\n                                    page_size,\n                                    bufsize,\n                                ) as *mut libc::c_char;\n                                ok = (ok as libc::c_int\n                                    & cat(\n                                        inbuf,\n                                        insize,\n                                        outbuf,\n                                        outsize,\n                                        show_nonprinting,\n                                        show_tabs,\n                                        number,\n                                        number_nonblank,\n                                        show_ends,\n                                        squeeze_blank,\n                                    ) as libc::c_int) != 0;\n                                alignfree(outbuf as *mut libc::c_void);\n                            }\n                            alignfree(inbuf as *mut libc::c_void);\n                        }\n                    }\n                }\n                if !reading_stdin && close(input_desc) < 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                }\n            }\n            _ => {}\n        }\n        argind += 1;\n        if !(argind < argc) {\n            break;\n        }\n    }\n    if pending_cr {\n        if full_write(\n            1 as libc::c_int,\n            b\"\\r\\0\" as *const u8 as *const libc::c_char as *const libc::c_void,\n            1 as libc::c_int as size_t,\n        ) != 1 as libc::c_int as libc::c_ulong\n        {\n            write_error();\n        }\n    }\n    if have_read_stdin as libc::c_int != 0 && close(0 as libc::c_int) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"closing standard input\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"closing standard input\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"closing standard input\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    return if ok as libc::c_int != 0 { 0 as libc::c_int } else { 1 as libc::c_int };\n}",
    "calls": [
      {
        "caller": "DefId(0:142 ~ cat[4a5d]::main)",
        "span": "src/cat.rs:2078:5: 2085:6 (#0)",
        "source": "unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:430:1: 430:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/cat.rs:431:1: 431:40 (#0)",
        "source": "static mut input_desc: libc::c_int = 0;"
      },
      {
        "span": "src/cat.rs:222:1: 222:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/cat.rs:233:1: 233:45 (#0)",
        "source": "pub const FADVISE_SEQUENTIAL: fadvice_t = 2;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:131 ~ cat[4a5d]::main)",
    "span": "src/cat.rs:2068:1: 2086:2 (#0)",
    "pieces": [
      "src/cat.rs:2068:1: 2086:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:132 ~ cat[4a5d]::run_static_initializers)",
    "span": "src/cat.rs:2087:1: 2100:2 (#0)",
    "pieces": [
      "src/cat.rs:2087:1: 2100:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "unsafe extern \"C\" fn run_static_initializers() {\n    line_num_print = line_buf\n        .as_mut_ptr()\n        .offset(20 as libc::c_int as isize)\n        .offset(-(8 as libc::c_int as isize));\n    line_num_start = line_buf\n        .as_mut_ptr()\n        .offset(20 as libc::c_int as isize)\n        .offset(-(3 as libc::c_int as isize));\n    line_num_end = line_buf\n        .as_mut_ptr()\n        .offset(20 as libc::c_int as isize)\n        .offset(-(3 as libc::c_int as isize));\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/cat.rs:454:1: 455:26 (#0)",
        "source": "static mut line_num_print: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:458:1: 459:26 (#0)",
        "source": "static mut line_num_end: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:432:1: 453:3 (#0)",
        "source": "static mut line_buf: [libc::c_char; 20] = [\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    '0' as i32 as libc::c_char,\n    '\\t' as i32 as libc::c_char,\n    '\\0' as i32 as libc::c_char,\n];"
      },
      {
        "span": "src/cat.rs:456:1: 457:26 (#0)",
        "source": "static mut line_num_start: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:98 ~ cat[4a5d]::is_ENOTSUP)",
    "span": "src/cat.rs:236:1: 238:2 (#0)",
    "pieces": [
      "src/cat.rs:236:1: 238:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn is_ENOTSUP(mut err: libc::c_int) -> bool {\n    return err == 95 as libc::c_int\n        || 95 as libc::c_int != 95 as libc::c_int && err == 95 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:108 ~ cat[4a5d]::__gl_setmode)",
    "span": "src/cat.rs:404:1: 406:2 (#0)",
    "pieces": [
      "src/cat.rs:404:1: 406:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:120 ~ cat[4a5d]::set_binary_mode)",
        "span": "src/cat.rs:409:47: 411:2 (#0)",
        "source": "{\n    __gl_setmode(fd, mode)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:109 ~ cat[4a5d]::set_binary_mode)",
    "span": "src/cat.rs:409:1: 411:2 (#0)",
    "pieces": [
      "src/cat.rs:409:1: 411:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:14:1: 14:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/cat.rs:16:1: 16:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/cat.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:17:1: 17:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  }
]