[
  {
    "func_defid": "DefId(0:798 ~ rust[fc84]::src::quotearg::gettext_quote)",
    "span": "src/quotearg.rs:297:1: 330:2 (#0)",
    "pieces": [
      "src/quotearg.rs:297:1: 330:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "unsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:898 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:379:21: 379:73 (#0)",
        "source": "let right_quote = gettext_quote(\"'\", quoting_style);"
      },
      {
        "caller": "DefId(0:898 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:378:21: 378:72 (#0)",
        "source": "let left_quote = gettext_quote(\"`\", quoting_style);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:799 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
    "span": "src/quotearg.rs:332:1: 1180:2 (#0)",
    "pieces": [
      "src/quotearg.rs:332:1: 343:4 (#0)",
      "src/quotearg.rs:1180:1: 1180:2 (#0)"
    ],
    "sub_chunks": [
      11
    ],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n   <<chunk 11>>}",
    "calls": [
      {
        "caller": "DefId(0:912 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1349:5: 1359:7 (#0)",
        "source": "let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:898 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1121:5: 1131:7 (#0)",
        "source": "return quotearg_buffer_restyled(\n        buffer,\n        orig_buffersize,\n        arg,\n        argsize,\n        c_quoting_style,\n        flags,\n        quote_these_too,\n        left_quote,\n        right_quote,\n    );"
      },
      {
        "caller": "DefId(0:902 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1252:5: 1262:7 (#0)",
        "source": "quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:899 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
        "span": "src/quotearg.rs:1190:13: 1202:6 (#0)",
        "source": "unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffer.len().try_into().unwrap(),\n            arg.as_ptr(),\n            arg.len().try_into().unwrap(),\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    }"
      },
      {
        "caller": "DefId(0:902 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1239:5: 1250:58 (#0)",
        "source": "let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:912 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1369:9: 1379:11 (#0)",
        "source": "quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );"
      },
      {
        "caller": "DefId(0:898 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1150:13: 1160:15 (#0)",
        "source": "return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:89:1: 89:46 (#0)",
        "source": "pub const c_quoting_style: quoting_style = 5;"
      },
      {
        "span": "src/quotearg.rs:92:1: 92:57 (#0)",
        "source": "pub const shell_always_quoting_style: quoting_style = 2;"
      },
      {
        "span": "src/quotearg.rs:90:1: 90:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/quotearg.rs:97:1: 97:52 (#0)",
        "source": "pub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/quotearg.rs:500:9: 556:2 (#0)",
        "pieces": [
          "src/quotearg.rs:500:9: 556:2 (#0)"
        ],
        "num_lines": 64,
        "source": "if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut escaping: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut escaping: bool"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/quotearg.rs:561:9: 691:22 (#0)",
        "pieces": [
          "src/quotearg.rs:561:9: 691:22 (#0)"
        ],
        "num_lines": 131,
        "source": "match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut elide_outer_quotes: bool",
          "mut c: u8"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut elide_outer_quotes: bool",
          "mut c: u8"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/quotearg.rs:723:9: 734:2 (#0)",
        "pieces": [
          "src/quotearg.rs:723:9: 734:2 (#0)"
        ],
        "num_lines": 17,
        "source": "esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut esc: u8"
        ],
        "live_out": [
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut esc: u8"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/quotearg.rs:739:9: 749:22 (#0)",
        "pieces": [
          "src/quotearg.rs:739:9: 749:22 (#0)"
        ],
        "num_lines": 11,
        "source": "if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut current_block: u64"
        ],
        "live_out": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/quotearg.rs:771:9: 808:2 (#0)",
        "pieces": [
          "src/quotearg.rs:771:9: 808:2 (#0)"
        ],
        "num_lines": 33,
        "source": "encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/quotearg.rs:822:9: 891:58 (#0)",
        "pieces": [
          "src/quotearg.rs:822:9: 891:58 (#0)"
        ],
        "num_lines": 70,
        "source": "let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;",
        "sub_chunks": [],
        "live_in": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut i: u64",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut i: u64",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut c_and_shell_quote_compat: bool",
          "mut m: u64",
          "mut printable: bool"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/quotearg.rs:893:9: 962:2 (#0)",
        "pieces": [
          "src/quotearg.rs:893:9: 962:2 (#0)"
        ],
        "num_lines": 96,
        "source": "if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut m: u64",
          "mut printable: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut m: u64",
          "mut printable: bool"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/quotearg.rs:470:13: 1014:2 (#0)",
        "pieces": [
          "src/quotearg.rs:470:13: 500:8 (#0)",
          "src/quotearg.rs:558:1: 561:8 (#0)",
          "src/quotearg.rs:692:1: 723:8 (#0)",
          "src/quotearg.rs:736:1: 739:8 (#0)",
          "src/quotearg.rs:750:1: 771:8 (#0)",
          "src/quotearg.rs:810:1: 822:8 (#0)",
          "src/quotearg.rs:892:1: 893:8 (#0)",
          "src/quotearg.rs:964:1: 1014:2 (#0)"
        ],
        "num_lines": 154,
        "source": "let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                   <<chunk 0>>                }\n                63 => {\n                   <<chunk 1>>                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                   <<chunk 2>>                }\n                123 | 125 => {\n                   <<chunk 3>>                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                   <<chunk 4>>                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                   <<chunk 5>>                   <<chunk 6>>                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }",
        "sub_chunks": [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut c: u8",
          "mut esc: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut c_and_shell_quote_compat: bool",
          "arg_slice: &[u8]"
        ]
      },
      {
        "chunk_id": 8,
        "span": "src/quotearg.rs:1016:13: 1102:8 (#0)",
        "pieces": [
          "src/quotearg.rs:1016:13: 1102:8 (#0)"
        ],
        "num_lines": 113,
        "source": "match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut quote_these_too: *const u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut all_c_and_shell_quote_compat: bool",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut quote_these_too: *const u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut all_c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 9,
        "span": "src/quotearg.rs:358:9: 1119:10 (#0)",
        "pieces": [
          "src/quotearg.rs:358:9: 470:12 (#0)",
          "src/quotearg.rs:1016:1: 1016:12 (#0)",
          "src/quotearg.rs:1104:1: 1119:10 (#0)"
        ],
        "num_lines": 136,
        "source": "pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n           <<chunk 7>>           <<chunk 8>>        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }",
        "sub_chunks": [
          7,
          8
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool",
          "mut current_block_48: u64"
        ]
      },
      {
        "chunk_id": 10,
        "span": "src/quotearg.rs:1120:9: 1139:2 (#0)",
        "pieces": [
          "src/quotearg.rs:1120:9: 1139:2 (#0)"
        ],
        "num_lines": 20,
        "source": "if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut all_c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut all_c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 11,
        "span": "src/quotearg.rs:343:5: 1179:7 (#0)",
        "pieces": [
          "src/quotearg.rs:343:5: 358:8 (#0)",
          "src/quotearg.rs:1120:1: 1120:8 (#0)",
          "src/quotearg.rs:1141:1: 1179:7 (#0)"
        ],
        "num_lines": 56,
        "source": "let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n       <<chunk 9>>       <<chunk 10>>    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };",
        "sub_chunks": [
          9,
          10
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:812 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
    "span": "src/quotearg.rs:1305:1: 1383:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1305:1: 1383:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 79,
    "source": "unsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}",
    "calls": [
      {
        "caller": "DefId(0:921 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1481:5: 1481:77 (#0)",
        "source": "return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);"
      },
      {
        "caller": "DefId(0:933 ~ rust[fc84]::src::quotearg::quote_n_mem)",
        "span": "src/quotearg.rs:1615:5: 1615:76 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);"
      },
      {
        "caller": "DefId(0:914 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
        "span": "src/quotearg.rs:1404:5: 1406:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg_cstring.as_ptr(), argsize, &default_quoting_options)\n    }"
      },
      {
        "caller": "DefId(0:926 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1525:5: 1530:7 (#0)",
        "source": "return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );"
      },
      {
        "caller": "DefId(0:929 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1557:5: 1557:56 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut o);"
      },
      {
        "caller": "DefId(0:917 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1431:5: 1433:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr(), u64::MAX, &o)\n    }"
      },
      {
        "caller": "DefId(0:918 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1443:5: 1445:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr() as *const libc::c_char, arg.len() as size_t, &o)\n    }"
      },
      {
        "caller": "DefId(0:913 ~ rust[fc84]::src::quotearg::quotearg_n)",
        "span": "src/quotearg.rs:1389:5: 1394:7 (#0)",
        "source": "return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1280:1: 1282:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1271:1: 1279:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:98:1: 98:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      },
      {
        "span": "src/quotearg.rs:1270:1: 1270:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:833 ~ rust[fc84]::src::quotearg::quote_n_mem)",
    "span": "src/quotearg.rs:1610:1: 1616:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1610:1: 1616:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:935 ~ rust[fc84]::src::quotearg::quote_n)",
        "span": "src/quotearg.rs:1632:5: 1632:71 (#0)",
        "source": "return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:934 ~ rust[fc84]::src::quotearg::quote_mem)",
        "span": "src/quotearg.rs:1622:22: 1622:95 (#0)",
        "source": "unsafe { quote_n_mem(0, c_string.as_ptr(), argsize.try_into().unwrap()) }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1599:1: 1608:3 (#0)",
        "source": "pub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:835 ~ rust[fc84]::src::quotearg::quote_n)",
    "span": "src/quotearg.rs:1628:1: 1633:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1628:1: 1633:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:936 ~ rust[fc84]::src::quotearg::quote)",
        "span": "src/quotearg.rs:1637:5: 1637:45 (#0)",
        "source": "unsafe { quote_n(0, c_string.as_ptr()) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1005 ~ rust[fc84]::src::xmalloc::check_nonnull)",
    "span": "src/xmalloc.rs:131:1: 136:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:131:1: 136:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:1162 ~ rust[fc84]::src::xmalloc::xmalloc)",
        "span": "src/xmalloc.rs:140:5: 140:37 (#0)",
        "source": "return check_nonnull(malloc(s));"
      },
      {
        "caller": "DefId(0:1163 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:145:1: 145:40 (#0)",
        "source": "return check_nonnull(allocated_memory);"
      },
      {
        "caller": "DefId(0:1168 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:198:5: 198:146 (#0)",
        "source": "let new_ptr = check_nonnull(unsafe { ireallocarray(p.map_or(std::ptr::null_mut(), |slice| slice.as_mut_ptr() as *mut libc::c_void), n, s) });"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1006 ~ rust[fc84]::src::xmalloc::xmalloc)",
    "span": "src/xmalloc.rs:139:1: 141:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:139:1: 141:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}",
    "calls": [
      {
        "caller": "DefId(0:1164 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:151:19: 151:60 (#0)",
        "source": "unsafe { xmalloc(n.try_into().unwrap()) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:796 ~ rust[fc84]::src::quotearg::set_custom_quoting)",
    "span": "src/quotearg.rs:259:1: 278:2 (#0)",
    "pieces": [
      "src/quotearg.rs:259:1: 278:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}",
    "calls": [
      {
        "caller": "DefId(0:929 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1556:5: 1556:127 (#0)",
        "source": "set_custom_quoting(&mut o as *mut quoting_options, left_quote as *const libc::c_char, right_quote as *const libc::c_char);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:84:1: 84:52 (#0)",
        "source": "pub const custom_quoting_style: quoting_style = 10;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:95 ~ rust[fc84]::src::closeout::close_stdout)",
    "span": "src/closeout.rs:83:1: 178:2 (#0)",
    "pieces": [
      "src/closeout.rs:83:1: 178:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:64:1: 64:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1003 ~ rust[fc84]::src::xmalloc::_gl_alloc_nomem)",
    "span": "src/xmalloc.rs:109:1: 114:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:109:1: 114:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:1157 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:71:13: 71:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1160 ~ rust[fc84]::src::xmalloc::imalloc)",
        "span": "src/xmalloc.rs:126:12: 128:6 (#0)",
        "source": "{\n        _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:1156 ~ rust[fc84]::src::xmalloc::irealloc)",
        "span": "src/xmalloc.rs:60:9: 60:34 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1157 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:77:13: 77:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:1158 ~ rust[fc84]::src::xmalloc::ireallocarray)",
        "span": "src/xmalloc.rs:102:12: 104:6 (#0)",
        "source": "{\n        _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:1160 ~ rust[fc84]::src::xmalloc::imalloc)",
        "span": "src/xmalloc.rs:121:26: 123:10 (#0)",
        "source": "{\n            _gl_alloc_nomem()\n        }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1004 ~ rust[fc84]::src::xmalloc::imalloc)",
    "span": "src/xmalloc.rs:117:1: 129:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:117:1: 129:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1163 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:144:5: 144:59 (#0)",
        "source": "let allocated_memory = imalloc(s.try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1007 ~ rust[fc84]::src::xmalloc::ximalloc)",
    "span": "src/xmalloc.rs:143:1: 146:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:143:1: 146:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1024 ~ rust[fc84]::src::xmalloc::ximemdup0)",
    "span": "src/xmalloc.rs:1009:1: 1015:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1009:1: 1015:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:179 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD)",
    "span": "src/fcntl.rs:88:1: 92:2 (#0)",
    "pieces": [
      "src/fcntl.rs:88:1: 92:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn rpl_fcntl_DUPFD(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    result = fcntl(fd, 0 as libc::c_int, target);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:210 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
        "span": "src/fcntl.rs:33:22: 33:60 (#0)",
        "source": "unsafe { rpl_fcntl_DUPFD(fd, target) }"
      },
      {
        "caller": "DefId(0:213 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
        "span": "src/fcntl.rs:111:9: 111:50 (#0)",
        "source": "let result = rpl_fcntl_DUPFD(fd, target);"
      },
      {
        "caller": "DefId(0:213 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
        "span": "src/fcntl.rs:105:13: 105:54 (#0)",
        "source": "let result = rpl_fcntl_DUPFD(fd, target);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fcntl.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fcntl.rs:3:1: 3:22 (#0)",
        "source": "use std::ffi::VaList;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:181 ~ rust[fc84]::src::fcntl::rpl_fcntl_DUPFD_CLOEXEC)",
    "span": "src/fcntl.rs:95:1: 126:2 (#0)",
    "pieces": [
      "src/fcntl.rs:95:1: 126:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 32,
    "source": "unsafe extern \"C\" fn rpl_fcntl_DUPFD_CLOEXEC(\n    mut fd: libc::c_int,\n    mut target: libc::c_int,\n) -> libc::c_int {\n    let mut result: libc::c_int = 0;\n    if 0 as libc::c_int <= have_dupfd_cloexec {\n        result = fcntl(fd, 1030 as libc::c_int, target);\n        if 0 as libc::c_int <= result || *__errno_location() != 22 as libc::c_int {\n            have_dupfd_cloexec = 1 as libc::c_int;\n        } else {\n            result = rpl_fcntl_DUPFD(fd, target);\n            if result >= 0 as libc::c_int {\n                have_dupfd_cloexec = -(1 as libc::c_int);\n            }\n        }\n    } else {\n        result = rpl_fcntl_DUPFD(fd, target);\n    }\n    if 0 as libc::c_int <= result && have_dupfd_cloexec == -(1 as libc::c_int) {\n        let mut flags: libc::c_int = fcntl(result, 1 as libc::c_int);\n        if flags < 0 as libc::c_int\n            || fcntl(result, 2 as libc::c_int, flags | 1 as libc::c_int)\n                == -(1 as libc::c_int)\n        {\n            let mut saved_errno: libc::c_int = *__errno_location();\n            close(result);\n            *__errno_location() = saved_errno;\n            result = -(1 as libc::c_int);\n        }\n    }\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:210 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
        "span": "src/fcntl.rs:37:22: 37:68 (#0)",
        "source": "unsafe { rpl_fcntl_DUPFD_CLOEXEC(fd, target) }"
      }
    ],
    "globals": [
      {
        "span": "src/fcntl.rs:94:1: 94:48 (#0)",
        "source": "static mut have_dupfd_cloexec: libc::c_int = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/fcntl.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fcntl.rs:3:1: 3:22 (#0)",
        "source": "use std::ffi::VaList;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:783 ~ rust[fc84]::src::quotearg::c32isprint)",
    "span": "src/quotearg.rs:144:1: 146:2 (#0)",
    "pieces": [
      "src/quotearg.rs:144:1: 146:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:167 ~ rust[fc84]::src::fclose::rpl_fclose)",
    "span": "src/fclose.rs:54:1: 74:2 (#0)",
    "pieces": [
      "src/fclose.rs:54:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fclose.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fclose.rs:1:1: 1:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:275 ~ rust[fc84]::src::ialloc::_gl_alloc_nomem)",
    "span": "src/ialloc.rs:96:1: 102:2 (#0)",
    "pieces": [
      "src/ialloc.rs:96:1: 102:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:3:24: 3:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/ialloc.rs:3:18: 3:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:800 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
    "span": "src/quotearg.rs:1182:1: 1206:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1182:1: 1206:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:935 ~ rust[fc84]::src::version_etc::version_etc_arn)",
    "span": "src/version_etc.rs:67:1: 249:2 (#0)",
    "pieces": [
      "src/version_etc.rs:67:1: 75:4 (#0)",
      "src/version_etc.rs:107:1: 107:4 (#0)",
      "src/version_etc.rs:249:1: 249:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:1064 ~ rust[fc84]::src::version_etc::version_etc_va)",
        "span": "src/version_etc.rs:286:5: 293:7 (#0)",
        "source": "version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );"
      },
      {
        "caller": "DefId(0:1063 ~ rust[fc84]::src::version_etc::version_etc_ar)",
        "span": "src/version_etc.rs:264:5: 264:81 (#0)",
        "source": "version_etc_arn(stream, command_name, package, version, authors, n_authors);"
      }
    ],
    "globals": [
      {
        "span": "src/version_etc.rs:64:1: 64:48 (#0)",
        "source": "pub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;"
      }
    ],
    "imports": [
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:18 (#0)",
        "source": "use std::println;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/version_etc.rs:75:5: 106:73 (#0)",
        "pieces": [
          "src/version_etc.rs:75:5: 106:73 (#0)"
        ],
        "num_lines": 32,
        "source": "if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);",
        "sub_chunks": [],
        "live_in": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut command_name: *const i8",
          "mut package: *const i8",
          "mut version: *const i8"
        ],
        "live_out": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut command_name: *const i8",
          "mut package: *const i8",
          "mut version: *const i8"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/version_etc.rs:107:5: 248:7 (#0)",
        "pieces": [
          "src/version_etc.rs:107:5: 248:7 (#0)"
        ],
        "num_lines": 142,
        "source": "match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };",
        "sub_chunks": [],
        "live_in": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut authors: *const *const i8",
          "mut n_authors: u64"
        ],
        "live_out": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut authors: *const *const i8",
          "mut n_authors: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:937 ~ rust[fc84]::src::version_etc::version_etc_va)",
    "span": "src/version_etc.rs:267:1: 294:2 (#0)",
    "pieces": [
      "src/version_etc.rs:267:1: 294:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "pub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:1067 ~ rust[fc84]::src::version_etc::version_etc)",
        "span": "src/version_etc.rs:305:5: 305:82 (#0)",
        "source": "version_etc_va(stream, command_name, package, version, authors.as_va_list());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:18 (#0)",
        "source": "use std::println;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:146 ~ rust[fc84]::src::fadvise::fdadvise)",
    "span": "src/fadvise.rs:62:1: 71:2 (#0)",
    "pieces": [
      "src/fadvise.rs:62:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn fdadvise(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut len: off_t,\n    mut advice: fadvice_t,\n) {\n    posix_fadvise(fd, offset, len, advice as libc::c_int);\n}",
    "calls": [
      {
        "caller": "DefId(0:173 ~ rust[fc84]::src::fadvise::fadvise)",
        "span": "src/fadvise.rs:79:1: 79:35 (#0)",
        "source": "fdadvise(fd, offset, len, advice);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fadvise.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:960 ~ rust[fc84]::src::xalignalloc::alignalloc)",
    "span": "src/xalignalloc.rs:13:1: 39:2 (#0)",
    "pieces": [
      "src/xalignalloc.rs:13:1: 39:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn alignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {\n        alignment = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {\n        size = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalignalloc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xalignalloc.rs:2:25: 2:31 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xalignalloc.rs:2:18: 2:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xalignalloc.rs:2:1: 2:33 (#0)",
        "source": "use std::alloc::{alloc, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1020 ~ rust[fc84]::src::xmalloc::xcalloc)",
    "span": "src/xmalloc.rs:980:1: 984:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:980:1: 984:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1011 ~ rust[fc84]::src::xmalloc::xreallocarray)",
    "span": "src/xmalloc.rs:182:1: 189:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:182:1: 189:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1170 ~ rust[fc84]::src::xmalloc::xnmalloc)",
        "span": "src/xmalloc.rs:209:1: 209:71 (#0)",
        "source": "xreallocarray(&mut vec, n.try_into().unwrap(), s.try_into().unwrap());"
      },
      {
        "caller": "DefId(0:1173 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
        "span": "src/xmalloc.rs:254:1: 254:71 (#0)",
        "source": "xreallocarray(&mut vec, n.try_into().unwrap(), s.try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1013 ~ rust[fc84]::src::xmalloc::xnmalloc)",
    "span": "src/xmalloc.rs:206:1: 211:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:206:1: 211:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [
      {
        "caller": "DefId(0:1164 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:154:19: 154:87 (#0)",
        "source": "unsafe { xnmalloc(n.try_into().unwrap(), size.try_into().unwrap()) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1008 ~ rust[fc84]::src::xmalloc::xcharalloc)",
    "span": "src/xmalloc.rs:148:1: 157:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:148:1: 157:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:941 ~ rust[fc84]::src::version_etc::emit_bug_reporting_address)",
    "span": "src/version_etc.rs:308:1: 323:2 (#0)",
    "pieces": [
      "src/version_etc.rs:308:1: 323:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:18 (#0)",
        "source": "use std::println;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:971 ~ rust[fc84]::src::xalloc_die::xalloc_die)",
    "span": "src/xalloc_die.rs:16:1: 53:2 (#0)",
    "pieces": [
      "src/xalloc_die.rs:16:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "pub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalloc_die.rs:1:1: 1:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/xalloc_die.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:22 ~ rust[fc84]::src::binary_io::__gl_setmode)",
    "span": "src/binary_io.rs:15:1: 17:2 (#0)",
    "pieces": [
      "src/binary_io.rs:15:1: 17:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:30 ~ rust[fc84]::src::binary_io::set_binary_mode)",
        "span": "src/binary_io.rs:8:51: 10:2 (#0)",
        "source": "{\n    __gl_setmode(fd, mode)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/binary_io.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/binary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:792 ~ rust[fc84]::src::quotearg::get_quoting_style)",
    "span": "src/quotearg.rs:198:1: 204:2 (#0)",
    "pieces": [
      "src/quotearg.rs:198:1: 204:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1016 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
    "span": "src/xmalloc.rs:230:1: 259:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:230:1: 259:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:48:1: 48:47 (#0)",
        "source": "pub const DEFAULT_MXFAST: C2RustUnnamed = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1015 ~ rust[fc84]::src::xmalloc::x2realloc)",
    "span": "src/xmalloc.rs:219:1: 227:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:219:1: 227:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1018 ~ rust[fc84]::src::xmalloc::xzalloc)",
    "span": "src/xmalloc.rs:968:1: 970:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:968:1: 970:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:182 ~ rust[fc84]::src::fcntl::run_static_initializers)",
    "span": "src/fcntl.rs:127:1: 133:2 (#0)",
    "pieces": [
      "src/fcntl.rs:127:1: 133:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn run_static_initializers() {\n    have_dupfd_cloexec = if 0 as libc::c_int != 0 {\n        -(1 as libc::c_int)\n    } else {\n        0 as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/fcntl.rs:94:1: 94:48 (#0)",
        "source": "static mut have_dupfd_cloexec: libc::c_int = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/fcntl.rs:3:1: 3:22 (#0)",
        "source": "use std::ffi::VaList;"
      },
      {
        "span": "src/fcntl.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:41 ~ rust[fc84]::src::c_ctype::c_tolower)",
    "span": "src/c_ctype.rs:138:1: 143:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:138:1: 143:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:802 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
    "span": "src/quotearg.rs:1221:1: 1268:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1221:1: 1268:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}",
    "calls": [
      {
        "caller": "DefId(0:901 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
        "span": "src/quotearg.rs:1216:22: 1216:98 (#0)",
        "source": "unsafe { quotearg_alloc_mem(arg_ptr, argsize_ptr, std::ptr::null_mut(), o) }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:98:1: 98:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      },
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:900 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clzll)",
    "span": "src/stdc_leading_zeros.rs:32:1: 38:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:32:1: 38:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:1029 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ull)",
        "span": "src/stdc_leading_zeros.rs:77:5: 77:40 (#0)",
        "source": "return __gl_stdbit_clzll(n) as u32;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:905 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ull)",
    "span": "src/stdc_leading_zeros.rs:76:1: 78:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:76:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_ull(\n    mut n: libc::c_ulonglong,\n) -> libc::c_uint {\n    return __gl_stdbit_clzll(n) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:834 ~ rust[fc84]::src::quotearg::quote_mem)",
    "span": "src/quotearg.rs:1618:1: 1625:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1618:1: 1625:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:218 ~ rust[fc84]::src::fpurge::fpurge)",
    "span": "src/fpurge.rs:48:1: 53:2 (#0)",
    "pieces": [
      "src/fpurge.rs:48:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fpurge.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:849 ~ rust[fc84]::src::safe_read::safe_read)",
    "span": "src/safe_read.rs:12:1: 34:2 (#0)",
    "pieces": [
      "src/safe_read.rs:12:1: 34:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn safe_read(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = read(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/safe_read.rs:9:1: 9:55 (#0)",
        "source": "pub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;"
      }
    ],
    "imports": [
      {
        "span": "src/safe_read.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:979 ~ rust[fc84]::src::xbinary_io::__gl_setmode)",
    "span": "src/xbinary_io.rs:31:1: 33:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:31:1: 33:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:1119 ~ rust[fc84]::src::xbinary_io::set_binary_mode)",
        "span": "src/xbinary_io.rs:26:47: 28:2 (#0)",
        "source": "{\n    __gl_setmode(fd, mode)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:978 ~ rust[fc84]::src::xbinary_io::set_binary_mode)",
    "span": "src/xbinary_io.rs:26:1: 28:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:26:1: 28:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:899 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clzl)",
    "span": "src/stdc_leading_zeros.rs:23:1: 29:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:23:1: 29:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:797 ~ rust[fc84]::src::quotearg::quoting_options_from_style)",
    "span": "src/quotearg.rs:280:1: 295:2 (#0)",
    "pieces": [
      "src/quotearg.rs:280:1: 295:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}",
    "calls": [
      {
        "caller": "DefId(0:926 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1523:5: 1523:45 (#0)",
        "source": "options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:918 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1442:5: 1442:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:917 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1430:5: 1430:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:94:1: 94:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:818 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
    "span": "src/quotearg.rs:1437:1: 1446:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1437:1: 1446:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:920 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
        "span": "src/quotearg.rs:1464:1: 1464:45 (#0)",
        "source": "return quotearg_n_style_mem(0, s, &arg_str);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:791 ~ rust[fc84]::src::quotearg::clone_quoting_options)",
    "span": "src/quotearg.rs:191:1: 195:2 (#0)",
    "pieces": [
      "src/quotearg.rs:191:1: 195:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:34 ~ rust[fc84]::src::c_ctype::c_isgraph)",
    "span": "src/c_ctype.rs:75:1: 80:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:75:1: 80:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:273 ~ rust[fc84]::src::ialloc::irealloc)",
    "span": "src/ialloc.rs:70:1: 78:2 (#0)",
    "pieces": [
      "src/ialloc.rs:70:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:7:1: 7:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:3:18: 3:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:3:24: 3:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:872 ~ rust[fc84]::src::setlocale_null::setlocale_null)",
    "span": "src/setlocale_null.rs:27:1: 34:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:27:1: 34:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:31 ~ rust[fc84]::src::c_ctype::c_isblank)",
    "span": "src/c_ctype.rs:54:1: 56:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:54:1: 56:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:882 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:18:1: 23:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:18:1: 23:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:989 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
        "span": "src/setlocale_null_unlocked.rs:31:9: 31:52 (#0)",
        "source": "result = setlocale_null_unlocked(category);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:94 ~ rust[fc84]::src::closeout::close_stdout_set_ignore_EPIPE)",
    "span": "src/closeout.rs:76:1: 80:2 (#0)",
    "pieces": [
      "src/closeout.rs:76:1: 80:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:74:1: 74:39 (#0)",
        "source": "static mut ignore_EPIPE: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:110 ~ rust[fc84]::src::copy_file_range::rpl_copy_file_range)",
    "span": "src/copy_file_range.rs:33:1: 80:2 (#0)",
    "pieces": [
      "src/copy_file_range.rs:33:1: 80:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "pub unsafe extern \"C\" fn rpl_copy_file_range(\n    mut infd: libc::c_int,\n    mut pinoff: *mut off_t,\n    mut outfd: libc::c_int,\n    mut poutoff: *mut off_t,\n    mut length: size_t,\n    mut flags: libc::c_uint,\n) -> ssize_t {\n    static mut ok: libc::c_schar = 0;\n    if ok == 0 {\n        let mut name: utsname = utsname {\n            sysname: [0; 65],\n            nodename: [0; 65],\n            release: [0; 65],\n            version: [0; 65],\n            machine: [0; 65],\n            domainname: [0; 65],\n        };\n        uname(&mut name);\n        let mut p: *mut libc::c_char = (name.release).as_mut_ptr();\n        ok = (if *p.offset(1 as libc::c_int as isize) as libc::c_int != '.' as i32\n            || ('5' as i32) < *p.offset(0 as libc::c_int as isize) as libc::c_int\n            || *p.offset(0 as libc::c_int as isize) as libc::c_int == '5' as i32\n                && (*p.offset(3 as libc::c_int as isize) as libc::c_int != '.' as i32\n                    || ('2' as i32)\n                        < *p.offset(2 as libc::c_int as isize) as libc::c_int)\n        {\n            1 as libc::c_int\n        } else {\n            -(1 as libc::c_int)\n        }) as libc::c_schar;\n    }\n    if (0 as libc::c_int) < ok as libc::c_int {\n        return copy_file_range(infd, pinoff, outfd, poutoff, length, flags);\n    }\n    *__errno_location() = 38 as libc::c_int;\n    return -(1 as libc::c_int) as ssize_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/copy_file_range.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/copy_file_range.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:813 ~ rust[fc84]::src::quotearg::quotearg_n)",
    "span": "src/quotearg.rs:1385:1: 1395:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1385:1: 1395:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:915 ~ rust[fc84]::src::quotearg::quotearg)",
        "span": "src/quotearg.rs:1412:9: 1412:54 (#0)",
        "source": "let quoted_ptr = quotearg_n(0, arg.as_ptr());"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:815 ~ rust[fc84]::src::quotearg::quotearg)",
    "span": "src/quotearg.rs:1410:1: 1415:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1410:1: 1415:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:47 ~ rust[fc84]::src::c_strcasecmp::c_tolower)",
    "span": "src/c_strcasecmp.rs:6:1: 11:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:6:1: 11:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:66 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:16:5: 16:86 (#0)",
        "source": "let c2: Vec<_> = s2.chars().map(|c| c_tolower(c as i32) as u8 as char).collect();"
      },
      {
        "caller": "DefId(0:66 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:15:5: 15:86 (#0)",
        "source": "let c1: Vec<_> = s1.chars().map(|c| c_tolower(c as i32) as u8 as char).collect();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:892 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctzl)",
    "span": "src/stdbit.rs:58:1: 64:2 (#0)",
    "pieces": [
      "src/stdbit.rs:58:1: 64:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_ctzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:4:1: 4:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:6:1: 6:14 (#0)",
        "source": "use std::u64;"
      },
      {
        "span": "src/stdbit.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:883 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:25:1: 62:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:25:1: 62:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:30 ~ rust[fc84]::src::c_ctype::c_isascii)",
    "span": "src/c_ctype.rs:36:1: 49:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:36:1: 49:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:48 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
    "span": "src/c_strcasecmp.rs:14:1: 27:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:14:1: 27:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "pub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_strcasecmp.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1009 ~ rust[fc84]::src::xmalloc::xrealloc)",
    "span": "src/xmalloc.rs:160:1: 169:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:160:1: 169:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1174 ~ rust[fc84]::src::xmalloc::xpalloc)",
        "span": "src/xmalloc.rs:963:5: 963:41 (#0)",
        "source": "pa = xrealloc(pa, nbytes as size_t);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1001 ~ rust[fc84]::src::xmalloc::icalloc)",
    "span": "src/xmalloc.rs:65:1: 84:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:65:1: 84:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1021 ~ rust[fc84]::src::xmalloc::xicalloc)",
    "span": "src/xmalloc.rs:987:1: 991:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:987:1: 991:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:724 ~ rust[fc84]::src::propername_lite::proper_name_lite)",
    "span": "src/propername_lite.rs:8:1: 24:2 (#0)",
    "pieces": [
      "src/propername_lite.rs:8:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/propername_lite.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:39 ~ rust[fc84]::src::c_ctype::c_isupper)",
    "span": "src/c_ctype.rs:124:1: 126:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:124:1: 126:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:794 ~ rust[fc84]::src::quotearg::set_char_quoting)",
    "span": "src/quotearg.rs:219:1: 237:2 (#0)",
    "pieces": [
      "src/quotearg.rs:219:1: 237:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 30,
    "source": "pub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:921 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1480:5: 1480:76 (#0)",
        "source": "let result = set_char_quoting(Some(&mut options), ch as u8 as char, 1);"
      },
      {
        "caller": "DefId(0:926 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1524:5: 1524:77 (#0)",
        "source": "let result = set_char_quoting(Some(&mut options), ':' as u8 as char, 1);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:821 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
    "span": "src/quotearg.rs:1467:1: 1482:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1467:1: 1482:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}",
    "calls": [
      {
        "caller": "DefId(0:925 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
        "span": "src/quotearg.rs:1504:22: 1506:6 (#0)",
        "source": "unsafe {\n        quotearg_char_mem(arg.as_ptr(), argsize.try_into().unwrap(), ':' as i32 as c_char)\n    }"
      },
      {
        "caller": "DefId(0:923 ~ rust[fc84]::src::quotearg::quotearg_char)",
        "span": "src/quotearg.rs:1488:5: 1488:78 (#0)",
        "source": "return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:94:1: 94:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:823 ~ rust[fc84]::src::quotearg::quotearg_char)",
    "span": "src/quotearg.rs:1484:1: 1489:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1484:1: 1489:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}",
    "calls": [
      {
        "caller": "DefId(0:924 ~ rust[fc84]::src::quotearg::quotearg_colon)",
        "span": "src/quotearg.rs:1496:9: 1496:59 (#0)",
        "source": "result_ptr = quotearg_char(c_string.as_ptr(), ch);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:178 ~ rust[fc84]::src::fcntl::rpl_fcntl)",
    "span": "src/fcntl.rs:23:1: 86:2 (#0)",
    "pieces": [
      "src/fcntl.rs:23:1: 86:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 136,
    "source": "pub unsafe extern \"C\" fn rpl_fcntl(\n    mut fd: libc::c_int,\n    mut action: libc::c_int,\n    mut args: ...\n) -> libc::c_int {\n    let mut arg: ::core::ffi::VaListImpl;\n    let mut result: libc::c_int = -(1 as libc::c_int);\n    arg = args.clone();\n    match action {\n        0 => {\n            let mut target: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD(fd, target);\n        }\n        1030 => {\n            let mut target_0: libc::c_int = arg.arg::<libc::c_int>();\n            result = rpl_fcntl_DUPFD_CLOEXEC(fd, target_0);\n        }\n        _ => {\n            let mut current_block_7: u64;\n            match action {\n                1 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                3 => {\n                    current_block_7 = 4046302689674688614;\n                }\n                1025 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                9 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                1032 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                1034 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                11 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                1033 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                0 => {\n                    current_block_7 = 8871774344836507656;\n                }\n                1030 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                1026 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                2 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                4 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                8 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1031 => {\n                    current_block_7 = 12013198723313890981;\n                }\n                1024 | 10 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {\n                    let mut p: *mut libc::c_void = arg.arg::<*mut libc::c_void>();\n                    result = fcntl(fd, action, p);\n                    current_block_7 = 7175849428784450219;\n                }\n            }\n            match current_block_7 {\n                4046302689674688614 => {\n                    current_block_7 = 6453289516101043606;\n                }\n                8871774344836507656 => {\n                    current_block_7 = 5351856672558463576;\n                }\n                12013198723313890981 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6453289516101043606 => {\n                    current_block_7 = 13722137258147953758;\n                }\n                5351856672558463576 => {\n                    current_block_7 = 9332010126091029806;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                13722137258147953758 => {\n                    current_block_7 = 12766345184754617216;\n                }\n                9332010126091029806 => {\n                    current_block_7 = 17966572639739034653;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                12766345184754617216 => {\n                    current_block_7 = 6940526744265269810;\n                }\n                17966572639739034653 => {\n                    current_block_7 = 15280576717888187136;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                6940526744265269810 => {\n                    current_block_7 = 7022052692272556539;\n                }\n                15280576717888187136 => {\n                    current_block_7 = 14034191772621753005;\n                }\n                _ => {}\n            }\n            match current_block_7 {\n                7022052692272556539 => {\n                    result = fcntl(fd, action);\n                }\n                14034191772621753005 => {\n                    let mut x: libc::c_int = arg.arg::<libc::c_int>();\n                    result = fcntl(fd, action, x);\n                }\n                _ => {}\n            }\n        }\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fcntl.rs:3:1: 3:22 (#0)",
        "source": "use std::ffi::VaList;"
      },
      {
        "span": "src/fcntl.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:236 ~ rust[fc84]::src::fseeko::rpl_fseeko)",
    "span": "src/fseeko.rs:52:1: 74:2 (#0)",
    "pieces": [
      "src/fseeko.rs:52:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fseeko.rs:1:1: 1:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/fseeko.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:274 ~ rust[fc84]::src::ialloc::imalloc)",
    "span": "src/ialloc.rs:83:1: 90:2 (#0)",
    "pieces": [
      "src/ialloc.rs:83:1: 90:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:3:18: 3:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:3:24: 3:30 (#0)",
        "source": "Layout"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:889 ~ rust[fc84]::src::stdbit::__gl_stdbit_clzl)",
    "span": "src/stdbit.rs:25:1: 31:2 (#0)",
    "pieces": [
      "src/stdbit.rs:25:1: 31:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_clzl(mut n: libc::c_ulong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:6:1: 6:14 (#0)",
        "source": "use std::u64;"
      },
      {
        "span": "src/stdbit.rs:4:1: 4:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdbit.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:898 ~ rust[fc84]::src::stdc_leading_zeros::__gl_stdbit_clz)",
    "span": "src/stdc_leading_zeros.rs:14:1: 20:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:14:1: 20:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:901 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ui)",
    "span": "src/stdc_leading_zeros.rs:43:1: 46:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:43:1: 46:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_ui(mut n: libc::c_uint) -> libc::c_uint {\n    return __gl_stdbit_clz(n) as libc::c_uint;\n}",
    "calls": [
      {
        "caller": "DefId(0:1026 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_uc)",
        "span": "src/stdc_leading_zeros.rs:52:5: 52:57 (#0)",
        "source": "let leading_zeros = stdc_leading_zeros_ui(n as u32);"
      },
      {
        "caller": "DefId(0:1027 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_us)",
        "span": "src/stdc_leading_zeros.rs:61:5: 61:57 (#0)",
        "source": "let leading_zeros = stdc_leading_zeros_ui(n as u32);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:903 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_us)",
    "span": "src/stdc_leading_zeros.rs:60:1: 64:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:60:1: 64:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_us(mut n: libc::c_ushort) -> libc::c_uint {\n    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)\n        .wrapping_sub(\n            (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(\n                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n                        .wrapping_sub(\n                            ::core::mem::size_of::<libc::c_ushort>() as libc::c_ulong,\n                        ),\n                ),\n        ) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1002 ~ rust[fc84]::src::xmalloc::ireallocarray)",
    "span": "src/xmalloc.rs:87:1: 105:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:87:1: 105:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1168 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:198:33: 198:144 (#0)",
        "source": "unsafe { ireallocarray(p.map_or(std::ptr::null_mut(), |slice| slice.as_mut_ptr() as *mut libc::c_void), n, s) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1012 ~ rust[fc84]::src::xmalloc::xireallocarray)",
    "span": "src/xmalloc.rs:192:1: 203:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:192:1: 203:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1014 ~ rust[fc84]::src::xmalloc::xinmalloc)",
    "span": "src/xmalloc.rs:213:1: 216:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:213:1: 216:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:683 ~ rust[fc84]::src::mbrtoc32::mbszero)",
    "span": "src/mbrtoc32.rs:36:1: 42:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:36:1: 42:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:744 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
        "span": "src/mbrtoc32.rs:64:9: 64:21 (#0)",
        "source": "mbszero(ps);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:825 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
    "span": "src/quotearg.rs:1502:1: 1508:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1502:1: 1508:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:862 ~ rust[fc84]::src::safe_write::safe_write)",
    "span": "src/safe_write.rs:12:1: 34:2 (#0)",
    "pieces": [
      "src/safe_write.rs:12:1: 34:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn safe_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = write(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/safe_write.rs:9:1: 9:55 (#0)",
        "source": "pub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;"
      }
    ],
    "imports": [
      {
        "span": "src/safe_write.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:893 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctzll)",
    "span": "src/stdbit.rs:69:1: 75:2 (#0)",
    "pieces": [
      "src/stdbit.rs:69:1: 75:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_ctzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:6:1: 6:14 (#0)",
        "source": "use std::u64;"
      },
      {
        "span": "src/stdbit.rs:4:1: 4:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:936 ~ rust[fc84]::src::version_etc::version_etc_ar)",
    "span": "src/version_etc.rs:251:1: 265:2 (#0)",
    "pieces": [
      "src/version_etc.rs:251:1: 265:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:18 (#0)",
        "source": "use std::println;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:28 ~ rust[fc84]::src::c_ctype::c_isalnum)",
    "span": "src/c_ctype.rs:22:1: 24:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:22:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:890 ~ rust[fc84]::src::stdbit::__gl_stdbit_clzll)",
    "span": "src/stdbit.rs:36:1: 42:2 (#0)",
    "pieces": [
      "src/stdbit.rs:36:1: 42:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:4:1: 4:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdbit.rs:6:1: 6:14 (#0)",
        "source": "use std::u64;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:92 ~ rust[fc84]::src::closeout::close_stdout_set_file_name)",
    "span": "src/closeout.rs:66:1: 72:2 (#0)",
    "pieces": [
      "src/closeout.rs:66:1: 72:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:64:1: 64:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1000 ~ rust[fc84]::src::xmalloc::irealloc)",
    "span": "src/xmalloc.rs:53:1: 62:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:53:1: 62:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1010 ~ rust[fc84]::src::xmalloc::xirealloc)",
    "span": "src/xmalloc.rs:171:1: 179:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:171:1: 179:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:836 ~ rust[fc84]::src::quotearg::quote)",
    "span": "src/quotearg.rs:1635:1: 1638:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1635:1: 1638:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:33 ~ rust[fc84]::src::c_ctype::c_isdigit)",
    "span": "src/c_ctype.rs:68:1: 70:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:68:1: 70:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:817 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
    "span": "src/quotearg.rs:1425:1: 1434:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1425:1: 1434:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:919 ~ rust[fc84]::src::quotearg::quotearg_style)",
        "span": "src/quotearg.rs:1453:5: 1453:50 (#0)",
        "source": "let result_ptr = quotearg_n_style(0, s, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:819 ~ rust[fc84]::src::quotearg::quotearg_style)",
    "span": "src/quotearg.rs:1449:1: 1455:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1449:1: 1455:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1017 ~ rust[fc84]::src::xmalloc::xpalloc)",
    "span": "src/xmalloc.rs:261:1: 966:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:261:1: 268:4 (#0)",
      "src/xmalloc.rs:966:1: 966:2 (#0)"
    ],
    "sub_chunks": [
      7
    ],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n   <<chunk 7>>}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:50:1: 50:51 (#0)",
        "source": "pub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xmalloc.rs:287:17: 366:18 (#0)",
        "pieces": [
          "src/xmalloc.rs:287:17: 366:18 (#0)"
        ],
        "num_lines": 80,
        "source": "if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xmalloc.rs:368:17: 473:18 (#0)",
        "pieces": [
          "src/xmalloc.rs:368:17: 473:18 (#0)"
        ],
        "num_lines": 106,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/xmalloc.rs:476:13: 589:14 (#0)",
        "pieces": [
          "src/xmalloc.rs:476:13: 589:14 (#0)"
        ],
        "num_lines": 114,
        "source": "if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/xmalloc.rs:643:29: 724:30 (#0)",
        "pieces": [
          "src/xmalloc.rs:643:29: 724:30 (#0)"
        ],
        "num_lines": 82,
        "source": "if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/xmalloc.rs:726:29: 832:30 (#0)",
        "pieces": [
          "src/xmalloc.rs:726:29: 832:30 (#0)"
        ],
        "num_lines": 107,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/xmalloc.rs:835:25: 948:26 (#0)",
        "pieces": [
          "src/xmalloc.rs:835:25: 948:26 (#0)"
        ],
        "num_lines": 114,
        "source": "if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/xmalloc.rs:624:13: 958:24 (#0)",
        "pieces": [
          "src/xmalloc.rs:624:13: 643:28 (#0)",
          "src/xmalloc.rs:725:1: 726:28 (#0)",
          "src/xmalloc.rs:833:1: 835:24 (#0)",
          "src/xmalloc.rs:949:1: 958:24 (#0)"
        ],
        "num_lines": 35,
        "source": "let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                           <<chunk 3>>                        } else {\n                           <<chunk 4>>                        }\n                    } else {\n                       <<chunk 5>>                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0",
        "sub_chunks": [
          3,
          4,
          5
        ],
        "live_in": [
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64",
          "mut n0: i64",
          "mut n: i64",
          "mut nbytes: i64"
        ],
        "live_out": [
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64",
          "mut n0: i64",
          "mut n: i64",
          "mut nbytes: i64",
          "fresh12: i64",
          "fresh13: bool"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/xmalloc.rs:268:5: 965:15 (#0)",
        "pieces": [
          "src/xmalloc.rs:268:5: 287:16 (#0)",
          "src/xmalloc.rs:367:1: 368:16 (#0)",
          "src/xmalloc.rs:474:1: 476:12 (#0)",
          "src/xmalloc.rs:590:1: 624:12 (#0)",
          "src/xmalloc.rs:959:1: 965:15 (#0)"
        ],
        "num_lines": 67,
        "source": "let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n               <<chunk 0>>            } else {\n               <<chunk 1>>            }\n        } else {\n           <<chunk 2>>        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n           <<chunk 6>>        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;",
        "sub_chunks": [
          0,
          1,
          2,
          6
        ],
        "live_in": [
          "mut pa: *mut libc::c_void",
          "mut pn: *mut i64",
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64"
        ],
        "live_out": [
          "mut pa: *mut libc::c_void",
          "mut pn: *mut i64",
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:814 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
    "span": "src/quotearg.rs:1397:1: 1407:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1397:1: 1407:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:916 ~ rust[fc84]::src::quotearg::quotearg_mem)",
        "span": "src/quotearg.rs:1420:5: 1420:59 (#0)",
        "source": "let result = quotearg_n_mem(0, arg.to_str().unwrap());"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:888 ~ rust[fc84]::src::stdbit::__gl_stdbit_clz)",
    "span": "src/stdbit.rs:14:1: 20:2 (#0)",
    "pieces": [
      "src/stdbit.rs:14:1: 20:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_clz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:6:1: 6:14 (#0)",
        "source": "use std::u64;"
      },
      {
        "span": "src/stdbit.rs:4:1: 4:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:667 ~ rust[fc84]::src::localcharset::locale_charset)",
    "span": "src/localcharset.rs:393:1: 402:2 (#0)",
    "pieces": [
      "src/localcharset.rs:393:1: 402:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/localcharset.rs:7:1: 7:39 (#0)",
        "source": "pub const CODESET: C2RustUnnamed = 14;"
      }
    ],
    "imports": [
      {
        "span": "src/localcharset.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/localcharset.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:715 ~ rust[fc84]::src::progname::set_program_name)",
    "span": "src/progname.rs:62:1: 90:2 (#0)",
    "pieces": [
      "src/progname.rs:62:1: 90:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "pub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/progname.rs:60:1: 60:77 (#0)",
        "source": "pub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/progname.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/progname.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/progname.rs:2:1: 2:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:202 ~ rust[fc84]::src::fflush::clear_ungetc_buffer_preserving_position)",
    "span": "src/fflush.rs:50:1: 56:2 (#0)",
    "pieces": [
      "src/fflush.rs:50:1: 56:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:235 ~ rust[fc84]::src::fflush::rpl_fflush)",
        "span": "src/fflush.rs:63:5: 63:58 (#0)",
        "source": "clear_ungetc_buffer_preserving_position(&mut stream);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:203 ~ rust[fc84]::src::fflush::rpl_fflush)",
    "span": "src/fflush.rs:59:1: 65:2 (#0)",
    "pieces": [
      "src/fflush.rs:59:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:66 ~ rust[fc84]::src::close_stream::close_stream)",
    "span": "src/close_stream.rs:51:1: 65:2 (#0)",
    "pieces": [
      "src/close_stream.rs:51:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/close_stream.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:961 ~ rust[fc84]::src::xalignalloc::xalignalloc)",
    "span": "src/xalignalloc.rs:42:1: 51:2 (#0)",
    "pieces": [
      "src/xalignalloc.rs:42:1: 51:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xalignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    let mut p: *mut libc::c_void = alignalloc(alignment, size);\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalignalloc.rs:2:18: 2:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xalignalloc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xalignalloc.rs:2:25: 2:31 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xalignalloc.rs:2:1: 2:33 (#0)",
        "source": "use std::alloc::{alloc, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1022 ~ rust[fc84]::src::xmalloc::xmemdup)",
    "span": "src/xmalloc.rs:994:1: 998:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:994:1: 998:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:21 ~ rust[fc84]::src::binary_io::set_binary_mode)",
    "span": "src/binary_io.rs:8:1: 10:2 (#0)",
    "pieces": [
      "src/binary_io.rs:8:1: 10:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/binary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/binary_io.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1023 ~ rust[fc84]::src::xmalloc::ximemdup)",
    "span": "src/xmalloc.rs:1001:1: 1006:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1001:1: 1006:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:810 ~ rust[fc84]::src::quotearg::quotearg_free)",
    "span": "src/quotearg.rs:1284:1: 1303:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1284:1: 1303:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:1270:1: 1270:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:1269:1: 1269:50 (#0)",
        "source": "static mut slot0: [libc::c_char; 256] = [0; 256];"
      },
      {
        "span": "src/quotearg.rs:1280:1: 1282:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1271:1: 1279:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:38 ~ rust[fc84]::src::c_ctype::c_isspace)",
    "span": "src/c_ctype.rs:117:1: 119:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:117:1: 119:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:693 ~ rust[fc84]::src::mbszero::mbszero)",
    "span": "src/mbszero.rs:27:1: 32:2 (#0)",
    "pieces": [
      "src/mbszero.rs:27:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mbszero.rs:1:1: 1:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/mbszero.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:829 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
    "span": "src/quotearg.rs:1548:1: 1558:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1548:1: 1558:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}",
    "calls": [
      {
        "caller": "DefId(0:928 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
        "span": "src/quotearg.rs:1539:5: 1545:7 (#0)",
        "source": "return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );"
      },
      {
        "caller": "DefId(0:931 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
        "span": "src/quotearg.rs:1587:9: 1593:11 (#0)",
        "source": "let result_ptr = quotearg_n_custom_mem(\n            0,\n            left_quote.as_ptr(),\n            right_quote.as_ptr(),\n            arg.as_ptr(),\n            argsize,\n        );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:831 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
    "span": "src/quotearg.rs:1580:1: 1596:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1580:1: 1596:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:36 ~ rust[fc84]::src::c_ctype::c_isprint)",
    "span": "src/c_ctype.rs:92:1: 103:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:92:1: 103:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:32 ~ rust[fc84]::src::c_ctype::c_iscntrl)",
    "span": "src/c_ctype.rs:61:1: 63:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:61:1: 63:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:784 ~ rust[fc84]::src::quotearg::mbszero)",
    "span": "src/quotearg.rs:149:1: 155:2 (#0)",
    "pieces": [
      "src/quotearg.rs:149:1: 155:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:40 ~ rust[fc84]::src::c_ctype::c_isxdigit)",
    "span": "src/c_ctype.rs:131:1: 133:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:131:1: 133:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:977 ~ rust[fc84]::src::xbinary_io::xset_binary_mode_error)",
    "span": "src/xbinary_io.rs:19:1: 23:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:19:1: 23:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "pub unsafe extern \"C\" fn xset_binary_mode_error() {}",
    "calls": [
      {
        "caller": "DefId(0:1116 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)",
        "span": "src/xbinary_io.rs:12:9: 12:34 (#0)",
        "source": "xset_binary_mode_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:976 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)",
    "span": "src/xbinary_io.rs:10:1: 14:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:10:1: 14:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:816 ~ rust[fc84]::src::quotearg::quotearg_mem)",
    "span": "src/quotearg.rs:1418:1: 1422:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1418:1: 1422:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:940 ~ rust[fc84]::src::version_etc::version_etc)",
    "span": "src/version_etc.rs:296:1: 306:2 (#0)",
    "pieces": [
      "src/version_etc.rs:296:1: 306:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:18 (#0)",
        "source": "use std::println;"
      },
      {
        "span": "src/version_etc.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:801 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
    "span": "src/quotearg.rs:1209:1: 1218:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1209:1: 1218:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:685 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
    "span": "src/mbrtoc32.rs:48:1: 78:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:48:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 31,
    "source": "pub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/mbrtoc32.rs:43:1: 46:3 (#0)",
        "source": "static mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};"
      }
    ],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:15 ~ rust[fc84]::src::alignalloc::alignalloc)",
    "span": "src/alignalloc.rs:16:1: 36:2 (#0)",
    "pieces": [
      "src/alignalloc.rs:16:1: 36:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn alignalloc(\n    mut alignment: idx_t,\n    mut size: idx_t,\n) -> *mut libc::c_void {\n    if (-(1 as libc::c_int) as size_t) < alignment as libc::c_ulong {\n        alignment = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    if (-(1 as libc::c_int) as size_t) < size as libc::c_ulong {\n        size = -(1 as libc::c_int) as size_t as idx_t;\n    }\n    return aligned_alloc(alignment as libc::c_ulong, size as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/alignalloc.rs:3:1: 3:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/alignalloc.rs:1:1: 1:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/alignalloc.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:42 ~ rust[fc84]::src::c_ctype::c_toupper)",
    "span": "src/c_ctype.rs:148:1: 153:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:148:1: 153:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:272 ~ rust[fc84]::src::ialloc::icalloc)",
    "span": "src/ialloc.rs:50:1: 65:2 (#0)",
    "pieces": [
      "src/ialloc.rs:50:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:7:1: 7:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:3:18: 3:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/ialloc.rs:5:1: 5:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/ialloc.rs:3:24: 3:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:29 ~ rust[fc84]::src::c_ctype::c_isalpha)",
    "span": "src/c_ctype.rs:29:1: 31:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:29:1: 31:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:826 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
    "span": "src/quotearg.rs:1511:1: 1531:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1511:1: 1531:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:94:1: 94:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:16 ~ rust[fc84]::src::alignalloc::alignfree)",
    "span": "src/alignalloc.rs:41:1: 43:2 (#0)",
    "pieces": [
      "src/alignalloc.rs:41:1: 43:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn alignfree(mut ptr: *mut libc::c_void) {\n    free(ptr);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/alignalloc.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/alignalloc.rs:1:1: 1:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/alignalloc.rs:3:1: 3:16 (#0)",
        "source": "use std::alloc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:824 ~ rust[fc84]::src::quotearg::quotearg_colon)",
    "span": "src/quotearg.rs:1491:1: 1499:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1491:1: 1499:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:891 ~ rust[fc84]::src::stdbit::__gl_stdbit_ctz)",
    "span": "src/stdbit.rs:47:1: 53:2 (#0)",
    "pieces": [
      "src/stdbit.rs:47:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn __gl_stdbit_ctz(mut n: libc::c_uint) -> libc::c_int {\n    return (if n != 0 {\n        n.trailing_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdbit.rs:10:1: 10:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdbit.rs:4:1: 4:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdbit.rs:6:1: 6:14 (#0)",
        "source": "use std::u64;"
      },
      {
        "span": "src/stdbit.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:904 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_ul)",
    "span": "src/stdc_leading_zeros.rs:69:1: 71:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:69:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_ul(mut n: libc::c_ulong) -> libc::c_uint {\n    return __gl_stdbit_clzl(n) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:37 ~ rust[fc84]::src::c_ctype::c_ispunct)",
    "span": "src/c_ctype.rs:108:1: 112:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:108:1: 112:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:828 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
    "span": "src/quotearg.rs:1533:1: 1546:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1533:1: 1546:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:930 ~ rust[fc84]::src::quotearg::quotearg_custom)",
        "span": "src/quotearg.rs:1571:9: 1571:106 (#0)",
        "source": "result_ptr = quotearg_n_custom(0, left_quote_c.as_ptr(), right_quote_c.as_ptr(), arg_c.as_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:271 ~ rust[fc84]::src::ialloc::ireallocarray)",
    "span": "src/ialloc.rs:27:1: 45:2 (#0)",
    "pieces": [
      "src/ialloc.rs:27:1: 45:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:5:1: 5:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:3:1: 3:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:3:24: 3:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/ialloc.rs:3:18: 3:22 (#0)",
        "source": "self"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:871 ~ rust[fc84]::src::setlocale_null::setlocale_null_r)",
    "span": "src/setlocale_null.rs:15:1: 24:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:15:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/setlocale_null.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1019 ~ rust[fc84]::src::xmalloc::xizalloc)",
    "span": "src/xmalloc.rs:973:1: 977:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:973:1: 977:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:820 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
    "span": "src/quotearg.rs:1458:1: 1465:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1458:1: 1465:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:795 ~ rust[fc84]::src::quotearg::set_quoting_flags)",
    "span": "src/quotearg.rs:240:1: 256:2 (#0)",
    "pieces": [
      "src/quotearg.rs:240:1: 256:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:35 ~ rust[fc84]::src::c_ctype::c_islower)",
    "span": "src/c_ctype.rs:85:1: 87:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:85:1: 87:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:902 ~ rust[fc84]::src::stdc_leading_zeros::stdc_leading_zeros_uc)",
    "span": "src/stdc_leading_zeros.rs:51:1: 55:2 (#0)",
    "pieces": [
      "src/stdc_leading_zeros.rs:51:1: 55:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn stdc_leading_zeros_uc(mut n: libc::c_uchar) -> libc::c_uint {\n    return (stdc_leading_zeros_ui(n as libc::c_uint) as libc::c_ulong)\n        .wrapping_sub(\n            (8 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(\n                    (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)\n                        .wrapping_sub(\n                            ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong,\n                        ),\n                ),\n        ) as libc::c_uint;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/stdc_leading_zeros.rs:6:1: 6:14 (#0)",
        "source": "use std::u32;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:8:1: 8:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/stdc_leading_zeros.rs:10:1: 10:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:147 ~ rust[fc84]::src::fadvise::fadvise)",
    "span": "src/fadvise.rs:74:1: 81:2 (#0)",
    "pieces": [
      "src/fadvise.rs:74:1: 81:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn fadvise(mut fp: *mut FILE, mut advice: fadvice_t) {\n    if !fp.is_null() {\n        fdadvise(\n            fileno(fp),\n            0 as libc::c_int as off_t,\n            0 as libc::c_int as off_t,\n            advice,\n        );\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fadvise.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:245 ~ rust[fc84]::src::full_write::full_write)",
    "span": "src/full_write.rs:10:1: 36:2 (#0)",
    "pieces": [
      "src/full_write.rs:10:1: 36:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn full_write(\n    mut fd: libc::c_int,\n    mut buf: *const libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    let mut total: size_t = 0 as libc::c_int as size_t;\n    let mut ptr: *const libc::c_char = buf as *const libc::c_char;\n    while count > 0 as libc::c_int as libc::c_ulong {\n        let mut n_rw: size_t = safe_write(fd, ptr as *const libc::c_void, count);\n        if n_rw == -(1 as libc::c_int) as size_t {\n            break;\n        }\n        if n_rw == 0 as libc::c_int as libc::c_ulong {\n            *__errno_location() = 28 as libc::c_int;\n            break;\n        } else {\n            total = (total as libc::c_ulong).wrapping_add(n_rw) as size_t as size_t;\n            ptr = ptr.offset(n_rw as isize);\n            count = (count as libc::c_ulong).wrapping_sub(n_rw) as size_t as size_t;\n        }\n    }\n    return total;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/full_write.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/full_write.rs:1:1: 1:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:830 ~ rust[fc84]::src::quotearg::quotearg_custom)",
    "span": "src/quotearg.rs:1560:1: 1577:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1560:1: 1577:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:1025 ~ rust[fc84]::src::xmalloc::xstrdup)",
    "span": "src/xmalloc.rs:1018:1: 1024:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1018:1: 1024:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:26:1: 26:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:24:1: 24:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:793 ~ rust[fc84]::src::quotearg::set_quoting_style)",
    "span": "src/quotearg.rs:207:1: 216:2 (#0)",
    "pieces": [
      "src/quotearg.rs:207:1: 216:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:183:1: 189:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:41:1: 41:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:39:1: 39:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:5: 28:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:37:1: 37:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:254 ~ rust[fc84]::src::hard_locale::hard_locale)",
    "span": "src/hard_locale.rs:14:1: 31:2 (#0)",
    "pieces": [
      "src/hard_locale.rs:14:1: 31:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hard_locale.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/hard_locale.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:100 ~ cat[4a5d]::emit_ancillary_info)",
    "span": "src/cat.rs:256:1: 307:2 (#0)",
    "pieces": [
      "src/cat.rs:256:1: 307:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 115,
    "source": "unsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:132 ~ cat[4a5d]::usage)",
        "span": "src/cat.rs:534:1: 534:35 (#0)",
        "source": "emit_ancillary_info(&program_str);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:99 ~ cat[4a5d]::emit_stdin_note)",
    "span": "src/cat.rs:250:1: 253:2 (#0)",
    "pieces": [
      "src/cat.rs:250:1: 253:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_stdin_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nWith no FILE, or when FILE is -, read standard input.\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:132 ~ cat[4a5d]::usage)",
        "span": "src/cat.rs:494:9: 494:27 (#0)",
        "source": "emit_stdin_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:121 ~ cat[4a5d]::usage)",
    "span": "src/cat.rs:469:1: 537:2 (#0)",
    "pieces": [
      "src/cat.rs:469:1: 537:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 66,
    "source": "pub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [FILE]...\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Concatenate FILE(s) to standard output.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_stdin_note();\n        fputs_unlocked(\n            gettext(\n                b\"\\n  -A, --show-all           equivalent to -vET\\n  -b, --number-nonblank    number nonempty output lines, overrides -n\\n  -e                       equivalent to -vE\\n  -E, --show-ends          display $ at end of each line\\n  -n, --number             number all output lines\\n  -s, --squeeze-blank      suppress repeated empty output lines\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -t                       equivalent to -vT\\n  -T, --show-tabs          display TAB characters as ^I\\n  -u                       (ignored)\\n  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        printf(\n            gettext(\n                b\"\\nExamples:\\n  %s f - g  Output f's contents, then standard input, then g's contents.\\n  %s        Copy standard input to standard output.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            program_name,\n            program_name,\n        );\n        emit_ancillary_info(b\"cat\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1152:17: 1152:41 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1131:17: 1131:41 (#0)",
        "source": "usage(0 as libc::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:108 ~ cat[4a5d]::__gl_setmode)",
    "span": "src/cat.rs:407:1: 409:2 (#0)",
    "pieces": [
      "src/cat.rs:407:1: 409:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:120 ~ cat[4a5d]::set_binary_mode)",
        "span": "src/cat.rs:416:5: 416:35 (#0)",
        "source": "return __gl_setmode(fd, mode);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:105 ~ cat[4a5d]::__gl_stdbit_clzll)",
    "span": "src/cat.rs:360:1: 366:2 (#0)",
    "pieces": [
      "src/cat.rs:360:1: 366:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "unsafe extern \"C\" fn __gl_stdbit_clzll(mut n: libc::c_ulonglong) -> libc::c_int {\n    return (if n != 0 {\n        n.leading_zeros() as i32 as libc::c_ulong\n    } else {\n        (8 as libc::c_int as libc::c_ulong)\n            .wrapping_mul(::core::mem::size_of::<libc::c_ulonglong>() as libc::c_ulong)\n    }) as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:106 ~ cat[4a5d]::stdc_leading_zeros_ull)",
    "span": "src/cat.rs:369:1: 371:2 (#0)",
    "pieces": [
      "src/cat.rs:369:1: 371:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn stdc_leading_zeros_ull(mut n: libc::c_ulonglong) -> libc::c_uint {\n    return __gl_stdbit_clzll(n) as libc::c_uint;\n}",
    "calls": [
      {
        "caller": "DefId(0:118 ~ cat[4a5d]::io_blksize)",
        "span": "src/cat.rs:384:9: 384:86 (#0)",
        "source": "let leading_zeros = stdc_leading_zeros_ull(adjusted_blocksize as u64) as i32;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:107 ~ cat[4a5d]::io_blksize)",
    "span": "src/cat.rs:374:1: 404:2 (#0)",
    "pieces": [
      "src/cat.rs:374:1: 404:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "unsafe extern \"C\" fn io_blksize(mut st: *const stat) -> idx_t {\n    let mut blocksize: idx_t = (if (if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) <= 0 as libc::c_int\n    {\n        IO_BUFSIZE as libc::c_int\n    } else if (0 as libc::c_int) < (*st).st_blksize\n        && (*st).st_blksize as libc::c_ulong\n            <= (-(1 as libc::c_int) as size_t)\n                .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    {\n        (*st).st_blksize\n    } else {\n        512 as libc::c_int\n    }) as idx_t;\n    blocksize\n        += (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long\n            - (IO_BUFSIZE as libc::c_int - 1 as libc::c_int) as libc::c_long % blocksize;\n    if (*st).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        && blocksize & blocksize - 1 as libc::c_int as libc::c_long != 0\n    {\n        let mut leading_zeros: libc::c_int = stdc_leading_zeros_ull(\n            blocksize as libc::c_ulonglong,\n        ) as libc::c_int;\n        if (9223372036854775807 as libc::c_long as libc::c_ulonglong)\n            < (9223372036854775807 as libc::c_longlong as libc::c_ulonglong)\n                .wrapping_mul(2 as libc::c_ulonglong)\n                .wrapping_add(1 as libc::c_ulonglong) || leading_zeros != 0\n        {\n            let mut power: libc::c_ulonglong = (1 as libc::c_ulonglong)\n                << 64 as libc::c_int - leading_zeros;\n            if power <= 9223372036854775807 as libc::c_long as libc::c_ulonglong {\n                blocksize = power as idx_t;\n            }\n        }\n    }\n    return (if (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n        < 18446744073709551615 as libc::c_ulong\n    {\n        9223372036854775807 as libc::c_long as libc::c_ulong\n    } else {\n        18446744073709551615 as libc::c_ulong\n    })\n        .wrapping_div(2 as libc::c_int as libc::c_ulong)\n        .wrapping_add(1 as libc::c_int as libc::c_ulong) < blocksize as libc::c_ulong\n    {\n        (if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        })\n            .wrapping_div(2 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n    } else {\n        blocksize as libc::c_ulong\n    }) as idx_t;\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1325:21: 1325:52 (#0)",
        "source": "insize = io_blksize(&stat_buf);"
      },
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1193:5: 1193:52 (#0)",
        "source": "let mut outsize: idx_t = io_blksize(&stat_buf);"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:236:1: 236:48 (#0)",
        "source": "pub const IO_BUFSIZE: C2RustUnnamed_0 = 262144;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:103 ~ cat[4a5d]::write_error)",
    "span": "src/cat.rs:310:1: 353:2 (#0)",
    "pieces": [
      "src/cat.rs:310:1: 353:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "unsafe extern \"C\" fn write_error() {\n    let mut saved_errno: libc::c_int = *__errno_location();\n    fflush_unlocked(stdout);\n    fpurge(stdout);\n    clearerr_unlocked(stdout);\n    if 0 != 0 {\n        error(\n            1 as libc::c_int,\n            saved_errno,\n            gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n        );\n        if 1 as libc::c_int != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = 1 as libc::c_int;\n            error(\n                __errstatus,\n                saved_errno,\n                gettext(b\"write error\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1821:13: 1821:27 (#0)",
        "source": "write_error();"
      },
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:635:13: 635:27 (#0)",
        "source": "write_error();"
      },
      {
        "caller": "DefId(0:134 ~ cat[4a5d]::simple_cat)",
        "span": "src/cat.rs:588:17: 588:31 (#0)",
        "source": "write_error();"
      },
      {
        "caller": "DefId(0:135 ~ cat[4a5d]::write_pending)",
        "span": "src/cat.rs:604:13: 604:27 (#0)",
        "source": "write_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:123 ~ cat[4a5d]::simple_cat)",
    "span": "src/cat.rs:566:1: 592:2 (#0)",
    "pieces": [
      "src/cat.rs:566:1: 592:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "unsafe extern \"C\" fn simple_cat(mut buf: *mut libc::c_char, mut bufsize: idx_t) -> bool {\n    loop {\n        let mut n_read: size_t = safe_read(\n            input_desc,\n            buf as *mut libc::c_void,\n            bufsize as size_t,\n        );\n        if n_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        infile,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if n_read == 0 as libc::c_int as libc::c_ulong {\n            return 1 as libc::c_int != 0;\n        }\n        if full_write(1 as libc::c_int, buf as *const libc::c_void, n_read) != n_read {\n            write_error();\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1382:5: 1382:33 (#0)",
        "source": "ok &= simple_cat(buf_slice);"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:436:1: 436:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/cat.rs:437:1: 437:40 (#0)",
        "source": "static mut input_desc: libc::c_int = 0;"
      },
      {
        "span": "src/cat.rs:231:1: 231:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:124 ~ cat[4a5d]::write_pending)",
    "span": "src/cat.rs:595:1: 608:2 (#0)",
    "pieces": [
      "src/cat.rs:595:1: 608:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "unsafe extern \"C\" fn write_pending(\n    mut outbuf: *mut libc::c_char,\n    mut bpout: *mut *mut libc::c_char,\n) {\n    let mut n_write: idx_t = (*bpout).offset_from(outbuf) as libc::c_long;\n    if (0 as libc::c_int as libc::c_long) < n_write {\n        if full_write(1 as libc::c_int, outbuf as *const libc::c_void, n_write as size_t)\n            != n_write as libc::c_ulong\n        {\n            write_error();\n        }\n        *bpout = outbuf;\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:686:5: 686:39 (#0)",
        "source": "write_pending(outbuf, &mut bpout);"
      },
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:692:5: 692:39 (#0)",
        "source": "write_pending(outbuf, &mut bpout);"
      },
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:675:5: 675:39 (#0)",
        "source": "write_pending(outbuf, &mut bpout);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:104 ~ cat[4a5d]::alignfree)",
    "span": "src/cat.rs:356:1: 358:2 (#0)",
    "pieces": [
      "src/cat.rs:356:1: 358:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn alignfree(mut ptr: *mut libc::c_void) {\n    free(ptr);\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1743:33: 1743:72 (#0)",
        "source": "alignfree(outbuf as *mut libc::c_void);"
      },
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1746:1: 1746:39 (#0)",
        "source": "alignfree(inbuf as *mut libc::c_void);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:122 ~ cat[4a5d]::next_line_num)",
    "span": "src/cat.rs:538:1: 564:2 (#0)",
    "pieces": [
      "src/cat.rs:538:1: 564:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 26,
    "source": "unsafe extern \"C\" fn next_line_num() {\n    let mut endp: *mut libc::c_char = line_num_end;\n    loop {\n        let fresh0 = *endp;\n        *endp = *endp + 1;\n        if (fresh0 as libc::c_int) < '9' as i32 {\n            return;\n        }\n        let fresh1 = endp;\n        endp = endp.offset(-1);\n        *fresh1 = '0' as i32 as libc::c_char;\n        if !(endp >= line_num_start) {\n            break;\n        }\n    }\n    if line_num_start > line_buf.as_mut_ptr() {\n        line_num_start = line_num_start.offset(-1);\n        *line_num_start = '1' as i32 as libc::c_char;\n    } else {\n        *line_buf.as_mut_ptr() = '>' as i32 as libc::c_char;\n    }\n    if line_num_start < line_num_print {\n        line_num_print = line_num_print.offset(-1);\n        line_num_print;\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:722:17: 722:33 (#0)",
        "source": "next_line_num();"
      },
      {
        "caller": "DefId(0:136 ~ cat[4a5d]::cat)",
        "span": "src/cat.rs:778:5: 778:21 (#0)",
        "source": "next_line_num();"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:462:1: 463:26 (#0)",
        "source": "static mut line_num_start: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:464:1: 465:26 (#0)",
        "source": "static mut line_num_end: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:460:1: 461:26 (#0)",
        "source": "static mut line_num_print: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:438:1: 459:3 (#0)",
        "source": "static mut line_buf: [libc::c_char; 20] = [\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    '0' as i32 as libc::c_char,\n    '\\t' as i32 as libc::c_char,\n    '\\0' as i32 as libc::c_char,\n];"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:125 ~ cat[4a5d]::cat)",
    "span": "src/cat.rs:609:1: 863:2 (#0)",
    "pieces": [
      "src/cat.rs:609:1: 628:8 (#0)",
      "src/cat.rs:862:1: 863:2 (#0)"
    ],
    "sub_chunks": [
      3
    ],
    "num_lines": 22,
    "source": "unsafe extern \"C\" fn cat(\n    mut inbuf: *mut libc::c_char,\n    mut insize: idx_t,\n    mut outbuf: *mut libc::c_char,\n    mut outsize: idx_t,\n    mut show_nonprinting: bool,\n    mut show_tabs: bool,\n    mut number: bool,\n    mut number_nonblank: bool,\n    mut show_ends: bool,\n    mut squeeze_blank: bool,\n) -> bool {\n    let mut ch: libc::c_uchar = 0;\n    let mut newlines: libc::c_int = newlines2;\n    let mut use_fionread: bool = 1 as libc::c_int != 0;\n    let mut eob: *mut libc::c_char = inbuf;\n    let mut bpin: *mut libc::c_char = eob.offset(1 as libc::c_int as isize);\n    let mut bpout: *mut libc::c_char = outbuf;\n    loop {\n       <<chunk 3>>    };\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1730:33: 1742:60 (#0)",
        "source": "ok = (ok as libc::c_int\n                                    & cat(\n                                        inbuf,\n                                        insize,\n                                        outbuf,\n                                        outsize,\n                                        show_nonprinting,\n                                        show_tabs,\n                                        number,\n                                        number_nonblank,\n                                        show_ends,\n                                        squeeze_blank,\n                                    ) as libc::c_int) != 0;"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:466:1: 466:54 (#0)",
        "source": "static mut newlines2: libc::c_int = 0 as libc::c_int;"
      },
      {
        "span": "src/cat.rs:231:1: 231:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/cat.rs:460:1: 461:26 (#0)",
        "source": "static mut line_num_print: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:437:1: 437:40 (#0)",
        "source": "static mut input_desc: libc::c_int = 0;"
      },
      {
        "span": "src/cat.rs:436:1: 436:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/cat.rs:230:1: 230:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/cat.rs:467:1: 467:53 (#0)",
        "source": "static mut pending_cr: bool = 0 as libc::c_int != 0;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/cat.rs:649:4: 700:40 (#0)",
        "pieces": [
          "src/cat.rs:649:4: 700:40 (#0)"
        ],
        "num_lines": 143,
        "source": "let mut input_pending: bool = 0 as libc::c_int != 0;\n                let mut n_to_read: libc::c_int = 0 as libc::c_int;\n                if use_fionread as libc::c_int != 0\n                    && ioctl(\n                        input_desc,\n                        0x541b as libc::c_int as libc::c_ulong,\n                        &mut n_to_read as *mut libc::c_int,\n                    ) < 0 as libc::c_int\n                {\n                    if *__errno_location() == 95 as libc::c_int\n                        || *__errno_location() == 25 as libc::c_int\n                        || *__errno_location() == 22 as libc::c_int\n                        || *__errno_location() == 19 as libc::c_int\n                        || *__errno_location() == 38 as libc::c_int\n                    {\n                        use_fionread = 0 as libc::c_int != 0;\n                    } else {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                *__errno_location(),\n                                gettext(\n                                    b\"cannot do ioctl on %s\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, infile),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    gettext(\n                                        b\"cannot do ioctl on %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_style(shell_escape_always_quoting_style, infile),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    *__errno_location(),\n                                    gettext(\n                                        b\"cannot do ioctl on %s\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_style(shell_escape_always_quoting_style, infile),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        newlines2 = newlines;\n                        return 0 as libc::c_int != 0;\n                    }\n                }\n                if n_to_read != 0 as libc::c_int {\n                    input_pending = 1 as libc::c_int != 0;\n                }\n                if !input_pending {\n                    write_pending(outbuf, &mut bpout);\n                }\n                let mut n_read: size_t = safe_read(\n                    input_desc,\n                    inbuf as *mut libc::c_void,\n                    insize as size_t,\n                );\n                if n_read == -(1 as libc::c_int) as size_t {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    write_pending(outbuf, &mut bpout);\n                    newlines2 = newlines;\n                    return 0 as libc::c_int != 0;\n                }\n                if n_read == 0 as libc::c_int as libc::c_ulong {\n                    write_pending(outbuf, &mut bpout);\n                    newlines2 = newlines;\n                    return 1 as libc::c_int != 0;\n                }\n                bpin = inbuf;\n                eob = bpin.offset(n_read as isize);\n                *eob = '\\n' as i32 as libc::c_char;\n                current_block_52 = 6476622998065200121;",
        "sub_chunks": [],
        "live_in": [
          "mut inbuf: *mut i8",
          "mut insize: i64",
          "mut outbuf: *mut i8",
          "mut newlines: i32",
          "mut use_fionread: bool",
          "mut eob: *mut i8",
          "mut bpin: *mut i8",
          "mut bpout: *mut i8",
          "mut current_block_52: u64"
        ],
        "live_out": [
          "mut inbuf: *mut i8",
          "mut insize: i64",
          "mut outbuf: *mut i8",
          "mut newlines: i32",
          "mut use_fionread: bool",
          "mut eob: *mut i8",
          "mut bpin: *mut i8",
          "mut bpout: *mut i8",
          "mut current_block_52: u64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/cat.rs:704:4: 754:2 (#0)",
        "pieces": [
          "src/cat.rs:704:4: 754:2 (#0)"
        ],
        "num_lines": 51,
        "source": "newlines += 1;\n                if newlines > 0 as libc::c_int {\n                    if newlines >= 2 as libc::c_int {\n                        newlines = 2 as libc::c_int;\n                        if squeeze_blank {\n                            let fresh2 = bpin;\n                            bpin = bpin.offset(1);\n                            ch = *fresh2 as libc::c_uchar;\n                            current_block_52 = 16658872821858055392;\n                        } else {\n                            current_block_52 = 15597372965620363352;\n                        }\n                    } else {\n                        current_block_52 = 15597372965620363352;\n                    }\n                    match current_block_52 {\n                        16658872821858055392 => {}\n                        _ => {\n                            if number as libc::c_int != 0 && !number_nonblank {\n                                next_line_num();\n                                bpout = stpcpy(bpout, line_num_print);\n                            }\n                            current_block_52 = 17784502470059252271;\n                        }\n                    }\n                } else {\n                    current_block_52 = 17784502470059252271;\n                }\n                match current_block_52 {\n                    16658872821858055392 => {}\n                    _ => {\n                        if show_ends {\n                            if pending_cr {\n                                let fresh3 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh3 = '^' as i32 as libc::c_char;\n                                let fresh4 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh4 = 'M' as i32 as libc::c_char;\n                                pending_cr = 0 as libc::c_int != 0;\n                            }\n                            let fresh5 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh5 = '$' as i32 as libc::c_char;\n                        }\n                        let fresh6 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh6 = '\\n' as i32 as libc::c_char;\n                        current_block_52 = 6476622998065200121;\n                    }\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut show_ends: bool",
          "mut squeeze_blank: bool",
          "mut ch: u8",
          "mut newlines: i32",
          "mut bpin: *mut i8",
          "mut bpout: *mut i8",
          "mut current_block_52: u64"
        ],
        "live_out": [
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut show_ends: bool",
          "mut squeeze_blank: bool",
          "mut ch: u8",
          "mut newlines: i32",
          "mut bpin: *mut i8",
          "mut bpout: *mut i8",
          "mut current_block_52: u64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/cat.rs:630:5: 768:2 (#0)",
        "pieces": [
          "src/cat.rs:630:5: 649:3 (#0)",
          "src/cat.rs:702:1: 704:3 (#0)",
          "src/cat.rs:756:1: 768:2 (#0)"
        ],
        "num_lines": 41,
        "source": "if outbuf.offset(outsize as isize) <= bpout {\n                let mut wp: *mut libc::c_char = outbuf;\n                let mut remaining_bytes: idx_t = 0;\n                loop {\n                    if full_write(\n                        1 as libc::c_int,\n                        wp as *const libc::c_void,\n                        outsize as size_t,\n                    ) != outsize as libc::c_ulong\n                    {\n                        write_error();\n                    }\n                    wp = wp.offset(outsize as isize);\n                    remaining_bytes = bpout.offset_from(wp) as libc::c_long;\n                    if !(outsize <= remaining_bytes) {\n                        break;\n                    }\n                }\n                memmove(\n                    outbuf as *mut libc::c_void,\n                    wp as *const libc::c_void,\n                    remaining_bytes as libc::c_ulong,\n                );\n                bpout = outbuf.offset(remaining_bytes as isize);\n            }\n            if bpin > eob {\n               <<chunk 0>>            } else {\n               <<chunk 1>>            }\n            match current_block_52 {\n                6476622998065200121 => {\n                    let fresh7 = bpin;\n                    bpin = bpin.offset(1);\n                    ch = *fresh7 as libc::c_uchar;\n                }\n                _ => {}\n            }\n            if !(ch as libc::c_int == '\\n' as i32) {\n                break;\n            }",
        "sub_chunks": [
          0,
          1
        ],
        "live_in": [
          "mut inbuf: *mut i8",
          "mut insize: i64",
          "mut outbuf: *mut i8",
          "mut outsize: i64",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut show_ends: bool",
          "mut squeeze_blank: bool",
          "mut ch: u8",
          "mut newlines: i32",
          "mut use_fionread: bool",
          "mut eob: *mut i8",
          "mut bpin: *mut i8",
          "mut bpout: *mut i8",
          "mut current_block_52: u64"
        ],
        "live_out": [
          "mut inbuf: *mut i8",
          "mut insize: i64",
          "mut outbuf: *mut i8",
          "mut outsize: i64",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut show_ends: bool",
          "mut squeeze_blank: bool",
          "mut ch: u8",
          "mut newlines: i32",
          "mut use_fionread: bool",
          "mut eob: *mut i8",
          "mut bpin: *mut i8",
          "mut bpout: *mut i8",
          "mut current_block_52: u64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/cat.rs:628:9: 860:3 (#0)",
        "pieces": [
          "src/cat.rs:628:9: 630:4 (#0)",
          "src/cat.rs:770:1: 860:3 (#0)"
        ],
        "num_lines": 118,
        "source": "let mut current_block_52: u64;\n        loop {\n           <<chunk 2>>        }\n        if pending_cr {\n            let fresh8 = bpout;\n            bpout = bpout.offset(1);\n            *fresh8 = '\\r' as i32 as libc::c_char;\n            pending_cr = 0 as libc::c_int != 0;\n        }\n        if newlines >= 0 as libc::c_int && number as libc::c_int != 0 {\n            next_line_num();\n            bpout = stpcpy(bpout, line_num_print);\n        }\n        if show_nonprinting {\n            loop {\n                if ch as libc::c_int >= 32 as libc::c_int {\n                    if (ch as libc::c_int) < 127 as libc::c_int {\n                        let fresh9 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh9 = ch as libc::c_char;\n                    } else if ch as libc::c_int == 127 as libc::c_int {\n                        let fresh10 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh10 = '^' as i32 as libc::c_char;\n                        let fresh11 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh11 = '?' as i32 as libc::c_char;\n                    } else {\n                        let fresh12 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh12 = 'M' as i32 as libc::c_char;\n                        let fresh13 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh13 = '-' as i32 as libc::c_char;\n                        if ch as libc::c_int >= 128 as libc::c_int + 32 as libc::c_int {\n                            if (ch as libc::c_int)\n                                < 128 as libc::c_int + 127 as libc::c_int\n                            {\n                                let fresh14 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh14 = (ch as libc::c_int - 128 as libc::c_int)\n                                    as libc::c_char;\n                            } else {\n                                let fresh15 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh15 = '^' as i32 as libc::c_char;\n                                let fresh16 = bpout;\n                                bpout = bpout.offset(1);\n                                *fresh16 = '?' as i32 as libc::c_char;\n                            }\n                        } else {\n                            let fresh17 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh17 = '^' as i32 as libc::c_char;\n                            let fresh18 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh18 = (ch as libc::c_int - 128 as libc::c_int\n                                + 64 as libc::c_int) as libc::c_char;\n                        }\n                    }\n                } else if ch as libc::c_int == '\\t' as i32 && !show_tabs {\n                    let fresh19 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh19 = '\\t' as i32 as libc::c_char;\n                } else if ch as libc::c_int == '\\n' as i32 {\n                    newlines = -(1 as libc::c_int);\n                    break;\n                } else {\n                    let fresh20 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh20 = '^' as i32 as libc::c_char;\n                    let fresh21 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh21 = (ch as libc::c_int + 64 as libc::c_int) as libc::c_char;\n                }\n                let fresh22 = bpin;\n                bpin = bpin.offset(1);\n                ch = *fresh22 as libc::c_uchar;\n            }\n        } else {\n            loop {\n                if ch as libc::c_int == '\\t' as i32 && show_tabs as libc::c_int != 0 {\n                    let fresh23 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh23 = '^' as i32 as libc::c_char;\n                    let fresh24 = bpout;\n                    bpout = bpout.offset(1);\n                    *fresh24 = (ch as libc::c_int + 64 as libc::c_int) as libc::c_char;\n                } else if ch as libc::c_int != '\\n' as i32 {\n                    if ch as libc::c_int == '\\r' as i32\n                        && *bpin as libc::c_int == '\\n' as i32\n                        && show_ends as libc::c_int != 0\n                    {\n                        if bpin == eob {\n                            pending_cr = 1 as libc::c_int != 0;\n                        } else {\n                            let fresh25 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh25 = '^' as i32 as libc::c_char;\n                            let fresh26 = bpout;\n                            bpout = bpout.offset(1);\n                            *fresh26 = 'M' as i32 as libc::c_char;\n                        }\n                    } else {\n                        let fresh27 = bpout;\n                        bpout = bpout.offset(1);\n                        *fresh27 = ch as libc::c_char;\n                    }\n                } else {\n                    newlines = -(1 as libc::c_int);\n                    break;\n                }\n                let fresh28 = bpin;\n                bpin = bpin.offset(1);\n                ch = *fresh28 as libc::c_uchar;\n            }\n        }",
        "sub_chunks": [
          2
        ],
        "live_in": [
          "mut inbuf: *mut i8",
          "mut insize: i64",
          "mut outbuf: *mut i8",
          "mut outsize: i64",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut show_ends: bool",
          "mut squeeze_blank: bool",
          "mut ch: u8",
          "mut newlines: i32",
          "mut use_fionread: bool",
          "mut eob: *mut i8",
          "mut bpin: *mut i8",
          "mut bpout: *mut i8"
        ],
        "live_out": [
          "mut inbuf: *mut i8",
          "mut insize: i64",
          "mut outbuf: *mut i8",
          "mut outsize: i64",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut show_ends: bool",
          "mut squeeze_blank: bool",
          "mut ch: u8",
          "mut newlines: i32",
          "mut use_fionread: bool",
          "mut eob: *mut i8",
          "mut bpin: *mut i8",
          "mut bpout: *mut i8"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:126 ~ cat[4a5d]::copy_cat)",
    "span": "src/cat.rs:864:1: 950:2 (#0)",
    "pieces": [
      "src/cat.rs:864:1: 950:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 87,
    "source": "unsafe extern \"C\" fn copy_cat() -> libc::c_int {\n    let mut copy_max: ssize_t = (((if (9223372036854775807 as libc::c_long\n        as libc::c_ulong) < 18446744073709551615 as libc::c_ulong\n    {\n        9223372036854775807 as libc::c_long as libc::c_ulong\n    } else {\n        18446744073709551615 as libc::c_ulong\n    }) >> 30 as libc::c_int) << 30 as libc::c_int) as ssize_t;\n    let mut some_copied: bool = 0 as libc::c_int != 0;\n    loop {\n        match rpl_copy_file_range(\n            input_desc,\n            0 as *mut off_t,\n            1 as libc::c_int,\n            0 as *mut off_t,\n            copy_max as size_t,\n            0 as libc::c_int as libc::c_uint,\n        ) {\n            0 => return some_copied as libc::c_int,\n            -1 => {\n                if *__errno_location() == 38 as libc::c_int\n                    || is_ENOTSUP(*__errno_location()) as libc::c_int != 0\n                    || *__errno_location() == 22 as libc::c_int\n                    || *__errno_location() == 9 as libc::c_int\n                    || *__errno_location() == 18 as libc::c_int\n                    || *__errno_location() == 26 as libc::c_int\n                    || *__errno_location() == 1 as libc::c_int\n                {\n                    return 0 as libc::c_int;\n                }\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return -(1 as libc::c_int);\n            }\n            _ => {}\n        }\n        some_copied = 1 as libc::c_int != 0;\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1369:86: 1371:2 (#0)",
        "source": "{\n    copy_cat()\n}"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:436:1: 436:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/cat.rs:437:1: 437:40 (#0)",
        "source": "static mut input_desc: libc::c_int = 0;"
      },
      {
        "span": "src/cat.rs:231:1: 231:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:110 ~ cat[4a5d]::xset_binary_mode_error)",
    "span": "src/cat.rs:419:1: 425:2 (#0)",
    "pieces": [
      "src/cat.rs:419:1: 425:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "unsafe extern \"C\" fn xset_binary_mode_error() {}",
    "calls": [
      {
        "caller": "DefId(0:122 ~ cat[4a5d]::xset_binary_mode)",
        "span": "src/cat.rs:431:13: 431:38 (#0)",
        "source": "xset_binary_mode_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:111 ~ cat[4a5d]::xset_binary_mode)",
    "span": "src/cat.rs:428:1: 434:2 (#0)",
    "pieces": [
      "src/cat.rs:428:1: 434:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1221:17: 1221:40 (#0)",
        "source": "xset_binary_mode(0, 0);"
      },
      {
        "caller": "DefId(0:138 ~ cat[4a5d]::main_0)",
        "span": "src/cat.rs:1203:9: 1203:32 (#0)",
        "source": "xset_binary_mode(1, 0);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:127 ~ cat[4a5d]::main_0)",
    "span": "src/cat.rs:951:1: 1856:2 (#0)",
    "pieces": [
      "src/cat.rs:951:1: 955:4 (#0)",
      "src/cat.rs:1085:1: 1085:4 (#0)",
      "src/cat.rs:1824:1: 1824:4 (#0)",
      "src/cat.rs:1856:1: 1856:2 (#0)"
    ],
    "sub_chunks": [
      10,
      11,
      12
    ],
    "num_lines": 8,
    "source": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n   <<chunk 10>>   <<chunk 11>>   <<chunk 12>>}",
    "calls": [
      {
        "caller": "DefId(0:142 ~ cat[4a5d]::main)",
        "span": "src/cat.rs:1867:5: 1874:6 (#0)",
        "source": "unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/cat.rs:242:1: 242:45 (#0)",
        "source": "pub const FADVISE_SEQUENTIAL: fadvice_t = 2;"
      },
      {
        "span": "src/cat.rs:437:1: 437:40 (#0)",
        "source": "static mut input_desc: libc::c_int = 0;"
      },
      {
        "span": "src/cat.rs:231:1: 231:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/cat.rs:436:1: 436:67 (#0)",
        "source": "static mut infile: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/cat.rs:1286:21: 1322:12 (#0)",
        "pieces": [
          "src/cat.rs:1286:21: 1322:12 (#0)"
        ],
        "num_lines": 51,
        "source": "if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;",
        "sub_chunks": [],
        "live_in": [
          "mut ok: bool"
        ],
        "live_out": [
          "mut ok: bool"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/cat.rs:1369:5: 1383:2 (#0)",
        "pieces": [
          "src/cat.rs:1369:5: 1383:2 (#0)"
        ],
        "num_lines": 20,
        "source": "let mut copy_cat_status: libc::c_int = if out_isreg\n                                    as libc::c_int != 0\n                                    && stat_buf.st_mode\n                                        & 0o170000 as libc::c_int as libc::c_uint\n                                        == 0o100000 as libc::c_int as libc::c_uint\n                                {\n                                    copy_cat()\n                                } else {\n                                    0 as libc::c_int\n                                };\n                                if copy_cat_status != 0 as libc::c_int {\n                                    inbuf = 0 as *mut libc::c_char;\n                                    ok = (ok as libc::c_int\n                                        & ((0 as libc::c_int) < copy_cat_status) as libc::c_int) != 0;\n                                } else {\n                                    insize = if insize > outsize { insize } else { outsize };\n                                    inbuf = xalignalloc(page_size, insize) as *mut libc::c_char;\n                                    ok = (ok as libc::c_int\n                                        & simple_cat(inbuf, insize) as libc::c_int) != 0;\n                                }",
        "sub_chunks": [],
        "live_in": [
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut stat_buf: stat",
          "mut outsize: i64",
          "mut out_isreg: bool",
          "mut ok: bool",
          "mut page_size: i64",
          "mut inbuf: *mut i8"
        ],
        "live_out": [
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut stat_buf: stat",
          "mut outsize: i64",
          "mut out_isreg: bool",
          "mut ok: bool",
          "mut page_size: i64",
          "mut inbuf: *mut i8",
          "copy_cat_status: i32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/cat.rs:1407:45: 1485:46 (#0)",
        "pieces": [
          "src/cat.rs:1407:45: 1485:46 (#0)"
        ],
        "num_lines": 79,
        "source": "if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    -(1 as libc::c_int) as idx_t\n                                                }) + 4 as libc::c_int as libc::c_long\n                                            }) - 1 as libc::c_int as libc::c_long)\n                                                < 0 as libc::c_int as libc::c_long\n                                            {\n                                                (insize\n                                                    < -(1 as libc::c_int) as idx_t\n                                                        / 4 as libc::c_int as libc::c_long) as libc::c_int\n                                            } else {\n                                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    4 as libc::c_int\n                                                }) - 1 as libc::c_int) < 0 as libc::c_int\n                                                {\n                                                    !(((((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) + 1 as libc::c_int)\n                                                        << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                        - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) + 0 as libc::c_int\n                                                }) < 0 as libc::c_int\n                                                {\n                                                    ((4 as libc::c_int)\n                                                        < -(if ((if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int\n                                                        } else {\n                                                            4 as libc::c_int\n                                                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                                                        {\n                                                            ((((if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) + 1 as libc::c_int)\n                                                                << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                                - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) - 1 as libc::c_int\n                                                        })) as libc::c_int\n                                                } else {\n                                                    ((0 as libc::c_int) < 4 as libc::c_int) as libc::c_int\n                                                }) != 0\n                                                {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + -(1 as libc::c_int) as idx_t\n                                                        >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                                } else {\n                                                    -(1 as libc::c_int) as idx_t\n                                                        / -(4 as libc::c_int) as libc::c_long\n                                                }) <= -(1 as libc::c_int) as libc::c_long - insize)\n                                                    as libc::c_int\n                                            }",
        "sub_chunks": [],
        "live_in": [
          "mut insize: i64"
        ],
        "live_out": [
          "mut insize: i64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/cat.rs:1487:45: 1579:2 (#0)",
        "pieces": [
          "src/cat.rs:1487:45: 1579:2 (#0)"
        ],
        "num_lines": 109,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    4 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long)\n                                                < 0 as libc::c_int as libc::c_long\n                                            {\n                                                !(((((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                }) + 1 as libc::c_int as libc::c_long)\n                                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                    - 1 as libc::c_int as libc::c_long)\n                                                    * 2 as libc::c_int as libc::c_long\n                                                    + 1 as libc::c_int as libc::c_long)\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                }) + 0 as libc::c_int as libc::c_long\n                                            }) < 0 as libc::c_int as libc::c_long\n                                            {\n                                                (((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int\n                                                } else {\n                                                    4 as libc::c_int\n                                                }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                                    < -(if ((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int\n                                                        } else {\n                                                            4 as libc::c_int\n                                                        }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                    }) - 1 as libc::c_int as libc::c_long)\n                                                        < 0 as libc::c_int as libc::c_long\n                                                    {\n                                                        ((((if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                        }) + 1 as libc::c_int as libc::c_long)\n                                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                            - 1 as libc::c_int as libc::c_long)\n                                                            * 2 as libc::c_int as libc::c_long\n                                                            + 1 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int\n                                                            } else {\n                                                                4 as libc::c_int\n                                                            }) as libc::c_long + 0 as libc::c_int as idx_t\n                                                        }) - 1 as libc::c_int as libc::c_long\n                                                    })) as libc::c_int\n                                            } else {\n                                                ((0 as libc::c_int as libc::c_long)\n                                                    < (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) as libc::c_long + 0 as libc::c_int as idx_t)\n                                                    as libc::c_int\n                                            }) != 0 && 4 as libc::c_int == -(1 as libc::c_int)\n                                            {\n                                                if ((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    insize\n                                                }) - 1 as libc::c_int as libc::c_long)\n                                                    < 0 as libc::c_int as libc::c_long\n                                                {\n                                                    ((0 as libc::c_int as libc::c_long)\n                                                        < insize + 0 as libc::c_int as idx_t) as libc::c_int\n                                                } else {\n                                                    ((0 as libc::c_int as libc::c_long) < insize\n                                                        && (-(1 as libc::c_int) as libc::c_long\n                                                            - 0 as libc::c_int as idx_t)\n                                                            < insize - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                                }\n                                            } else {\n                                                ((0 as libc::c_int as idx_t\n                                                    / 4 as libc::c_int as libc::c_long) < insize) as libc::c_int\n                                            }",
        "sub_chunks": [],
        "live_in": [
          "mut insize: i64"
        ],
        "live_out": [
          "mut insize: i64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/cat.rs:1583:41: 1699:42 (#0)",
        "pieces": [
          "src/cat.rs:1583:41: 1699:42 (#0)"
        ],
        "num_lines": 117,
        "source": "if 4 as libc::c_int == 0 as libc::c_int {\n                                            0 as libc::c_int\n                                        } else {\n                                            if insize < 0 as libc::c_int as libc::c_long {\n                                                if (if (if ((if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        insize\n                                                    }) + 0 as libc::c_int as idx_t\n                                                }) - 1 as libc::c_int as libc::c_long)\n                                                    < 0 as libc::c_int as libc::c_long\n                                                {\n                                                    !(((((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t\n                                                    }) + 1 as libc::c_int as libc::c_long)\n                                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                        - 1 as libc::c_int as libc::c_long)\n                                                        * 2 as libc::c_int as libc::c_long\n                                                        + 1 as libc::c_int as libc::c_long)\n                                                } else {\n                                                    (if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t\n                                                    }) + 0 as libc::c_int as libc::c_long\n                                                }) < 0 as libc::c_int as libc::c_long\n                                                {\n                                                    (((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int as libc::c_long\n                                                    } else {\n                                                        insize\n                                                    }) + 0 as libc::c_int as idx_t)\n                                                        < -(if ((if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                insize\n                                                            }) + 0 as libc::c_int as idx_t\n                                                        }) - 1 as libc::c_int as libc::c_long)\n                                                            < 0 as libc::c_int as libc::c_long\n                                                        {\n                                                            ((((if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                (if 1 as libc::c_int != 0 {\n                                                                    0 as libc::c_int as libc::c_long\n                                                                } else {\n                                                                    insize\n                                                                }) + 0 as libc::c_int as idx_t\n                                                            }) + 1 as libc::c_int as libc::c_long)\n                                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                                - 1 as libc::c_int as libc::c_long)\n                                                                * 2 as libc::c_int as libc::c_long\n                                                                + 1 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            (if 1 as libc::c_int != 0 {\n                                                                0 as libc::c_int as libc::c_long\n                                                            } else {\n                                                                (if 1 as libc::c_int != 0 {\n                                                                    0 as libc::c_int as libc::c_long\n                                                                } else {\n                                                                    insize\n                                                                }) + 0 as libc::c_int as idx_t\n                                                            }) - 1 as libc::c_int as libc::c_long\n                                                        })) as libc::c_int\n                                                } else {\n                                                    ((0 as libc::c_int as libc::c_long)\n                                                        < (if 1 as libc::c_int != 0 {\n                                                            0 as libc::c_int as libc::c_long\n                                                        } else {\n                                                            insize\n                                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                                }) != 0 && insize == -(1 as libc::c_int) as libc::c_long\n                                                {\n                                                    if ((if 1 as libc::c_int != 0 {\n                                                        0 as libc::c_int\n                                                    } else {\n                                                        4 as libc::c_int\n                                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                                    {\n                                                        ((0 as libc::c_int as libc::c_long)\n                                                            < 4 as libc::c_int as libc::c_long\n                                                                + 0 as libc::c_int as idx_t) as libc::c_int\n                                                    } else {\n                                                        ((-(1 as libc::c_int) as libc::c_long\n                                                            - 0 as libc::c_int as idx_t)\n                                                            < (4 as libc::c_int - 1 as libc::c_int) as libc::c_long)\n                                                            as libc::c_int\n                                                    }\n                                                } else {\n                                                    (0 as libc::c_int as idx_t / insize\n                                                        < 4 as libc::c_int as libc::c_long) as libc::c_int\n                                                }\n                                            } else {\n                                                ((-(1 as libc::c_int) as idx_t\n                                                    / 4 as libc::c_int as libc::c_long) < insize) as libc::c_int\n                                            }\n                                        }",
        "sub_chunks": [],
        "live_in": [
          "mut insize: i64"
        ],
        "live_out": [
          "mut insize: i64"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/cat.rs:1387:5: 1743:72 (#0)",
        "pieces": [
          "src/cat.rs:1387:5: 1407:44 (#0)",
          "src/cat.rs:1486:1: 1487:44 (#0)",
          "src/cat.rs:1581:1: 1583:40 (#0)",
          "src/cat.rs:1700:1: 1743:72 (#0)"
        ],
        "num_lines": 70,
        "source": "inbuf = xalignalloc(\n                                    page_size,\n                                    insize + 1 as libc::c_int as libc::c_long,\n                                ) as *mut libc::c_char;\n                                let mut bufsize: idx_t = 0;\n                                if (if (0 as libc::c_int as idx_t)\n                                    < -(1 as libc::c_int) as idx_t\n                                    && ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        insize\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    && ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int\n                                    } else {\n                                        4 as libc::c_int\n                                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                                    && (if (4 as libc::c_int) < 0 as libc::c_int {\n                                        if insize < 0 as libc::c_int as libc::c_long {\n                                           <<chunk 2>>                                        } else {\n                                           <<chunk 3>>                                        }\n                                    } else {\n                                       <<chunk 4>>                                    }) != 0\n                                {\n                                    let (fresh33, _fresh34) = insize\n                                        .overflowing_mul((4 as libc::c_int).into());\n                                    *(&mut bufsize as *mut idx_t) = fresh33;\n                                    1 as libc::c_int\n                                } else {\n                                    let (fresh35, fresh36) = insize\n                                        .overflowing_mul((4 as libc::c_int).into());\n                                    *(&mut bufsize as *mut idx_t) = fresh35;\n                                    fresh36 as libc::c_int\n                                }) != 0\n                                    || {\n                                        let (fresh37, fresh38) = bufsize.overflowing_add(outsize);\n                                        *(&mut bufsize as *mut idx_t) = fresh37;\n                                        fresh38 as libc::c_int != 0\n                                    }\n                                    || {\n                                        let (fresh39, fresh40) = bufsize\n                                            .overflowing_add((20 as libc::c_int - 1 as libc::c_int).into());\n                                        *(&mut bufsize as *mut idx_t) = fresh39;\n                                        fresh40 as libc::c_int != 0\n                                    }\n                                {\n                                    xalloc_die();\n                                }\n                                let mut outbuf: *mut libc::c_char = xalignalloc(\n                                    page_size,\n                                    bufsize,\n                                ) as *mut libc::c_char;\n                                ok = (ok as libc::c_int\n                                    & cat(\n                                        inbuf,\n                                        insize,\n                                        outbuf,\n                                        outsize,\n                                        show_nonprinting,\n                                        show_tabs,\n                                        number,\n                                        number_nonblank,\n                                        show_ends,\n                                        squeeze_blank,\n                                    ) as libc::c_int) != 0;\n                                alignfree(outbuf as *mut libc::c_void);",
        "sub_chunks": [
          2,
          3,
          4
        ],
        "live_in": [
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut outsize: i64",
          "mut ok: bool",
          "mut page_size: i64",
          "mut inbuf: *mut i8"
        ],
        "live_out": [
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut outsize: i64",
          "mut ok: bool",
          "mut page_size: i64",
          "mut inbuf: *mut i8"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/cat.rs:1367:9: 1746:91 (#0)",
        "pieces": [
          "src/cat.rs:1367:9: 1369:4 (#0)",
          "src/cat.rs:1385:1: 1387:4 (#0)",
          "src/cat.rs:1744:1: 1746:91 (#0)"
        ],
        "num_lines": 12,
        "source": "inbuf = 0 as *mut libc::c_char;\n                            if !(number as libc::c_int != 0\n                                || show_ends as libc::c_int != 0\n                                || show_nonprinting as libc::c_int != 0\n                                || show_tabs as libc::c_int != 0\n                                || squeeze_blank as libc::c_int != 0)\n                            {\n                               <<chunk 1>>                            } else {\n                               <<chunk 5>>                            }\n                            alignfree(inbuf as *mut libc::c_void);",
        "sub_chunks": [
          1,
          5
        ],
        "live_in": [
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut stat_buf: stat",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut outsize: i64",
          "mut out_isreg: bool",
          "mut ok: bool",
          "mut page_size: i64"
        ],
        "live_out": [
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut stat_buf: stat",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut outsize: i64",
          "mut out_isreg: bool",
          "mut ok: bool",
          "mut page_size: i64"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/cat.rs:1325:21: 1750:2 (#0)",
        "pieces": [
          "src/cat.rs:1325:21: 1367:8 (#0)",
          "src/cat.rs:1748:1: 1750:2 (#0)"
        ],
        "num_lines": 102,
        "source": "insize = io_blksize(&mut stat_buf);\n                    fdadvise(\n                        input_desc,\n                        0 as libc::c_int as off_t,\n                        0 as libc::c_int as off_t,\n                        FADVISE_SEQUENTIAL,\n                    );\n                    if stat_buf.st_dev == out_dev && stat_buf.st_ino == out_ino {\n                        if out_flags < -(1 as libc::c_int) {\n                            out_flags = rpl_fcntl(1 as libc::c_int, 3 as libc::c_int);\n                        }\n                        let mut exhausting: bool = 0 as libc::c_int <= out_flags\n                            && out_flags & 0o2000 as libc::c_int != 0;\n                        if !exhausting {\n                            let mut in_pos: off_t = lseek(\n                                input_desc,\n                                0 as libc::c_int as __off_t,\n                                1 as libc::c_int,\n                            );\n                            if 0 as libc::c_int as libc::c_long <= in_pos {\n                                exhausting = in_pos\n                                    < lseek(\n                                        1 as libc::c_int,\n                                        0 as libc::c_int as __off_t,\n                                        1 as libc::c_int,\n                                    );\n                            }\n                        }\n                        if exhausting {\n                            if 0 != 0 {\n                                error(\n                                    0 as libc::c_int,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"%s: input file is output file\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                    quotearg_n_style_colon(\n                                        0 as libc::c_int,\n                                        shell_escape_quoting_style,\n                                        infile,\n                                    ),\n                                );\n                                if 0 as libc::c_int != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                            } else {\n                                ({\n                                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                                    error(\n                                        __errstatus,\n                                        0 as libc::c_int,\n                                        gettext(\n                                            b\"%s: input file is output file\\0\" as *const u8\n                                                as *const libc::c_char,\n                                        ),\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            infile,\n                                        ),\n                                    );\n                                    if __errstatus != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                    \n                                });\n                                ({\n                                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                                    error(\n                                        __errstatus,\n                                        0 as libc::c_int,\n                                        gettext(\n                                            b\"%s: input file is output file\\0\" as *const u8\n                                                as *const libc::c_char,\n                                        ),\n                                        quotearg_n_style_colon(\n                                            0 as libc::c_int,\n                                            shell_escape_quoting_style,\n                                            infile,\n                                        ),\n                                    );\n                                    if __errstatus != 0 as libc::c_int {\n                                        unreachable!();\n                                    } else {};\n                                    \n                                });\n                            };\n                            ok = 0 as libc::c_int != 0;\n                            current_block = 7239751344758050955;\n                        } else {\n                            current_block = 5372832139739605200;\n                        }\n                    } else {\n                        current_block = 5372832139739605200;\n                    }\n                    match current_block {\n                        7239751344758050955 => {}\n                        _ => {\n                           <<chunk 6>>                        }\n                    }",
        "sub_chunks": [
          6
        ],
        "live_in": [
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut current_block: u64",
          "mut stat_buf: stat",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut outsize: i64",
          "mut out_dev: u64",
          "mut out_ino: u64",
          "mut out_flags: i32",
          "mut out_isreg: bool",
          "mut ok: bool",
          "mut page_size: i64"
        ],
        "live_out": [
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut current_block: u64",
          "mut stat_buf: stat",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut outsize: i64",
          "mut out_dev: u64",
          "mut out_ino: u64",
          "mut out_flags: i32",
          "mut out_isreg: bool",
          "mut ok: bool",
          "mut page_size: i64"
        ]
      },
      {
        "chunk_id": 8,
        "span": "src/cat.rs:1285:17: 1805:18 (#0)",
        "pieces": [
          "src/cat.rs:1285:17: 1286:20 (#0)",
          "src/cat.rs:1324:1: 1325:20 (#0)",
          "src/cat.rs:1752:1: 1805:18 (#0)"
        ],
        "num_lines": 58,
        "source": "if fstat(input_desc, &mut stat_buf) < 0 as libc::c_int {\n                   <<chunk 0>>                } else {\n                   <<chunk 7>>                }\n                if !reading_stdin && close(input_desc) < 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                                quotearg_n_style_colon(\n                                    0 as libc::c_int,\n                                    shell_escape_quoting_style,\n                                    infile,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                }",
        "sub_chunks": [
          0,
          7
        ],
        "live_in": [
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut current_block: u64",
          "mut stat_buf: stat",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut outsize: i64",
          "mut out_dev: u64",
          "mut out_ino: u64",
          "mut out_flags: i32",
          "mut out_isreg: bool",
          "mut ok: bool",
          "mut page_size: i64",
          "mut reading_stdin: bool"
        ],
        "live_out": [
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut current_block: u64",
          "mut stat_buf: stat",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut outsize: i64",
          "mut out_dev: u64",
          "mut out_ino: u64",
          "mut out_flags: i32",
          "mut out_isreg: bool",
          "mut ok: bool",
          "mut page_size: i64",
          "mut reading_stdin: bool"
        ]
      },
      {
        "chunk_id": 9,
        "span": "src/cat.rs:1210:9: 1812:10 (#0)",
        "pieces": [
          "src/cat.rs:1210:9: 1285:16 (#0)",
          "src/cat.rs:1806:1: 1812:10 (#0)"
        ],
        "num_lines": 83,
        "source": "if argind < argc {\n            infile = *argv.offset(argind as isize);\n        }\n        let mut reading_stdin: bool = strcmp(\n            infile,\n            b\"-\\0\" as *const u8 as *const libc::c_char,\n        ) == 0 as libc::c_int;\n        if reading_stdin {\n            have_read_stdin = 1 as libc::c_int != 0;\n            input_desc = 0 as libc::c_int;\n            if file_open_mode & 0 as libc::c_int != 0 {\n                xset_binary_mode(0 as libc::c_int, 0 as libc::c_int);\n            }\n            current_block = 13321564401369230990;\n        } else {\n            input_desc = open(infile, file_open_mode);\n            if input_desc < 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            infile,\n                        ),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            b\"%s\\0\" as *const u8 as *const libc::c_char,\n                            quotearg_n_style_colon(\n                                0 as libc::c_int,\n                                shell_escape_quoting_style,\n                                infile,\n                            ),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                ok = 0 as libc::c_int != 0;\n                current_block = 4567019141635105728;\n            } else {\n                current_block = 13321564401369230990;\n            }\n        }\n        match current_block {\n            13321564401369230990 => {\n               <<chunk 8>>            }\n            _ => {}\n        }\n        argind += 1;\n        if !(argind < argc) {\n            break;\n        }",
        "sub_chunks": [
          8
        ],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut current_block: u64",
          "mut have_read_stdin: bool",
          "mut stat_buf: stat",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut file_open_mode: i32",
          "mut outsize: i64",
          "mut out_dev: u64",
          "mut out_ino: u64",
          "mut out_flags: i32",
          "mut out_isreg: bool",
          "mut argind: i32",
          "mut ok: bool",
          "mut page_size: i64"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut current_block: u64",
          "mut have_read_stdin: bool",
          "mut stat_buf: stat",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut file_open_mode: i32",
          "mut outsize: i64",
          "mut out_dev: u64",
          "mut out_ino: u64",
          "mut out_flags: i32",
          "mut out_isreg: bool",
          "mut argind: i32",
          "mut ok: bool",
          "mut page_size: i64"
        ]
      },
      {
        "chunk_id": 10,
        "span": "src/cat.rs:955:5: 1084:32 (#0)",
        "pieces": [
          "src/cat.rs:955:5: 1084:32 (#0)"
        ],
        "num_lines": 130,
        "source": "let mut insize: idx_t = 0;\n    let mut inbuf: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut current_block: u64;\n    let mut have_read_stdin: bool = 0 as libc::c_int != 0;\n    let mut stat_buf: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut number: bool = 0 as libc::c_int != 0;\n    let mut number_nonblank: bool = 0 as libc::c_int != 0;\n    let mut squeeze_blank: bool = 0 as libc::c_int != 0;\n    let mut show_ends: bool = 0 as libc::c_int != 0;\n    let mut show_nonprinting: bool = 0 as libc::c_int != 0;\n    let mut show_tabs: bool = 0 as libc::c_int != 0;\n    let mut file_open_mode: libc::c_int = 0 as libc::c_int;\n    static mut long_options: [option; 10] = [\n        {\n            let mut init = option {\n                name: b\"number-nonblank\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'b' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"number\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'n' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"squeeze-blank\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 's' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-nonprinting\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'v' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-ends\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'E' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-tabs\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'T' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"show-all\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 'A' as i32,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"help\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: GETOPT_HELP_CHAR as libc::c_int,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: b\"version\\0\" as *const u8 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: GETOPT_VERSION_CHAR as libc::c_int,\n            };\n            init\n        },\n        {\n            let mut init = option {\n                name: 0 as *const libc::c_char,\n                has_arg: 0 as libc::c_int,\n                flag: 0 as *const libc::c_int as *mut libc::c_int,\n                val: 0 as libc::c_int,\n            };\n            init\n        },\n    ];\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    let mut c: libc::c_int = 0;",
        "sub_chunks": [],
        "live_in": [
          "mut argv: *mut *mut i8"
        ],
        "live_out": [
          "mut argv: *mut *mut i8",
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut current_block: u64",
          "mut have_read_stdin: bool",
          "mut stat_buf: stat",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut file_open_mode: i32",
          "mut c: i32"
        ]
      },
      {
        "chunk_id": 11,
        "span": "src/cat.rs:1085:5: 1823:6 (#0)",
        "pieces": [
          "src/cat.rs:1085:5: 1210:8 (#0)",
          "src/cat.rs:1813:1: 1823:6 (#0)"
        ],
        "num_lines": 137,
        "source": "loop {\n        c = getopt_long(\n            argc,\n            argv,\n            b\"benstuvAET\\0\" as *const u8 as *const libc::c_char,\n            long_options.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        match c {\n            98 => {\n                number = 1 as libc::c_int != 0;\n                number_nonblank = 1 as libc::c_int != 0;\n            }\n            101 => {\n                show_ends = 1 as libc::c_int != 0;\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            110 => {\n                number = 1 as libc::c_int != 0;\n            }\n            115 => {\n                squeeze_blank = 1 as libc::c_int != 0;\n            }\n            116 => {\n                show_tabs = 1 as libc::c_int != 0;\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            117 => {}\n            118 => {\n                show_nonprinting = 1 as libc::c_int != 0;\n            }\n            65 => {\n                show_nonprinting = 1 as libc::c_int != 0;\n                show_ends = 1 as libc::c_int != 0;\n                show_tabs = 1 as libc::c_int != 0;\n            }\n            69 => {\n                show_ends = 1 as libc::c_int != 0;\n            }\n            84 => {\n                show_tabs = 1 as libc::c_int != 0;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"cat\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Torbjorn Granlund\\0\" as *const u8 as *const libc::c_char,\n                        b\"Torbj\\xC3\\xB6rn Granlund\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                        b\"Richard M. Stallman\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                usage(1 as libc::c_int);\n            }\n        }\n    }\n    if fstat(1 as libc::c_int, &mut stat_buf) < 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"standard output\\0\" as *const u8 as *const libc::c_char),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    let mut outsize: idx_t = io_blksize(&mut stat_buf);\n    let mut out_dev: dev_t = stat_buf.st_dev;\n    let mut out_ino: ino_t = stat_buf.st_ino;\n    let mut out_flags: libc::c_int = -(2 as libc::c_int);\n    let mut out_isreg: bool = (stat_buf.st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint) as libc::c_int != 0 as libc::c_int;\n    if !(number as libc::c_int != 0 || show_ends as libc::c_int != 0\n        || squeeze_blank as libc::c_int != 0)\n    {\n        file_open_mode |= 0 as libc::c_int;\n        xset_binary_mode(1 as libc::c_int, 0 as libc::c_int);\n    }\n    infile = b\"-\\0\" as *const u8 as *const libc::c_char;\n    let mut argind: libc::c_int = optind;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut page_size: idx_t = getpagesize() as idx_t;\n    loop {\n       <<chunk 9>>    }\n    if pending_cr {\n        if full_write(\n            1 as libc::c_int,\n            b\"\\r\\0\" as *const u8 as *const libc::c_char as *const libc::c_void,\n            1 as libc::c_int as size_t,\n        ) != 1 as libc::c_int as libc::c_ulong\n        {\n            write_error();\n        }\n    }",
        "sub_chunks": [
          9
        ],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut current_block: u64",
          "mut have_read_stdin: bool",
          "mut stat_buf: stat",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut file_open_mode: i32",
          "mut c: i32"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut insize: i64",
          "mut inbuf: *mut i8",
          "mut current_block: u64",
          "mut have_read_stdin: bool",
          "mut stat_buf: stat",
          "mut number: bool",
          "mut number_nonblank: bool",
          "mut squeeze_blank: bool",
          "mut show_ends: bool",
          "mut show_nonprinting: bool",
          "mut show_tabs: bool",
          "mut file_open_mode: i32",
          "mut c: i32",
          "mut outsize: i64",
          "mut out_dev: u64",
          "mut out_ino: u64",
          "mut out_flags: i32",
          "mut out_isreg: bool",
          "mut argind: i32",
          "mut ok: bool",
          "mut page_size: i64"
        ]
      },
      {
        "chunk_id": 12,
        "span": "src/cat.rs:1824:5: 1854:31 (#0)",
        "pieces": [
          "src/cat.rs:1824:5: 1854:31 (#0)"
        ],
        "num_lines": 43,
        "source": "if have_read_stdin as libc::c_int != 0 && close(0 as libc::c_int) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"closing standard input\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"closing standard input\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"closing standard input\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    return if ok as libc::c_int != 0 { 0 as libc::c_int } else { 1 as libc::c_int };",
        "sub_chunks": [],
        "live_in": [
          "mut have_read_stdin: bool",
          "mut ok: bool"
        ],
        "live_out": []
      }
    ]
  },
  {
    "func_defid": "DefId(0:131 ~ cat[4a5d]::main)",
    "span": "src/cat.rs:1857:1: 1875:2 (#0)",
    "pieces": [
      "src/cat.rs:1857:1: 1875:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:132 ~ cat[4a5d]::run_static_initializers)",
    "span": "src/cat.rs:1876:1: 1881:2 (#0)",
    "pieces": [
      "src/cat.rs:1876:1: 1881:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "unsafe extern \"C\" fn run_static_initializers() {\n    line_num_print = line_buf\n        .as_mut_ptr()\n        .offset(20 as libc::c_int as isize)\n        .offset(-(8 as libc::c_int as isize));\n    line_num_start = line_buf\n        .as_mut_ptr()\n        .offset(20 as libc::c_int as isize)\n        .offset(-(3 as libc::c_int as isize));\n    line_num_end = line_buf\n        .as_mut_ptr()\n        .offset(20 as libc::c_int as isize)\n        .offset(-(3 as libc::c_int as isize));\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/cat.rs:462:1: 463:26 (#0)",
        "source": "static mut line_num_start: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:460:1: 461:26 (#0)",
        "source": "static mut line_num_print: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      },
      {
        "span": "src/cat.rs:438:1: 459:3 (#0)",
        "source": "static mut line_buf: [libc::c_char; 20] = [\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    ' ' as i32 as libc::c_char,\n    '0' as i32 as libc::c_char,\n    '\\t' as i32 as libc::c_char,\n    '\\0' as i32 as libc::c_char,\n];"
      },
      {
        "span": "src/cat.rs:464:1: 465:26 (#0)",
        "source": "static mut line_num_end: *mut libc::c_char = 0 as *const libc::c_char\n    as *mut libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:109 ~ cat[4a5d]::set_binary_mode)",
    "span": "src/cat.rs:412:1: 417:2 (#0)",
    "pieces": [
      "src/cat.rs:412:1: 417:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:98 ~ cat[4a5d]::is_ENOTSUP)",
    "span": "src/cat.rs:245:1: 247:2 (#0)",
    "pieces": [
      "src/cat.rs:245:1: 247:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn is_ENOTSUP(mut err: libc::c_int) -> bool {\n    return err == 95 as libc::c_int\n        || 95 as libc::c_int != 95 as libc::c_int && err == 95 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/cat.rs:24:1: 24:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/cat.rs:22:1: 22:10 (#0)",
        "source": "use libc;"
      },
      {
        "span": "src/cat.rs:26:1: 26:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/cat.rs:28:1: 28:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/cat.rs:30:1: 30:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  }
]