[
  {
    "func_defid": "DefId(0:692 ~ rust[fc84]::src::quotearg::gettext_quote)",
    "span": "src/quotearg.rs:262:1: 295:2 (#0)",
    "pieces": [
      "src/quotearg.rs:262:1: 295:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "unsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:693 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:346:21: 349:23 (#0)",
        "source": "right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );"
      },
      {
        "caller": "DefId(0:693 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:342:21: 345:23 (#0)",
        "source": "left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:693 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
    "span": "src/quotearg.rs:296:1: 1197:2 (#0)",
    "pieces": [
      "src/quotearg.rs:296:1: 1197:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 902,
    "source": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:693 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1167:13: 1177:15 (#0)",
        "source": "return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );"
      },
      {
        "caller": "DefId(0:696 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1266:5: 1276:7 (#0)",
        "source": "quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:706 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1362:5: 1372:7 (#0)",
        "source": "let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:696 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1253:5: 1264:58 (#0)",
        "source": "let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:706 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1382:9: 1392:11 (#0)",
        "source": "quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );"
      },
      {
        "caller": "DefId(0:694 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
        "span": "src/quotearg.rs:1212:5: 1222:7 (#0)",
        "source": "let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:693 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1138:41: 1150:10 (#0)",
        "source": "{\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:57:1: 57:52 (#0)",
        "source": "pub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;"
      },
      {
        "span": "src/quotearg.rs:50:1: 50:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/quotearg.rs:52:1: 52:57 (#0)",
        "source": "pub const shell_always_quoting_style: quoting_style = 2;"
      },
      {
        "span": "src/quotearg.rs:49:1: 49:46 (#0)",
        "source": "pub const c_quoting_style: quoting_style = 5;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:706 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
    "span": "src/quotearg.rs:1318:1: 1396:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1318:1: 1396:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 79,
    "source": "unsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}",
    "calls": [
      {
        "caller": "DefId(0:707 ~ rust[fc84]::src::quotearg::quotearg_n)",
        "span": "src/quotearg.rs:1402:5: 1407:7 (#0)",
        "source": "return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );"
      },
      {
        "caller": "DefId(0:727 ~ rust[fc84]::src::quotearg::quote_n_mem)",
        "span": "src/quotearg.rs:1588:5: 1588:76 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);"
      },
      {
        "caller": "DefId(0:720 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1514:5: 1519:7 (#0)",
        "source": "return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );"
      },
      {
        "caller": "DefId(0:711 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1435:5: 1435:82 (#0)",
        "source": "return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);"
      },
      {
        "caller": "DefId(0:723 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1546:5: 1546:56 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut o);"
      },
      {
        "caller": "DefId(0:712 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1445:5: 1445:52 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &o);"
      },
      {
        "caller": "DefId(0:715 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1477:5: 1477:77 (#0)",
        "source": "return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);"
      },
      {
        "caller": "DefId(0:708 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
        "span": "src/quotearg.rs:1415:5: 1415:78 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1294:1: 1296:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1284:1: 1284:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:1285:1: 1293:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:58:1: 58:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:690 ~ rust[fc84]::src::quotearg::set_custom_quoting)",
    "span": "src/quotearg.rs:228:1: 242:2 (#0)",
    "pieces": [
      "src/quotearg.rs:228:1: 242:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}",
    "calls": [
      {
        "caller": "DefId(0:723 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1545:5: 1545:57 (#0)",
        "source": "set_custom_quoting(&mut o, left_quote, right_quote);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:44:1: 44:52 (#0)",
        "source": "pub const custom_quoting_style: quoting_style = 10;"
      },
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:723 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
    "span": "src/quotearg.rs:1537:1: 1547:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1537:1: 1547:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}",
    "calls": [
      {
        "caller": "DefId(0:722 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
        "span": "src/quotearg.rs:1528:5: 1534:7 (#0)",
        "source": "return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );"
      },
      {
        "caller": "DefId(0:725 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
        "span": "src/quotearg.rs:1563:5: 1569:7 (#0)",
        "source": "return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:29 ~ rust[fc84]::src::c_strcasecmp::c_tolower)",
    "span": "src/c_strcasecmp.rs:3:1: 11:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:3:1: 11:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:30 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:26:9: 26:61 (#0)",
        "source": "c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;"
      },
      {
        "caller": "DefId(0:30 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:25:9: 25:61 (#0)",
        "source": "c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:30 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
    "span": "src/c_strcasecmp.rs:13:1: 46:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:13:1: 46:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "pub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:707 ~ rust[fc84]::src::quotearg::quotearg_n)",
    "span": "src/quotearg.rs:1398:1: 1408:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1398:1: 1408:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:709 ~ rust[fc84]::src::quotearg::quotearg)",
        "span": "src/quotearg.rs:1419:5: 1419:46 (#0)",
        "source": "return quotearg_n(0 as libc::c_int, arg);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:709 ~ rust[fc84]::src::quotearg::quotearg)",
    "span": "src/quotearg.rs:1418:1: 1420:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1418:1: 1420:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:688 ~ rust[fc84]::src::quotearg::set_char_quoting)",
    "span": "src/quotearg.rs:184:1: 213:2 (#0)",
    "pieces": [
      "src/quotearg.rs:184:1: 213:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 30,
    "source": "pub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:720 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1513:5: 1513:82 (#0)",
        "source": "set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:715 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1476:5: 1476:58 (#0)",
        "source": "set_char_quoting(&mut options, ch, 1 as libc::c_int);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:21 ~ rust[fc84]::src::c_ctype::c_isupper)",
    "span": "src/c_ctype.rs:136:1: 142:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:136:1: 142:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:884 ~ rust[fc84]::src::xmalloc::xreallocarray)",
    "span": "src/xmalloc.rs:134:1: 144:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:134:1: 144:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:886 ~ rust[fc84]::src::xmalloc::xnmalloc)",
        "span": "src/xmalloc.rs:155:5: 155:56 (#0)",
        "source": "return xreallocarray(0 as *mut libc::c_void, n, s);"
      },
      {
        "caller": "DefId(0:889 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
        "span": "src/xmalloc.rs:192:5: 192:32 (#0)",
        "source": "p = xreallocarray(p, n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:886 ~ rust[fc84]::src::xmalloc::xnmalloc)",
    "span": "src/xmalloc.rs:154:1: 156:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:154:1: 156:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [
      {
        "caller": "DefId(0:881 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:111:12: 113:6 (#0)",
        "source": "{\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:120 ~ rust[fc84]::src::fflush::clear_ungetc_buffer_preserving_position)",
    "span": "src/fflush.rs:49:1: 53:2 (#0)",
    "pieces": [
      "src/fflush.rs:49:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:121 ~ rust[fc84]::src::fflush::rpl_fflush)",
        "span": "src/fflush.rs:59:5: 59:53 (#0)",
        "source": "clear_ungetc_buffer_preserving_position(stream);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:686 ~ rust[fc84]::src::quotearg::get_quoting_style)",
    "span": "src/quotearg.rs:166:1: 175:2 (#0)",
    "pieces": [
      "src/quotearg.rs:166:1: 175:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:587 ~ rust[fc84]::src::mbszero::mbszero)",
    "span": "src/mbszero.rs:25:1: 31:2 (#0)",
    "pieces": [
      "src/mbszero.rs:25:1: 31:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mbszero.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:577 ~ rust[fc84]::src::mbrtoc32::mbszero)",
    "span": "src/mbrtoc32.rs:36:1: 42:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:36:1: 42:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:579 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
        "span": "src/mbrtoc32.rs:64:9: 64:21 (#0)",
        "source": "mbszero(ps);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:787 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:16:1: 21:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:16:1: 21:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:788 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
        "span": "src/setlocale_null_unlocked.rs:28:5: 28:77 (#0)",
        "source": "let mut result: *const libc::c_char = setlocale_null_unlocked(category);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:788 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:23:1: 58:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:23:1: 58:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:561 ~ rust[fc84]::src::localcharset::locale_charset)",
    "span": "src/localcharset.rs:391:1: 401:2 (#0)",
    "pieces": [
      "src/localcharset.rs:391:1: 401:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/localcharset.rs:5:1: 5:39 (#0)",
        "source": "pub const CODESET: C2RustUnnamed = 14;"
      }
    ],
    "imports": [
      {
        "span": "src/localcharset.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:878 ~ rust[fc84]::src::xmalloc::check_nonnull)",
    "span": "src/xmalloc.rs:91:1: 96:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:91:1: 96:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:880 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:103:5: 103:38 (#0)",
        "source": "return check_nonnull(imalloc(s));"
      },
      {
        "caller": "DefId(0:885 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:151:5: 151:50 (#0)",
        "source": "return check_nonnull(ireallocarray(p, n, s));"
      },
      {
        "caller": "DefId(0:883 ~ rust[fc84]::src::xmalloc::xirealloc)",
        "span": "src/xmalloc.rs:131:5: 131:42 (#0)",
        "source": "return check_nonnull(irealloc(p, s));"
      },
      {
        "caller": "DefId(0:894 ~ rust[fc84]::src::xmalloc::xicalloc)",
        "span": "src/xmalloc.rs:917:5: 917:41 (#0)",
        "source": "return check_nonnull(icalloc(n, s));"
      },
      {
        "caller": "DefId(0:879 ~ rust[fc84]::src::xmalloc::xmalloc)",
        "span": "src/xmalloc.rs:99:5: 99:37 (#0)",
        "source": "return check_nonnull(malloc(s));"
      },
      {
        "caller": "DefId(0:893 ~ rust[fc84]::src::xmalloc::xcalloc)",
        "span": "src/xmalloc.rs:913:5: 913:40 (#0)",
        "source": "return check_nonnull(calloc(n, s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:879 ~ rust[fc84]::src::xmalloc::xmalloc)",
    "span": "src/xmalloc.rs:98:1: 100:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:98:1: 100:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}",
    "calls": [
      {
        "caller": "DefId(0:895 ~ rust[fc84]::src::xmalloc::xmemdup)",
        "span": "src/xmalloc.rs:924:5: 924:37 (#0)",
        "source": "return memcpy(xmalloc(s), p, s);"
      },
      {
        "caller": "DefId(0:881 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:109:5: 111:6 (#0)",
        "source": "{\n        xmalloc(n)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:881 ~ rust[fc84]::src::xmalloc::xcharalloc)",
    "span": "src/xmalloc.rs:106:1: 114:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:106:1: 114:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:22 ~ rust[fc84]::src::c_ctype::c_isxdigit)",
    "span": "src/c_ctype.rs:146:1: 152:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:146:1: 152:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:691 ~ rust[fc84]::src::quotearg::quoting_options_from_style)",
    "span": "src/quotearg.rs:243:1: 261:2 (#0)",
    "pieces": [
      "src/quotearg.rs:243:1: 261:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}",
    "calls": [
      {
        "caller": "DefId(0:720 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1512:5: 1512:45 (#0)",
        "source": "options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:712 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1444:5: 1444:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:711 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1434:5: 1434:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:54:1: 54:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:712 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
    "span": "src/quotearg.rs:1438:1: 1446:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1438:1: 1446:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:714 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
        "span": "src/quotearg.rs:1460:5: 1460:68 (#0)",
        "source": "return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:714 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
    "span": "src/quotearg.rs:1455:1: 1461:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1455:1: 1461:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:15 ~ rust[fc84]::src::c_ctype::c_isdigit)",
    "span": "src/c_ctype.rs:65:1: 70:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:65:1: 70:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:19 ~ rust[fc84]::src::c_ctype::c_ispunct)",
    "span": "src/c_ctype.rs:116:1: 123:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:116:1: 123:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:704 ~ rust[fc84]::src::quotearg::quotearg_free)",
    "span": "src/quotearg.rs:1298:1: 1317:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1298:1: 1317:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:1294:1: 1296:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1284:1: 1284:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:1285:1: 1293:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:1283:1: 1283:50 (#0)",
        "source": "static mut slot0: [libc::c_char; 256] = [0; 256];"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:715 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
    "span": "src/quotearg.rs:1463:1: 1478:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1463:1: 1478:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}",
    "calls": [
      {
        "caller": "DefId(0:717 ~ rust[fc84]::src::quotearg::quotearg_char)",
        "span": "src/quotearg.rs:1484:5: 1484:78 (#0)",
        "source": "return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);"
      },
      {
        "caller": "DefId(0:719 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
        "span": "src/quotearg.rs:1497:5: 1497:72 (#0)",
        "source": "return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:54:1: 54:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:719 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
    "span": "src/quotearg.rs:1493:1: 1498:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1493:1: 1498:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:722 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
    "span": "src/quotearg.rs:1522:1: 1535:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1522:1: 1535:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:724 ~ rust[fc84]::src::quotearg::quotearg_custom)",
        "span": "src/quotearg.rs:1554:5: 1554:78 (#0)",
        "source": "return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:750 ~ rust[fc84]::src::root_dev_ino::get_root_dev_ino)",
    "span": "src/root_dev_ino.rs:51:1: 76:2 (#0)",
    "pieces": [
      "src/root_dev_ino.rs:51:1: 76:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 26,
    "source": "pub unsafe extern \"C\" fn get_root_dev_ino(mut root_d_i: *mut dev_ino) -> *mut dev_ino {\n    let mut statbuf: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    if lstat(b\"/\\0\" as *const u8 as *const libc::c_char, &mut statbuf) != 0 {\n        return 0 as *mut dev_ino;\n    }\n    (*root_d_i).st_ino = statbuf.st_ino;\n    (*root_d_i).st_dev = statbuf.st_dev;\n    return root_d_i;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/root_dev_ino.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:169 ~ rust[fc84]::src::ialloc::_gl_alloc_nomem)",
    "span": "src/ialloc.rs:86:1: 89:2 (#0)",
    "pieces": [
      "src/ialloc.rs:86:1: 89:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:165 ~ rust[fc84]::src::ialloc::ireallocarray)",
        "span": "src/ialloc.rs:36:12: 38:6 (#0)",
        "source": "{\n        return _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:168 ~ rust[fc84]::src::ialloc::imalloc)",
        "span": "src/ialloc.rs:78:12: 80:6 (#0)",
        "source": "{\n        _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:166 ~ rust[fc84]::src::ialloc::icalloc)",
        "span": "src/ialloc.rs:46:13: 46:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:167 ~ rust[fc84]::src::ialloc::irealloc)",
        "span": "src/ialloc.rs:68:12: 70:6 (#0)",
        "source": "{\n        return _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:166 ~ rust[fc84]::src::ialloc::icalloc)",
        "span": "src/ialloc.rs:52:13: 52:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:20 ~ rust[fc84]::src::c_ctype::c_isspace)",
    "span": "src/c_ctype.rs:127:1: 132:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:127:1: 132:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:893 ~ rust[fc84]::src::xmalloc::xcalloc)",
    "span": "src/xmalloc.rs:912:1: 914:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:912:1: 914:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}",
    "calls": [
      {
        "caller": "DefId(0:891 ~ rust[fc84]::src::xmalloc::xzalloc)",
        "span": "src/xmalloc.rs:905:5: 905:51 (#0)",
        "source": "return xcalloc(s, 1 as libc::c_int as size_t);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:891 ~ rust[fc84]::src::xmalloc::xzalloc)",
    "span": "src/xmalloc.rs:904:1: 906:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:904:1: 906:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:74 ~ rust[fc84]::src::closeout::close_stdout_set_file_name)",
    "span": "src/closeout.rs:63:1: 65:2 (#0)",
    "pieces": [
      "src/closeout.rs:63:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:61:1: 61:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:852 ~ rust[fc84]::src::xgetcwd::xgetcwd)",
    "span": "src/xgetcwd.rs:9:1: 18:2 (#0)",
    "pieces": [
      "src/xgetcwd.rs:9:1: 18:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xgetcwd() -> *mut libc::c_char {\n    let mut cwd: *mut libc::c_char = getcwd(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n    );\n    if cwd.is_null() && *__errno_location() == 12 as libc::c_int {\n        xalloc_die();\n    }\n    return cwd;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xgetcwd.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:777 ~ rust[fc84]::src::setlocale_null::setlocale_null)",
    "span": "src/setlocale_null.rs:20:1: 24:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:20:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:18 ~ rust[fc84]::src::c_ctype::c_isprint)",
    "span": "src/c_ctype.rs:101:1: 112:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:101:1: 112:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:687 ~ rust[fc84]::src::quotearg::set_quoting_style)",
    "span": "src/quotearg.rs:177:1: 182:2 (#0)",
    "pieces": [
      "src/quotearg.rs:177:1: 182:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:876 ~ rust[fc84]::src::xmalloc::_gl_alloc_nomem)",
    "span": "src/xmalloc.rs:79:1: 82:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:79:1: 82:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:873 ~ rust[fc84]::src::xmalloc::irealloc)",
        "span": "src/xmalloc.rs:35:12: 37:6 (#0)",
        "source": "{\n        return _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:875 ~ rust[fc84]::src::xmalloc::ireallocarray)",
        "span": "src/xmalloc.rs:73:12: 75:6 (#0)",
        "source": "{\n        return _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:874 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:43:13: 43:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:874 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:49:13: 49:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:877 ~ rust[fc84]::src::xmalloc::imalloc)",
        "span": "src/xmalloc.rs:87:12: 89:6 (#0)",
        "source": "{\n        _gl_alloc_nomem()\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:873 ~ rust[fc84]::src::xmalloc::irealloc)",
    "span": "src/xmalloc.rs:28:1: 38:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:28:1: 38:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:883 ~ rust[fc84]::src::xmalloc::xirealloc)",
        "span": "src/xmalloc.rs:131:5: 131:42 (#0)",
        "source": "return check_nonnull(irealloc(p, s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:720 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
    "span": "src/quotearg.rs:1500:1: 1520:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1500:1: 1520:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:54:1: 54:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:895 ~ rust[fc84]::src::xmalloc::xmemdup)",
    "span": "src/xmalloc.rs:920:1: 925:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:920:1: 925:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}",
    "calls": [
      {
        "caller": "DefId(0:898 ~ rust[fc84]::src::xmalloc::xstrdup)",
        "span": "src/xmalloc.rs:946:5: 949:28 (#0)",
        "source": "return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:579 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
    "span": "src/mbrtoc32.rs:48:1: 78:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:48:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 31,
    "source": "pub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/mbrtoc32.rs:43:1: 46:3 (#0)",
        "source": "static mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};"
      }
    ],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:727 ~ rust[fc84]::src::quotearg::quote_n_mem)",
    "span": "src/quotearg.rs:1583:1: 1589:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1583:1: 1589:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:729 ~ rust[fc84]::src::quotearg::quote_n)",
        "span": "src/quotearg.rs:1602:5: 1602:71 (#0)",
        "source": "return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:728 ~ rust[fc84]::src::quotearg::quote_mem)",
        "span": "src/quotearg.rs:1595:5: 1595:56 (#0)",
        "source": "return quote_n_mem(0 as libc::c_int, arg, argsize);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1572:1: 1581:3 (#0)",
        "source": "pub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:729 ~ rust[fc84]::src::quotearg::quote_n)",
    "span": "src/quotearg.rs:1598:1: 1603:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1598:1: 1603:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:730 ~ rust[fc84]::src::quotearg::quote)",
        "span": "src/quotearg.rs:1606:5: 1606:43 (#0)",
        "source": "return quote_n(0 as libc::c_int, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:16 ~ rust[fc84]::src::c_ctype::c_isgraph)",
    "span": "src/c_ctype.rs:74:1: 85:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:74:1: 85:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:696 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
    "span": "src/quotearg.rs:1235:1: 1282:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1235:1: 1282:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}",
    "calls": [
      {
        "caller": "DefId(0:695 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
        "span": "src/quotearg.rs:1232:5: 1232:66 (#0)",
        "source": "return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:58:1: 58:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:13 ~ rust[fc84]::src::c_ctype::c_isblank)",
    "span": "src/c_ctype.rs:47:1: 49:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:47:1: 49:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:874 ~ rust[fc84]::src::xmalloc::icalloc)",
    "span": "src/xmalloc.rs:40:1: 54:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:40:1: 54:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:894 ~ rust[fc84]::src::xmalloc::xicalloc)",
        "span": "src/xmalloc.rs:917:5: 917:41 (#0)",
        "source": "return check_nonnull(icalloc(n, s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:894 ~ rust[fc84]::src::xmalloc::xicalloc)",
    "span": "src/xmalloc.rs:916:1: 918:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:916:1: 918:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}",
    "calls": [
      {
        "caller": "DefId(0:892 ~ rust[fc84]::src::xmalloc::xizalloc)",
        "span": "src/xmalloc.rs:909:5: 909:51 (#0)",
        "source": "return xicalloc(s, 1 as libc::c_int as idx_t);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:728 ~ rust[fc84]::src::quotearg::quote_mem)",
    "span": "src/quotearg.rs:1591:1: 1596:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1591:1: 1596:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:776 ~ rust[fc84]::src::setlocale_null::setlocale_null_r)",
    "span": "src/setlocale_null.rs:12:1: 18:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:12:1: 18:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:882 ~ rust[fc84]::src::xmalloc::xrealloc)",
    "span": "src/xmalloc.rs:116:1: 125:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:116:1: 125:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:890 ~ rust[fc84]::src::xmalloc::xpalloc)",
        "span": "src/xmalloc.rs:899:5: 899:41 (#0)",
        "source": "pa = xrealloc(pa, nbytes as size_t);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:890 ~ rust[fc84]::src::xmalloc::xpalloc)",
    "span": "src/xmalloc.rs:197:1: 902:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:197:1: 902:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 706,
    "source": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:25:1: 25:51 (#0)",
        "source": "pub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:725 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
    "span": "src/quotearg.rs:1557:1: 1570:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1557:1: 1570:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:877 ~ rust[fc84]::src::xmalloc::imalloc)",
    "span": "src/xmalloc.rs:84:1: 90:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:84:1: 90:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:880 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:103:5: 103:38 (#0)",
        "source": "return check_nonnull(imalloc(s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:898 ~ rust[fc84]::src::xmalloc::xstrdup)",
    "span": "src/xmalloc.rs:945:1: 950:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:945:1: 950:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:818 ~ rust[fc84]::src::version_etc::version_etc_arn)",
    "span": "src/version_etc.rs:65:1: 247:2 (#0)",
    "pieces": [
      "src/version_etc.rs:65:1: 247:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 183,
    "source": "pub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:819 ~ rust[fc84]::src::version_etc::version_etc_ar)",
        "span": "src/version_etc.rs:262:5: 262:81 (#0)",
        "source": "version_etc_arn(stream, command_name, package, version, authors, n_authors);"
      },
      {
        "caller": "DefId(0:820 ~ rust[fc84]::src::version_etc::version_etc_va)",
        "span": "src/version_etc.rs:284:5: 291:7 (#0)",
        "source": "version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/version_etc.rs:62:1: 62:48 (#0)",
        "source": "pub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;"
      }
    ],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:820 ~ rust[fc84]::src::version_etc::version_etc_va)",
    "span": "src/version_etc.rs:265:1: 292:2 (#0)",
    "pieces": [
      "src/version_etc.rs:265:1: 292:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "pub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:823 ~ rust[fc84]::src::version_etc::version_etc)",
        "span": "src/version_etc.rs:303:5: 303:82 (#0)",
        "source": "version_etc_va(stream, command_name, package, version, authors.as_va_list());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:823 ~ rust[fc84]::src::version_etc::version_etc)",
    "span": "src/version_etc.rs:294:1: 304:2 (#0)",
    "pieces": [
      "src/version_etc.rs:294:1: 304:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:10 ~ rust[fc84]::src::c_ctype::c_isalnum)",
    "span": "src/c_ctype.rs:5:1: 14:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:5:1: 14:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:678 ~ rust[fc84]::src::quotearg::mbszero)",
    "span": "src/quotearg.rs:108:1: 114:2 (#0)",
    "pieces": [
      "src/quotearg.rs:108:1: 114:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:167 ~ rust[fc84]::src::ialloc::irealloc)",
    "span": "src/ialloc.rs:61:1: 71:2 (#0)",
    "pieces": [
      "src/ialloc.rs:61:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:767 ~ rust[fc84]::src::same_inode::psame_inode)",
    "span": "src/same_inode.rs:42:1: 44:2 (#0)",
    "pieces": [
      "src/same_inode.rs:42:1: 44:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn psame_inode(mut a: *const stat, mut b: *const stat) -> bool {\n    return (*a).st_dev ^ (*b).st_dev | (*a).st_ino ^ (*b).st_ino == 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/same_inode.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:711 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
    "span": "src/quotearg.rs:1429:1: 1436:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1429:1: 1436:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:713 ~ rust[fc84]::src::quotearg::quotearg_style)",
        "span": "src/quotearg.rs:1452:5: 1452:55 (#0)",
        "source": "return quotearg_n_style(0 as libc::c_int, s, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:695 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
    "span": "src/quotearg.rs:1227:1: 1233:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1227:1: 1233:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:76 ~ rust[fc84]::src::closeout::close_stdout_set_ignore_EPIPE)",
    "span": "src/closeout.rs:68:1: 70:2 (#0)",
    "pieces": [
      "src/closeout.rs:68:1: 70:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:66:1: 66:39 (#0)",
        "source": "static mut ignore_EPIPE: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:708 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
    "span": "src/quotearg.rs:1410:1: 1416:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1410:1: 1416:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:710 ~ rust[fc84]::src::quotearg::quotearg_mem)",
        "span": "src/quotearg.rs:1426:5: 1426:59 (#0)",
        "source": "return quotearg_n_mem(0 as libc::c_int, arg, argsize);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:23 ~ rust[fc84]::src::c_ctype::c_tolower)",
    "span": "src/c_ctype.rs:156:1: 164:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:156:1: 164:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:724 ~ rust[fc84]::src::quotearg::quotearg_custom)",
    "span": "src/quotearg.rs:1549:1: 1555:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1549:1: 1555:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:102 ~ rust[fc84]::src::fclose::rpl_fclose)",
    "span": "src/fclose.rs:52:1: 72:2 (#0)",
    "pieces": [
      "src/fclose.rs:52:1: 72:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fclose.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:710 ~ rust[fc84]::src::quotearg::quotearg_mem)",
    "span": "src/quotearg.rs:1422:1: 1427:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1422:1: 1427:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:875 ~ rust[fc84]::src::xmalloc::ireallocarray)",
    "span": "src/xmalloc.rs:56:1: 76:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:56:1: 76:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:885 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:151:5: 151:50 (#0)",
        "source": "return check_nonnull(ireallocarray(p, n, s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:885 ~ rust[fc84]::src::xmalloc::xireallocarray)",
    "span": "src/xmalloc.rs:146:1: 152:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:146:1: 152:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}",
    "calls": [
      {
        "caller": "DefId(0:887 ~ rust[fc84]::src::xmalloc::xinmalloc)",
        "span": "src/xmalloc.rs:159:5: 159:57 (#0)",
        "source": "return xireallocarray(0 as *mut libc::c_void, n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:887 ~ rust[fc84]::src::xmalloc::xinmalloc)",
    "span": "src/xmalloc.rs:158:1: 160:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:158:1: 160:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:685 ~ rust[fc84]::src::quotearg::clone_quoting_options)",
    "span": "src/quotearg.rs:150:1: 164:2 (#0)",
    "pieces": [
      "src/quotearg.rs:150:1: 164:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:77 ~ rust[fc84]::src::closeout::close_stdout)",
    "span": "src/closeout.rs:72:1: 167:2 (#0)",
    "pieces": [
      "src/closeout.rs:72:1: 167:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:61:1: 61:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:17 ~ rust[fc84]::src::c_ctype::c_islower)",
    "span": "src/c_ctype.rs:89:1: 97:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:89:1: 97:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:12 ~ rust[fc84]::src::c_ctype::c_isascii)",
    "span": "src/c_ctype.rs:30:1: 43:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:30:1: 43:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:694 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
    "span": "src/quotearg.rs:1199:1: 1225:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1199:1: 1225:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:819 ~ rust[fc84]::src::version_etc::version_etc_ar)",
    "span": "src/version_etc.rs:249:1: 263:2 (#0)",
    "pieces": [
      "src/version_etc.rs:249:1: 263:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:24 ~ rust[fc84]::src::c_ctype::c_toupper)",
    "span": "src/c_ctype.rs:168:1: 176:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:168:1: 176:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:880 ~ rust[fc84]::src::xmalloc::ximalloc)",
    "span": "src/xmalloc.rs:102:1: 104:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:102:1: 104:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}",
    "calls": [
      {
        "caller": "DefId(0:896 ~ rust[fc84]::src::xmalloc::ximemdup)",
        "span": "src/xmalloc.rs:931:5: 931:55 (#0)",
        "source": "return memcpy(ximalloc(s), p, s as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:897 ~ rust[fc84]::src::xmalloc::ximemdup0)",
        "span": "src/xmalloc.rs:938:5: 939:30 (#0)",
        "source": "let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:897 ~ rust[fc84]::src::xmalloc::ximemdup0)",
    "span": "src/xmalloc.rs:934:1: 943:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:934:1: 943:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:14 ~ rust[fc84]::src::c_ctype::c_iscntrl)",
    "span": "src/c_ctype.rs:53:1: 61:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:53:1: 61:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:842 ~ rust[fc84]::src::xalloc_die::xalloc_die)",
    "span": "src/xalloc_die.rs:14:1: 54:2 (#0)",
    "pieces": [
      "src/xalloc_die.rs:14:1: 54:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "pub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalloc_die.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:168 ~ rust[fc84]::src::ialloc::imalloc)",
    "span": "src/ialloc.rs:75:1: 81:2 (#0)",
    "pieces": [
      "src/ialloc.rs:75:1: 81:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:165 ~ rust[fc84]::src::ialloc::ireallocarray)",
    "span": "src/ialloc.rs:19:1: 39:2 (#0)",
    "pieces": [
      "src/ialloc.rs:19:1: 39:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:713 ~ rust[fc84]::src::quotearg::quotearg_style)",
    "span": "src/quotearg.rs:1448:1: 1453:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1448:1: 1453:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:717 ~ rust[fc84]::src::quotearg::quotearg_char)",
    "span": "src/quotearg.rs:1480:1: 1485:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1480:1: 1485:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}",
    "calls": [
      {
        "caller": "DefId(0:718 ~ rust[fc84]::src::quotearg::quotearg_colon)",
        "span": "src/quotearg.rs:1490:5: 1490:59 (#0)",
        "source": "return quotearg_char(arg, ':' as i32 as libc::c_char);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:718 ~ rust[fc84]::src::quotearg::quotearg_colon)",
    "span": "src/quotearg.rs:1487:1: 1491:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1487:1: 1491:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:896 ~ rust[fc84]::src::xmalloc::ximemdup)",
    "span": "src/xmalloc.rs:927:1: 932:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:927:1: 932:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:677 ~ rust[fc84]::src::quotearg::c32isprint)",
    "span": "src/quotearg.rs:104:1: 106:2 (#0)",
    "pieces": [
      "src/quotearg.rs:104:1: 106:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:889 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
    "span": "src/xmalloc.rs:169:1: 195:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:169:1: 195:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:888 ~ rust[fc84]::src::xmalloc::x2realloc)",
        "span": "src/xmalloc.rs:166:5: 166:58 (#0)",
        "source": "return x2nrealloc(p, ps, 1 as libc::c_int as size_t);"
      }
    ],
    "globals": [
      {
        "span": "src/xmalloc.rs:23:1: 23:47 (#0)",
        "source": "pub const DEFAULT_MXFAST: C2RustUnnamed = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:888 ~ rust[fc84]::src::xmalloc::x2realloc)",
    "span": "src/xmalloc.rs:162:1: 167:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:162:1: 167:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:139 ~ rust[fc84]::src::fseeko::rpl_fseeko)",
    "span": "src/fseeko.rs:50:1: 67:2 (#0)",
    "pieces": [
      "src/fseeko.rs:50:1: 67:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fseeko.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:689 ~ rust[fc84]::src::quotearg::set_quoting_flags)",
    "span": "src/quotearg.rs:215:1: 226:2 (#0)",
    "pieces": [
      "src/quotearg.rs:215:1: 226:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:148 ~ rust[fc84]::src::hard_locale::hard_locale)",
    "span": "src/hard_locale.rs:12:1: 30:2 (#0)",
    "pieces": [
      "src/hard_locale.rs:12:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hard_locale.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:618 ~ rust[fc84]::src::propername_lite::proper_name_lite)",
    "span": "src/propername_lite.rs:8:1: 24:2 (#0)",
    "pieces": [
      "src/propername_lite.rs:8:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/propername_lite.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:824 ~ rust[fc84]::src::version_etc::emit_bug_reporting_address)",
    "span": "src/version_etc.rs:306:1: 324:2 (#0)",
    "pieces": [
      "src/version_etc.rs:306:1: 324:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:609 ~ rust[fc84]::src::progname::set_program_name)",
    "span": "src/progname.rs:59:1: 96:2 (#0)",
    "pieces": [
      "src/progname.rs:59:1: 96:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "pub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/progname.rs:57:1: 57:77 (#0)",
        "source": "pub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/progname.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:892 ~ rust[fc84]::src::xmalloc::xizalloc)",
    "span": "src/xmalloc.rs:908:1: 910:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:908:1: 910:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:883 ~ rust[fc84]::src::xmalloc::xirealloc)",
    "span": "src/xmalloc.rs:127:1: 132:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:127:1: 132:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:48 ~ rust[fc84]::src::close_stream::close_stream)",
    "span": "src/close_stream.rs:50:1: 65:2 (#0)",
    "pieces": [
      "src/close_stream.rs:50:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/close_stream.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:121 ~ rust[fc84]::src::fflush::rpl_fflush)",
    "span": "src/fflush.rs:55:1: 61:2 (#0)",
    "pieces": [
      "src/fflush.rs:55:1: 61:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:166 ~ rust[fc84]::src::ialloc::icalloc)",
    "span": "src/ialloc.rs:43:1: 57:2 (#0)",
    "pieces": [
      "src/ialloc.rs:43:1: 57:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:11 ~ rust[fc84]::src::c_ctype::c_isalpha)",
    "span": "src/c_ctype.rs:18:1: 26:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:18:1: 26:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:730 ~ rust[fc84]::src::quotearg::quote)",
    "span": "src/quotearg.rs:1605:1: 1607:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1605:1: 1607:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:91 ~ pwd[5c92]::readdir_ignoring_dot_and_dotdot)",
    "span": "src/pwd.rs:335:1: 344:2 (#0)",
    "pieces": [
      "src/pwd.rs:335:1: 344:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "unsafe extern \"C\" fn readdir_ignoring_dot_and_dotdot(\n    mut dirp: *mut DIR,\n) -> *const dirent {\n    loop {\n        let mut dp: *const dirent = readdir(dirp);\n        if dp.is_null() || !dot_or_dotdot(((*dp).d_name).as_ptr()) {\n            return dp;\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:749:9: 749:52 (#0)",
        "source": "dp = readdir_ignoring_dot_and_dotdot(dirp);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:99 ~ pwd[5c92]::file_name_prepend)",
    "span": "src/pwd.rs:501:1: 537:2 (#0)",
    "pieces": [
      "src/pwd.rs:501:1: 537:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 37,
    "source": "unsafe extern \"C\" fn file_name_prepend(\n    mut p: *mut file_name,\n    mut s: *const libc::c_char,\n    mut s_len: size_t,\n) {\n    let mut n_free: size_t = ((*p).start).offset_from((*p).buf) as libc::c_long\n        as size_t;\n    if n_free < (1 as libc::c_int as libc::c_ulong).wrapping_add(s_len) {\n        let mut half: size_t = ((*p).n_alloc)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            .wrapping_add(s_len);\n        let mut q: *mut libc::c_char = xnmalloc(2 as libc::c_int as size_t, half)\n            as *mut libc::c_char;\n        let mut n_used: size_t = ((*p).n_alloc).wrapping_sub(n_free);\n        (*p)\n            .start = q\n            .offset((2 as libc::c_int as libc::c_ulong).wrapping_mul(half) as isize)\n            .offset(-(n_used as isize));\n        memcpy(\n            (*p).start as *mut libc::c_void,\n            ((*p).buf).offset(n_free as isize) as *const libc::c_void,\n            n_used,\n        );\n        free((*p).buf as *mut libc::c_void);\n        (*p).buf = q;\n        (*p).n_alloc = (2 as libc::c_int as libc::c_ulong).wrapping_mul(half);\n    }\n    (*p)\n        .start = ((*p).start)\n        .offset(-((1 as libc::c_int as libc::c_ulong).wrapping_add(s_len) as isize));\n    *((*p).start).offset(0 as libc::c_int as isize) = '/' as i32 as libc::c_char;\n    memcpy(\n        ((*p).start).offset(1 as libc::c_int as isize) as *mut libc::c_void,\n        s as *const libc::c_void,\n        s_len,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:104 ~ pwd[5c92]::robust_getcwd)",
        "span": "src/pwd.rs:1017:9: 1021:11 (#0)",
        "source": "file_name_prepend(\n            file_name,\n            b\"\\0\" as *const u8 as *const libc::c_char,\n            0 as libc::c_int as size_t,\n        );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:774:13: 778:15 (#0)",
        "source": "file_name_prepend(\n                file_name,\n                ((*dp).d_name).as_ptr(),\n                strlen(((*dp).d_name).as_ptr()),\n            );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:100 ~ pwd[5c92]::nth_parent)",
    "span": "src/pwd.rs:538:1: 555:2 (#0)",
    "pieces": [
      "src/pwd.rs:538:1: 555:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "unsafe extern \"C\" fn nth_parent(mut n: size_t) -> *mut libc::c_char {\n    let mut buf: *mut libc::c_char = xnmalloc(3 as libc::c_int as size_t, n)\n        as *mut libc::c_char;\n    let mut p: *mut libc::c_char = buf;\n    let mut i: size_t = 0 as libc::c_int as size_t;\n    while i < n {\n        memcpy(\n            p as *mut libc::c_void,\n            b\"../\\0\" as *const u8 as *const libc::c_char as *const libc::c_void,\n            3 as libc::c_int as libc::c_ulong,\n        );\n        p = p.offset(3 as libc::c_int as isize);\n        i = i.wrapping_add(1);\n        i;\n    }\n    *p.offset(-(1 as libc::c_int) as isize) = '\\0' as i32 as libc::c_char;\n    return buf;\n}",
    "calls": [
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:687:13: 692:15 (#0)",
        "source": "error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                quote(nth_parent(parent_height)),\n            );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:615:17: 622:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:665:17: 672:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:638:13: 643:15 (#0)",
        "source": "error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char),\n                quote(nth_parent(parent_height)),\n            );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:785:13: 790:15 (#0)",
        "source": "error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"reading directory %s\\0\" as *const u8 as *const libc::c_char),\n                quote(nth_parent(parent_height)),\n            );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:586:13: 593:15 (#0)",
        "source": "error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote(nth_parent(parent_height)),\n            );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:699:17: 704:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quote(nth_parent(parent_height)),\n                );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:812:17: 819:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"reading directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:829:13: 837:15 (#0)",
        "source": "error(\n                1 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"couldn't find directory entry in %s with matching i-node\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                quote(nth_parent(parent_height)),\n            );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:650:17: 657:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:712:17: 717:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quote(nth_parent(parent_height)),\n                );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:844:17: 852:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"couldn't find directory entry in %s with matching i-node\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:860:17: 868:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"couldn't find directory entry in %s with matching i-node\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:600:17: 607:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );"
      },
      {
        "caller": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
        "span": "src/pwd.rs:797:17: 804:19 (#0)",
        "source": "error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"reading directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:101 ~ pwd[5c92]::find_dir_entry)",
    "span": "src/pwd.rs:556:1: 877:2 (#0)",
    "pieces": [
      "src/pwd.rs:556:1: 877:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 322,
    "source": "unsafe extern \"C\" fn find_dir_entry(\n    mut dot_sb: *mut stat,\n    mut file_name: *mut file_name,\n    mut parent_height: size_t,\n) {\n    let mut dirp: *mut DIR = 0 as *mut DIR;\n    let mut fd: libc::c_int = 0;\n    let mut parent_sb: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut use_lstat: bool = false;\n    let mut found: bool = false;\n    dirp = opendir(b\"..\\0\" as *const u8 as *const libc::c_char);\n    if dirp.is_null() {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote(nth_parent(parent_height)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    fd = dirfd(dirp);\n    if (if 0 as libc::c_int <= fd {\n        fchdir(fd)\n    } else {\n        chdir(b\"..\\0\" as *const u8 as *const libc::c_char)\n    }) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char),\n                quote(nth_parent(parent_height)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to chdir to %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if (if 0 as libc::c_int <= fd {\n        fstat(fd, &mut parent_sb)\n    } else {\n        stat(b\".\\0\" as *const u8 as *const libc::c_char, &mut parent_sb)\n    }) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                quote(nth_parent(parent_height)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    use_lstat = parent_sb.st_dev != (*dot_sb).st_dev;\n    found = 0 as libc::c_int != 0;\n    loop {\n        let mut dp: *const dirent = 0 as *const dirent;\n        let mut ent_sb: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        let mut ino: ino_t = 0;\n        *__errno_location() = 0 as libc::c_int;\n        dp = readdir_ignoring_dot_and_dotdot(dirp);\n        if dp.is_null() {\n            if *__errno_location() != 0 {\n                let mut e: libc::c_int = *__errno_location();\n                closedir(dirp);\n                *__errno_location() = e;\n                dirp = 0 as *mut DIR;\n            }\n            break;\n        } else {\n            ino = (*dp).d_ino;\n            if ino == NOT_AN_INODE_NUMBER as libc::c_int as libc::c_ulong\n                || use_lstat as libc::c_int != 0\n            {\n                if lstat(((*dp).d_name).as_ptr(), &mut ent_sb) < 0 as libc::c_int {\n                    continue;\n                }\n                ino = ent_sb.st_ino;\n            }\n            if ino != (*dot_sb).st_ino {\n                continue;\n            }\n            if !(!use_lstat || ent_sb.st_dev == (*dot_sb).st_dev) {\n                continue;\n            }\n            file_name_prepend(\n                file_name,\n                ((*dp).d_name).as_ptr(),\n                strlen(((*dp).d_name).as_ptr()),\n            );\n            found = 1 as libc::c_int != 0;\n            break;\n        }\n    }\n    if dirp.is_null() || closedir(dirp) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"reading directory %s\\0\" as *const u8 as *const libc::c_char),\n                quote(nth_parent(parent_height)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"reading directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"reading directory %s\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if !found {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"couldn't find directory entry in %s with matching i-node\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                quote(nth_parent(parent_height)),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"couldn't find directory entry in %s with matching i-node\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"couldn't find directory entry in %s with matching i-node\\0\"\n                            as *const u8 as *const libc::c_char,\n                    ),\n                    quote(nth_parent(parent_height)),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    *dot_sb = parent_sb;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:97 ~ pwd[5c92]::file_name_free)",
    "span": "src/pwd.rs:478:1: 481:2 (#0)",
    "pieces": [
      "src/pwd.rs:478:1: 481:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn file_name_free(mut p: *mut file_name) {\n    free((*p).buf as *mut libc::c_void);\n    free(p as *mut libc::c_void);\n}",
    "calls": [
      {
        "caller": "DefId(0:109 ~ pwd[5c92]::main_0)",
        "span": "src/pwd.rs:1210:9: 1210:35 (#0)",
        "source": "file_name_free(file_name);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:104 ~ pwd[5c92]::robust_getcwd)",
    "span": "src/pwd.rs:878:1: 1023:2 (#0)",
    "pieces": [
      "src/pwd.rs:878:1: 1023:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 146,
    "source": "unsafe extern \"C\" fn robust_getcwd(mut file_name: *mut file_name) {\n    let mut height: size_t = 1 as libc::c_int as size_t;\n    let mut dev_ino_buf: dev_ino = dev_ino { st_ino: 0, st_dev: 0 };\n    let mut root_dev_ino: *mut dev_ino = get_root_dev_ino(&mut dev_ino_buf);\n    let mut dot_sb: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    if root_dev_ino.is_null() {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"failed to get attributes of %s\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"/\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to get attributes of %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"/\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to get attributes of %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"/\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if stat(b\".\\0\" as *const u8 as *const libc::c_char, &mut dot_sb) < 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\".\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\".\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\".\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    while !(dot_sb.st_dev ^ (*root_dev_ino).st_dev\n        | dot_sb.st_ino ^ (*root_dev_ino).st_ino == 0)\n    {\n        let fresh0 = height;\n        height = height.wrapping_add(1);\n        find_dir_entry(&mut dot_sb, file_name, fresh0);\n    }\n    if *((*file_name).start).offset(0 as libc::c_int as isize) as libc::c_int\n        == '\\0' as i32\n    {\n        file_name_prepend(\n            file_name,\n            b\"\\0\" as *const u8 as *const libc::c_char,\n            0 as libc::c_int as size_t,\n        );\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:109 ~ pwd[5c92]::main_0)",
        "span": "src/pwd.rs:1208:9: 1208:34 (#0)",
        "source": "robust_getcwd(file_name);"
      }
    ],
    "globals": [
      {
        "span": "src/pwd.rs:200:1: 200:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:98 ~ pwd[5c92]::file_name_init)",
    "span": "src/pwd.rs:482:1: 500:2 (#0)",
    "pieces": [
      "src/pwd.rs:482:1: 500:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn file_name_init() -> *mut file_name {\n    let mut p: *mut file_name = xmalloc(\n        ::core::mem::size_of::<file_name>() as libc::c_ulong,\n    ) as *mut file_name;\n    (*p)\n        .n_alloc = (if (2 as libc::c_int * 4096 as libc::c_int)\n        < 32 as libc::c_int * 1024 as libc::c_int\n    {\n        2 as libc::c_int * 4096 as libc::c_int\n    } else {\n        32 as libc::c_int * 1024 as libc::c_int\n    }) as size_t;\n    (*p).buf = xmalloc((*p).n_alloc) as *mut libc::c_char;\n    (*p)\n        .start = ((*p).buf)\n        .offset(((*p).n_alloc).wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize);\n    *((*p).start).offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:109 ~ pwd[5c92]::main_0)",
        "span": "src/pwd.rs:1207:9: 1207:62 (#0)",
        "source": "let mut file_name: *mut file_name = file_name_init();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:106 ~ pwd[5c92]::logical_getcwd)",
    "span": "src/pwd.rs:1024:1: 1091:2 (#0)",
    "pieces": [
      "src/pwd.rs:1024:1: 1091:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "unsafe extern \"C\" fn logical_getcwd() -> *mut libc::c_char {\n    let mut st1: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut st2: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut wd: *mut libc::c_char = getenv(b\"PWD\\0\" as *const u8 as *const libc::c_char);\n    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;\n    if wd.is_null() || *wd.offset(0 as libc::c_int as isize) as libc::c_int != '/' as i32\n    {\n        return 0 as *mut libc::c_char;\n    }\n    p = wd;\n    loop {\n        p = strstr(p, b\"/.\\0\" as *const u8 as *const libc::c_char);\n        if p.is_null() {\n            break;\n        }\n        if *p.offset(2 as libc::c_int as isize) == 0\n            || *p.offset(2 as libc::c_int as isize) as libc::c_int == '/' as i32\n            || *p.offset(2 as libc::c_int as isize) as libc::c_int == '.' as i32\n                && (*p.offset(3 as libc::c_int as isize) == 0\n                    || *p.offset(3 as libc::c_int as isize) as libc::c_int == '/' as i32)\n        {\n            return 0 as *mut libc::c_char;\n        }\n        p = p.offset(1);\n        p;\n    }\n    if stat(wd, &mut st1) == 0 as libc::c_int\n        && stat(b\".\\0\" as *const u8 as *const libc::c_char, &mut st2) == 0 as libc::c_int\n        && psame_inode(&mut st1, &mut st2) as libc::c_int != 0\n    {\n        return wd;\n    }\n    return 0 as *mut libc::c_char;\n}",
    "calls": [
      {
        "caller": "DefId(0:109 ~ pwd[5c92]::main_0)",
        "span": "src/pwd.rs:1196:9: 1196:31 (#0)",
        "source": "wd = logical_getcwd();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:88 ~ pwd[5c92]::emit_ancillary_info)",
    "span": "src/pwd.rs:219:1: 333:2 (#0)",
    "pieces": [
      "src/pwd.rs:219:1: 333:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 115,
    "source": "unsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:96 ~ pwd[5c92]::usage)",
        "span": "src/pwd.rs:474:9: 474:75 (#0)",
        "source": "emit_ancillary_info(b\"pwd\\0\" as *const u8 as *const libc::c_char);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:96 ~ pwd[5c92]::usage)",
    "span": "src/pwd.rs:410:1: 477:2 (#0)",
    "pieces": [
      "src/pwd.rs:410:1: 477:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 68,
    "source": "pub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(b\"Usage: %s [OPTION]...\\n\\0\" as *const u8 as *const libc::c_char),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Print the full filename of the current working directory.\\n\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -L, --logical   use PWD from environment, even if it contains symlinks\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -P, --physical  resolve all symlinks\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\nIf no option is specified, -P is assumed.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        printf(\n            gettext(\n                b\"\\nYour shell may have its own version of %s, which usually supersedes\\nthe version described here.  Please refer to your shell's documentation\\nfor details about the options it supports.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            b\"pwd\\0\" as *const u8 as *const libc::c_char,\n        );\n        emit_ancillary_info(b\"pwd\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}",
    "calls": [
      {
        "caller": "DefId(0:109 ~ pwd[5c92]::main_0)",
        "span": "src/pwd.rs:1145:17: 1145:41 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:109 ~ pwd[5c92]::main_0)",
        "span": "src/pwd.rs:1128:17: 1128:41 (#0)",
        "source": "usage(0 as libc::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:109 ~ pwd[5c92]::main_0)",
    "span": "src/pwd.rs:1092:1: 1213:2 (#0)",
    "pieces": [
      "src/pwd.rs:1092:1: 1213:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 122,
    "source": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut wd: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut logical: bool = !(getenv(\n        b\"POSIXLY_CORRECT\\0\" as *const u8 as *const libc::c_char,\n    ))\n        .is_null();\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    loop {\n        let mut c: libc::c_int = getopt_long(\n            argc,\n            argv,\n            b\"LP\\0\" as *const u8 as *const libc::c_char,\n            longopts.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if c == -(1 as libc::c_int) {\n            break;\n        }\n        match c {\n            76 => {\n                logical = 1 as libc::c_int != 0;\n            }\n            80 => {\n                logical = 0 as libc::c_int != 0;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"pwd\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                usage(1 as libc::c_int);\n            }\n        }\n    }\n    if optind < argc {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"ignoring non-option arguments\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"ignoring non-option arguments\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"ignoring non-option arguments\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if logical {\n        wd = logical_getcwd();\n        if !wd.is_null() {\n            puts(wd);\n            return 0 as libc::c_int;\n        }\n    }\n    wd = xgetcwd();\n    if !wd.is_null() {\n        puts(wd);\n        free(wd as *mut libc::c_void);\n    } else {\n        let mut file_name: *mut file_name = file_name_init();\n        robust_getcwd(file_name);\n        puts((*file_name).start);\n        file_name_free(file_name);\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:110 ~ pwd[5c92]::main)",
        "span": "src/pwd.rs:1224:5: 1231:6 (#0)",
        "source": "unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/pwd.rs:362:1: 408:3 (#0)",
        "source": "static mut longopts: [option; 5] = [\n    {\n        let mut init = option {\n            name: b\"logical\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'L' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"physical\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'P' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];"
      }
    ],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:110 ~ pwd[5c92]::main)",
    "span": "src/pwd.rs:1214:1: 1232:2 (#0)",
    "pieces": [
      "src/pwd.rs:1214:1: 1232:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:93 ~ pwd[5c92]::psame_inode)",
    "span": "src/pwd.rs:359:1: 361:2 (#0)",
    "pieces": [
      "src/pwd.rs:359:1: 361:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn psame_inode(mut a: *const stat, mut b: *const stat) -> bool {\n    return (*a).st_dev ^ (*b).st_dev | (*a).st_ino ^ (*b).st_ino == 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:92 ~ pwd[5c92]::dot_or_dotdot)",
    "span": "src/pwd.rs:346:1: 357:2 (#0)",
    "pieces": [
      "src/pwd.rs:346:1: 357:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn dot_or_dotdot(mut file_name: *const libc::c_char) -> bool {\n    if *file_name.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32 {\n        let mut sep: libc::c_char = *file_name\n            .offset(\n                ((*file_name.offset(1 as libc::c_int as isize) as libc::c_int\n                    == '.' as i32) as libc::c_int + 1 as libc::c_int) as isize,\n            );\n        return sep == 0 || sep as libc::c_int == '/' as i32;\n    } else {\n        return 0 as libc::c_int != 0\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/pwd.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  }
]