[
  {
    "func_defid": "DefId(0:29 ~ rust[fc84]::src::c_ctype::c_tolower)",
    "span": "src/c_ctype.rs:140:1: 145:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:140:1: 145:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:913 ~ rust[fc84]::src::xmalloc::_gl_alloc_nomem)",
    "span": "src/xmalloc.rs:115:1: 120:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:115:1: 120:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:1071 ~ rust[fc84]::src::xmalloc::ireallocarray)",
        "span": "src/xmalloc.rs:108:12: 110:6 (#0)",
        "source": "{\n        _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:1071 ~ rust[fc84]::src::xmalloc::ireallocarray)",
        "span": "src/xmalloc.rs:105:13: 105:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:911 ~ rust[fc84]::src::xmalloc::icalloc)",
    "span": "src/xmalloc.rs:67:1: 87:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:67:1: 87:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:915 ~ rust[fc84]::src::xmalloc::check_nonnull)",
    "span": "src/xmalloc.rs:137:1: 142:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:137:1: 142:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:1089 ~ rust[fc84]::src::xmalloc::xcalloc)",
        "span": "src/xmalloc.rs:1011:5: 1011:40 (#0)",
        "source": "return check_nonnull(calloc(n, s));"
      },
      {
        "caller": "DefId(0:1075 ~ rust[fc84]::src::xmalloc::xmalloc)",
        "span": "src/xmalloc.rs:146:5: 146:37 (#0)",
        "source": "return check_nonnull(malloc(s));"
      },
      {
        "caller": "DefId(0:1081 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:215:24: 218:2 (#0)",
        "source": "{\n    let result = ireallocarray(p, n.try_into().unwrap(), s.try_into().unwrap());\ncheck_nonnull(result)\n}"
      },
      {
        "caller": "DefId(0:1076 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:151:1: 151:33 (#0)",
        "source": "check_nonnull(allocated_memory);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:931 ~ rust[fc84]::src::xmalloc::xicalloc)",
    "span": "src/xmalloc.rs:1014:1: 1022:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1014:1: 1022:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:28 ~ rust[fc84]::src::c_ctype::c_isxdigit)",
    "span": "src/c_ctype.rs:133:1: 135:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:133:1: 135:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:20 ~ rust[fc84]::src::c_ctype::c_iscntrl)",
    "span": "src/c_ctype.rs:55:1: 61:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:55:1: 61:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:16 ~ rust[fc84]::src::c_ctype::c_isalnum)",
    "span": "src/c_ctype.rs:24:1: 29:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:24:1: 29:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:868 ~ rust[fc84]::src::xbinary_io::xset_binary_mode_error)",
    "span": "src/xbinary_io.rs:20:1: 25:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:20:1: 25:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "pub unsafe extern \"C\" fn xset_binary_mode_error() {}",
    "calls": [
      {
        "caller": "DefId(0:1004 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)",
        "span": "src/xbinary_io.rs:13:9: 13:34 (#0)",
        "source": "xset_binary_mode_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:914 ~ rust[fc84]::src::xmalloc::imalloc)",
    "span": "src/xmalloc.rs:123:1: 135:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:123:1: 135:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1076 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:150:5: 150:59 (#0)",
        "source": "let allocated_memory = imalloc(s.try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:917 ~ rust[fc84]::src::xmalloc::ximalloc)",
    "span": "src/xmalloc.rs:149:1: 153:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:149:1: 153:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:934 ~ rust[fc84]::src::xmalloc::ximemdup0)",
    "span": "src/xmalloc.rs:1039:1: 1045:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1039:1: 1045:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:729 ~ rust[fc84]::src::quotearg::gettext_quote)",
    "span": "src/quotearg.rs:281:1: 318:2 (#0)",
    "pieces": [
      "src/quotearg.rs:281:1: 318:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "unsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:836 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:370:21: 373:3 (#0)",
        "source": "let right_quote = gettext_quote(\n    \"'\",\n    quoting_style,\n);"
      },
      {
        "caller": "DefId(0:836 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:366:21: 369:3 (#0)",
        "source": "let left_quote = gettext_quote(\n    \"`\",\n    quoting_style,\n);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:730 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
    "span": "src/quotearg.rs:320:1: 1221:2 (#0)",
    "pieces": [
      "src/quotearg.rs:320:1: 1221:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 902,
    "source": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:836 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1162:41: 1174:10 (#0)",
        "source": "{\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        }"
      },
      {
        "caller": "DefId(0:839 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1303:5: 1313:7 (#0)",
        "source": "quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:836 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1191:13: 1201:15 (#0)",
        "source": "return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );"
      },
      {
        "caller": "DefId(0:849 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1422:9: 1432:11 (#0)",
        "source": "quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );"
      },
      {
        "caller": "DefId(0:839 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1290:5: 1301:58 (#0)",
        "source": "let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:849 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1402:5: 1412:7 (#0)",
        "source": "let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:837 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
        "span": "src/quotearg.rs:1239:13: 1251:6 (#0)",
        "source": "unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffersize.try_into().unwrap(),\n            arg.as_ptr(),\n            argsize.try_into().unwrap(),\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:89:1: 89:57 (#0)",
        "source": "pub const shell_always_quoting_style: quoting_style = 2;"
      },
      {
        "span": "src/quotearg.rs:87:1: 87:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/quotearg.rs:86:1: 86:46 (#0)",
        "source": "pub const c_quoting_style: quoting_style = 5;"
      },
      {
        "span": "src/quotearg.rs:94:1: 94:52 (#0)",
        "source": "pub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:743 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
    "span": "src/quotearg.rs:1358:1: 1436:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1358:1: 1436:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 79,
    "source": "unsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}",
    "calls": [
      {
        "caller": "DefId(0:870 ~ rust[fc84]::src::quotearg::quote_n_mem)",
        "span": "src/quotearg.rs:1669:5: 1669:76 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);"
      },
      {
        "caller": "DefId(0:851 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
        "span": "src/quotearg.rs:1455:5: 1458:6 (#0)",
        "source": "unsafe {\n        let options = &default_quoting_options; // Accessing mutable static requires unsafe\n        quotearg_n_options(n, arg.as_ptr(), argsize, options)\n    }"
      },
      {
        "caller": "DefId(0:863 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1575:18: 1582:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(\n            n,\n            arg_ptr,\n            u64::MAX,\n            &mut options,\n        )\n    }"
      },
      {
        "caller": "DefId(0:866 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1612:5: 1612:56 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut o);"
      },
      {
        "caller": "DefId(0:858 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1534:5: 1534:77 (#0)",
        "source": "return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);"
      },
      {
        "caller": "DefId(0:855 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1497:5: 1499:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr(), argsize, &o)\n    }"
      },
      {
        "caller": "DefId(0:854 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1484:5: 1486:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr(), u64::MAX, &o)\n    }"
      },
      {
        "caller": "DefId(0:850 ~ rust[fc84]::src::quotearg::quotearg_n)",
        "span": "src/quotearg.rs:1442:5: 1447:7 (#0)",
        "source": "return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1321:1: 1321:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:95:1: 95:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      },
      {
        "span": "src/quotearg.rs:1322:1: 1330:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:1331:1: 1333:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:745 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
    "span": "src/quotearg.rs:1450:1: 1459:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1450:1: 1459:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:853 ~ rust[fc84]::src::quotearg::quotearg_mem)",
        "span": "src/quotearg.rs:1475:1: 1475:36 (#0)",
        "source": "return quotearg_n_mem(0, arg_cstr);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:747 ~ rust[fc84]::src::quotearg::quotearg_mem)",
    "span": "src/quotearg.rs:1470:1: 1476:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1470:1: 1476:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:725 ~ rust[fc84]::src::quotearg::set_char_quoting)",
    "span": "src/quotearg.rs:215:1: 233:2 (#0)",
    "pieces": [
      "src/quotearg.rs:215:1: 233:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 30,
    "source": "pub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:863 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1572:5: 1572:56 (#0)",
        "source": "set_char_quoting(Some(&mut options), ':' as i8, 1);"
      },
      {
        "caller": "DefId(0:858 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1533:5: 1533:68 (#0)",
        "source": "let result = set_char_quoting(Some(&mut options), ch as i8, 1);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:728 ~ rust[fc84]::src::quotearg::quoting_options_from_style)",
    "span": "src/quotearg.rs:264:1: 279:2 (#0)",
    "pieces": [
      "src/quotearg.rs:264:1: 279:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}",
    "calls": [
      {
        "caller": "DefId(0:863 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1571:5: 1571:45 (#0)",
        "source": "options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:855 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1495:5: 1495:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:854 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1483:5: 1483:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:91:1: 91:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:757 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
    "span": "src/quotearg.rs:1559:1: 1585:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1559:1: 1585:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:91:1: 91:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:921 ~ rust[fc84]::src::xmalloc::xreallocarray)",
    "span": "src/xmalloc.rs:195:1: 208:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:195:1: 208:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1082 ~ rust[fc84]::src::xmalloc::xnmalloc)",
        "span": "src/xmalloc.rs:221:5: 221:78 (#0)",
        "source": "let result = xreallocarray(n.try_into().unwrap(), s.try_into().unwrap());"
      },
      {
        "caller": "DefId(0:1085 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
        "span": "src/xmalloc.rs:274:5: 274:69 (#0)",
        "source": "p = xreallocarray(n.try_into().unwrap(), s.try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:923 ~ rust[fc84]::src::xmalloc::xnmalloc)",
    "span": "src/xmalloc.rs:220:1: 226:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:220:1: 226:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:916 ~ rust[fc84]::src::xmalloc::xmalloc)",
    "span": "src/xmalloc.rs:145:1: 147:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:145:1: 147:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:918 ~ rust[fc84]::src::xmalloc::xcharalloc)",
    "span": "src/xmalloc.rs:155:1: 164:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:155:1: 164:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:919 ~ rust[fc84]::src::xmalloc::xrealloc)",
    "span": "src/xmalloc.rs:167:1: 182:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:167:1: 182:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:1086 ~ rust[fc84]::src::xmalloc::xpalloc)",
        "span": "src/xmalloc.rs:984:5: 984:61 (#0)",
        "source": "pa = xrealloc(pa as *mut libc::c_void, nbytes as usize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:927 ~ rust[fc84]::src::xmalloc::xpalloc)",
    "span": "src/xmalloc.rs:282:1: 987:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:282:1: 987:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 706,
    "source": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:49:1: 49:51 (#0)",
        "source": "pub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:723 ~ rust[fc84]::src::quotearg::get_quoting_style)",
    "span": "src/quotearg.rs:194:1: 200:2 (#0)",
    "pieces": [
      "src/quotearg.rs:194:1: 200:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:930 ~ rust[fc84]::src::xmalloc::xcalloc)",
    "span": "src/xmalloc.rs:1010:1: 1012:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1010:1: 1012:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:928 ~ rust[fc84]::src::xmalloc::xzalloc)",
    "span": "src/xmalloc.rs:989:1: 997:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:989:1: 997:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:838 ~ rust[fc84]::src::version_etc::version_etc_arn)",
    "span": "src/version_etc.rs:68:1: 250:2 (#0)",
    "pieces": [
      "src/version_etc.rs:68:1: 250:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 183,
    "source": "pub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:971 ~ rust[fc84]::src::version_etc::version_etc_va)",
        "span": "src/version_etc.rs:287:5: 294:7 (#0)",
        "source": "version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );"
      },
      {
        "caller": "DefId(0:970 ~ rust[fc84]::src::version_etc::version_etc_ar)",
        "span": "src/version_etc.rs:265:5: 265:81 (#0)",
        "source": "version_etc_arn(stream, command_name, package, version, authors, n_authors);"
      }
    ],
    "globals": [
      {
        "span": "src/version_etc.rs:65:1: 65:48 (#0)",
        "source": "pub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;"
      }
    ],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:840 ~ rust[fc84]::src::version_etc::version_etc_va)",
    "span": "src/version_etc.rs:268:1: 295:2 (#0)",
    "pieces": [
      "src/version_etc.rs:268:1: 295:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "pub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:974 ~ rust[fc84]::src::version_etc::version_etc)",
        "span": "src/version_etc.rs:306:5: 306:82 (#0)",
        "source": "version_etc_va(stream, command_name, package, version, authors.as_va_list());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:843 ~ rust[fc84]::src::version_etc::version_etc)",
    "span": "src/version_etc.rs:297:1: 307:2 (#0)",
    "pieces": [
      "src/version_etc.rs:297:1: 307:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:2:1: 2:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:752 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
    "span": "src/quotearg.rs:1520:1: 1535:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1520:1: 1535:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}",
    "calls": [
      {
        "caller": "DefId(0:862 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
        "span": "src/quotearg.rs:1554:41: 1554:114 (#0)",
        "source": "unsafe { quotearg_char_mem(arg.as_ptr(), argsize, ':' as i32 as c_char) }"
      },
      {
        "caller": "DefId(0:860 ~ rust[fc84]::src::quotearg::quotearg_char)",
        "span": "src/quotearg.rs:1539:5: 1541:6 (#0)",
        "source": "unsafe {\n        quotearg_char_mem(arg.as_ptr(), 18446744073709551615 as libc::c_ulong, ch_as_c_char)\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:91:1: 91:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:754 ~ rust[fc84]::src::quotearg::quotearg_char)",
    "span": "src/quotearg.rs:1537:1: 1542:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1537:1: 1542:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}",
    "calls": [
      {
        "caller": "DefId(0:861 ~ rust[fc84]::src::quotearg::quotearg_colon)",
        "span": "src/quotearg.rs:1547:5: 1547:41 (#0)",
        "source": "let result = quotearg_char(arg, ch);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:744 ~ rust[fc84]::src::quotearg::quotearg_n)",
    "span": "src/quotearg.rs:1438:1: 1448:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1438:1: 1448:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:852 ~ rust[fc84]::src::quotearg::quotearg)",
        "span": "src/quotearg.rs:1465:22: 1465:55 (#0)",
        "source": "unsafe { quotearg_n(n, arg_ptr) }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:867 ~ rust[fc84]::src::xbinary_io::xset_binary_mode)",
    "span": "src/xbinary_io.rs:10:1: 15:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:10:1: 15:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:142 ~ rust[fc84]::src::fpurge::fpurge)",
    "span": "src/fpurge.rs:47:1: 50:2 (#0)",
    "pieces": [
      "src/fpurge.rs:47:1: 50:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn fpurge(mut fp: *mut FILE) -> libc::c_int {\n    __fpurge(fp);\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fpurge.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:910 ~ rust[fc84]::src::xmalloc::irealloc)",
    "span": "src/xmalloc.rs:52:1: 64:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:52:1: 64:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:920 ~ rust[fc84]::src::xmalloc::xirealloc)",
    "span": "src/xmalloc.rs:185:1: 192:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:185:1: 192:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:199 ~ rust[fc84]::src::ialloc::_gl_alloc_nomem)",
    "span": "src/ialloc.rs:110:1: 115:2 (#0)",
    "pieces": [
      "src/ialloc.rs:110:1: 115:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:6:1: 6:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:196 ~ rust[fc84]::src::ialloc::icalloc)",
    "span": "src/ialloc.rs:58:1: 73:2 (#0)",
    "pieces": [
      "src/ialloc.rs:58:1: 73:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:4:1: 4:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:912 ~ rust[fc84]::src::xmalloc::ireallocarray)",
    "span": "src/xmalloc.rs:90:1: 111:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:90:1: 111:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:1081 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:216:5: 216:81 (#0)",
        "source": "let result = ireallocarray(p, n.try_into().unwrap(), s.try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:922 ~ rust[fc84]::src::xmalloc::xireallocarray)",
    "span": "src/xmalloc.rs:211:1: 218:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:211:1: 218:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:924 ~ rust[fc84]::src::xmalloc::xinmalloc)",
    "span": "src/xmalloc.rs:228:1: 237:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:228:1: 237:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:741 ~ rust[fc84]::src::quotearg::quotearg_free)",
    "span": "src/quotearg.rs:1335:1: 1356:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1335:1: 1356:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:1331:1: 1333:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1320:1: 1320:50 (#0)",
        "source": "static mut slot0: [libc::c_char; 256] = [0; 256];"
      },
      {
        "span": "src/quotearg.rs:1321:1: 1321:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:1322:1: 1330:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:749 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
    "span": "src/quotearg.rs:1490:1: 1500:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1490:1: 1500:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:857 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
        "span": "src/quotearg.rs:1515:5: 1515:50 (#0)",
        "source": "let result = quotearg_n_style_mem(0, s, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:751 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
    "span": "src/quotearg.rs:1511:1: 1517:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1511:1: 1517:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:839 ~ rust[fc84]::src::version_etc::version_etc_ar)",
    "span": "src/version_etc.rs:252:1: 266:2 (#0)",
    "pieces": [
      "src/version_etc.rs:252:1: 266:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:2:1: 2:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:790 ~ rust[fc84]::src::setlocale_null::setlocale_null)",
    "span": "src/setlocale_null.rs:28:1: 37:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:28:1: 37:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:10 ~ rust[fc84]::src::binary_io::__gl_setmode)",
    "span": "src/binary_io.rs:15:1: 17:2 (#0)",
    "pieces": [
      "src/binary_io.rs:15:1: 17:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:12 ~ rust[fc84]::src::binary_io::set_binary_mode)",
        "span": "src/binary_io.rs:8:51: 10:2 (#0)",
        "source": "{\n    __gl_setmode(fd, mode)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/binary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/binary_io.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:9 ~ rust[fc84]::src::binary_io::set_binary_mode)",
    "span": "src/binary_io.rs:8:1: 10:2 (#0)",
    "pieces": [
      "src/binary_io.rs:8:1: 10:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/binary_io.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/binary_io.rs:2:1: 2:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:967 ~ rust[fc84]::src::xstrtoumax::bkm_scale)",
    "span": "src/xstrtoumax.rs:40:1: 436:2 (#0)",
    "pieces": [
      "src/xstrtoumax.rs:40:1: 436:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 397,
    "source": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut uintmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: uintmax_t = 0;\n    if if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t\n        && (if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_ulong } else { *x })\n            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            < 0 as libc::c_int as libc::c_ulong\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_ulong {\n                if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        -(1 as libc::c_int) as uintmax_t\n                    })\n                        .wrapping_add(scale_factor as libc::c_ulong)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    (*x\n                        < (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(scale_factor as libc::c_ulong)) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(-(1 as libc::c_int) as uintmax_t)\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (-(1 as libc::c_int) as uintmax_t)\n                            .wrapping_div(-scale_factor as libc::c_ulong)\n                    }) <= (-(1 as libc::c_int) as libc::c_ulong).wrapping_sub(*x))\n                        as libc::c_int\n                }\n            } else {\n                if (if (if (if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_ulong\n                } else {\n                    ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                })\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    < 0 as libc::c_int as libc::c_ulong\n                {\n                    !((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                }) < 0 as libc::c_int as libc::c_ulong\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_ulong)\n                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                        < (if (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_ulong)\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            < 0 as libc::c_int as libc::c_ulong\n                        {\n                            ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                << (::core::mem::size_of::<libc::c_ulong>()\n                                    as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        })\n                            .wrapping_neg()) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_ulong)\n                        < ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_ulong)\n                            .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        *x\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (*x).wrapping_add(0 as libc::c_int as uintmax_t))\n                            as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong) < *x\n                            && (-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (*x).wrapping_sub(1 as libc::c_int as libc::c_ulong))\n                            as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_ulong {\n                    if (if (if (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_ulong\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                    })\n                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        < 0 as libc::c_int as libc::c_ulong\n                    {\n                        !((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            << (::core::mem::size_of::<libc::c_ulong>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)\n                        })\n                            .wrapping_add(0 as libc::c_int as libc::c_ulong)\n                    }) < 0 as libc::c_int as libc::c_ulong\n                    {\n                        ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_ulong\n                        } else {\n                            *x\n                        })\n                            .wrapping_add(0 as libc::c_int as uintmax_t)\n                            < (if (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    *x\n                                })\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)\n                            })\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                < 0 as libc::c_int as libc::c_ulong\n                            {\n                                ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                    << (::core::mem::size_of::<libc::c_ulong>()\n                                        as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_ulong\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_ulong\n                                    } else {\n                                        *x\n                                    })\n                                        .wrapping_add(0 as libc::c_int as uintmax_t)\n                                })\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                            })\n                                .wrapping_neg()) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_ulong)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_ulong\n                            } else {\n                                *x\n                            })\n                                .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_ulong\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_ulong)\n                                < (scale_factor as libc::c_ulong)\n                                    .wrapping_add(0 as libc::c_int as uintmax_t)) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_ulong)\n                                .wrapping_sub(0 as libc::c_int as uintmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_ulong)\n                                as libc::c_int\n                        }\n                    } else {\n                        ((0 as libc::c_int as uintmax_t).wrapping_div(*x)\n                            < scale_factor as libc::c_ulong) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as uintmax_t)\n                        .wrapping_div(scale_factor as libc::c_ulong) < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.try_into().unwrap());\n        *(&mut scaled as *mut uintmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_ulong {\n            !if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n                -(1 as libc::c_int) as uintmax_t\n            } else {\n                ((1 as libc::c_int as uintmax_t)\n                    << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            }\n        } else if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n            -(1 as libc::c_int) as uintmax_t\n        } else {\n            ((1 as libc::c_int as uintmax_t)\n                << (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                .wrapping_mul(2 as libc::c_int as libc::c_ulong)\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}",
    "calls": [
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:570:17: 570:69 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);"
      },
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:600:17: 600:66 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 2 as libc::c_int);"
      },
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:567:17: 567:68 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 512 as libc::c_int);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoumax.rs:25:1: 25:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoumax.rs:26:1: 26:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoumax.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:968 ~ rust[fc84]::src::xstrtoumax::bkm_scale_by_power)",
    "span": "src/xstrtoumax.rs:437:1: 450:2 (#0)",
    "pieces": [
      "src/xstrtoumax.rs:437:1: 450:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut uintmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}",
    "calls": [
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:594:17: 594:74 (#0)",
        "source": "let mut overflow = bkm_scale_by_power(&mut tmp, base, 9);"
      },
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:591:17: 591:75 (#0)",
        "source": "let mut overflow = bkm_scale_by_power(&mut tmp, base, 10);"
      },
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:576:17: 576:74 (#0)",
        "source": "let mut overflow = bkm_scale_by_power(&mut tmp, base, 6);"
      },
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:588:17: 588:74 (#0)",
        "source": "let mut overflow = bkm_scale_by_power(&mut tmp, base, 5);"
      },
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:606:17: 606:74 (#0)",
        "source": "let mut overflow = bkm_scale_by_power(&mut tmp, base, 7);"
      },
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:579:17: 579:74 (#0)",
        "source": "let mut overflow = bkm_scale_by_power(&mut tmp, base, 3);"
      },
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:582:17: 582:74 (#0)",
        "source": "let mut overflow = bkm_scale_by_power(&mut tmp, base, 1);"
      },
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:597:17: 597:74 (#0)",
        "source": "let mut overflow = bkm_scale_by_power(&mut tmp, base, 4);"
      },
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:585:17: 585:74 (#0)",
        "source": "let mut overflow = bkm_scale_by_power(&mut tmp, base, 2);"
      },
      {
        "caller": "DefId(0:1128 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
        "span": "src/xstrtoumax.rs:603:17: 603:74 (#0)",
        "source": "let mut overflow = bkm_scale_by_power(&mut tmp, base, 8);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoumax.rs:26:1: 26:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoumax.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:160 ~ rust[fc84]::src::fseeko::rpl_fseeko)",
    "span": "src/fseeko.rs:52:1: 74:2 (#0)",
    "pieces": [
      "src/fseeko.rs:52:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fseeko.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fseeko.rs:1:1: 1:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:808 ~ rust[fc84]::src::umaxtostr::umaxtostr)",
    "span": "src/umaxtostr.rs:7:1: 36:2 (#0)",
    "pieces": [
      "src/umaxtostr.rs:7:1: 36:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 50,
    "source": "pub unsafe extern \"C\" fn umaxtostr(\n    mut i: uintmax_t,\n    mut buf: *mut libc::c_char,\n) -> *mut libc::c_char {\n    let mut p: *mut libc::c_char = buf\n        .offset(\n            (::core::mem::size_of::<uintmax_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(\n                    !((0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t)\n                        as libc::c_int as libc::c_ulong,\n                )\n                .wrapping_mul(146 as libc::c_int as libc::c_ulong)\n                .wrapping_add(484 as libc::c_int as libc::c_ulong)\n                .wrapping_div(485 as libc::c_int as libc::c_ulong)\n                .wrapping_add(\n                    !((0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t)\n                        as libc::c_int as libc::c_ulong,\n                ) as isize,\n        );\n    *p = 0 as libc::c_int as libc::c_char;\n    if i < 0 as libc::c_int as libc::c_ulong {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_ulong)\n                .wrapping_sub(i.wrapping_rem(10 as libc::c_int as libc::c_ulong))\n                as libc::c_char;\n            i = (i as libc::c_ulong).wrapping_div(10 as libc::c_int as libc::c_ulong)\n                as uintmax_t as uintmax_t;\n            if !(i != 0 as libc::c_int as libc::c_ulong) {\n                break;\n            }\n        }\n        p = p.offset(-1);\n        *p = '-' as i32 as libc::c_char;\n    } else {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_ulong)\n                .wrapping_add(i.wrapping_rem(10 as libc::c_int as libc::c_ulong))\n                as libc::c_char;\n            i = (i as libc::c_ulong).wrapping_div(10 as libc::c_int as libc::c_ulong)\n                as uintmax_t as uintmax_t;\n            if !(i != 0 as libc::c_int as libc::c_ulong) {\n                break;\n            }\n        }\n    }\n    return p;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/umaxtostr.rs:1:1: 1:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/umaxtostr.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:727 ~ rust[fc84]::src::quotearg::set_custom_quoting)",
    "span": "src/quotearg.rs:252:1: 262:2 (#0)",
    "pieces": [
      "src/quotearg.rs:252:1: 262:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}",
    "calls": [
      {
        "caller": "DefId(0:866 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1611:5: 1611:95 (#0)",
        "source": "set_custom_quoting(Some(&mut o), CStr::from_ptr(left_quote), CStr::from_ptr(right_quote));"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:81:1: 81:52 (#0)",
        "source": "pub const custom_quoting_style: quoting_style = 10;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:760 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
    "span": "src/quotearg.rs:1603:1: 1613:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1603:1: 1613:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}",
    "calls": [
      {
        "caller": "DefId(0:865 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
        "span": "src/quotearg.rs:1594:5: 1600:7 (#0)",
        "source": "return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );"
      },
      {
        "caller": "DefId(0:868 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
        "span": "src/quotearg.rs:1641:5: 1649:6 (#0)",
        "source": "unsafe {\n        quotearg_n_custom_mem(\n            0,\n            left_quote.as_ptr(),\n            right_quote.as_ptr(),\n            arg.as_ptr(),\n            argsize,\n        )\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:759 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
    "span": "src/quotearg.rs:1588:1: 1601:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1588:1: 1601:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:867 ~ rust[fc84]::src::quotearg::quotearg_custom)",
        "span": "src/quotearg.rs:1626:9: 1626:106 (#0)",
        "source": "result_ptr = quotearg_n_custom(0, left_quote_c.as_ptr(), right_quote_c.as_ptr(), arg_c.as_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:761 ~ rust[fc84]::src::quotearg::quotearg_custom)",
    "span": "src/quotearg.rs:1615:1: 1632:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1615:1: 1632:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:715 ~ rust[fc84]::src::quotearg::mbszero)",
    "span": "src/quotearg.rs:146:1: 150:2 (#0)",
    "pieces": [
      "src/quotearg.rs:146:1: 150:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:870 ~ rust[fc84]::src::xbinary_io::__gl_setmode)",
    "span": "src/xbinary_io.rs:33:1: 35:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:33:1: 35:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:1006 ~ rust[fc84]::src::xbinary_io::set_binary_mode)",
        "span": "src/xbinary_io.rs:28:47: 30:2 (#0)",
        "source": "{\n    __gl_setmode(fd, mode)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:869 ~ rust[fc84]::src::xbinary_io::set_binary_mode)",
    "span": "src/xbinary_io.rs:28:1: 30:2 (#0)",
    "pieces": [
      "src/xbinary_io.rs:28:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xbinary_io.rs:4:1: 4:32 (#0)",
        "source": "use std::os::unix::io::AsRawFd;"
      },
      {
        "span": "src/xbinary_io.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:30 ~ rust[fc84]::src::c_ctype::c_toupper)",
    "span": "src/c_ctype.rs:150:1: 155:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:150:1: 155:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:789 ~ rust[fc84]::src::setlocale_null::setlocale_null_r)",
    "span": "src/setlocale_null.rs:15:1: 25:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:15:1: 25:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/setlocale_null.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:764 ~ rust[fc84]::src::quotearg::quote_n_mem)",
    "span": "src/quotearg.rs:1664:1: 1670:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1664:1: 1670:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:871 ~ rust[fc84]::src::quotearg::quote_mem)",
        "span": "src/quotearg.rs:1675:9: 1675:83 (#0)",
        "source": "let result = quote_n_mem(0, arg.as_ptr() as *const libc::c_char, argsize);"
      },
      {
        "caller": "DefId(0:872 ~ rust[fc84]::src::quotearg::quote_n)",
        "span": "src/quotearg.rs:1683:5: 1683:55 (#0)",
        "source": "unsafe { quote_n_mem(n, arg.as_ptr(), max_value) }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1653:1: 1662:3 (#0)",
        "source": "pub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:765 ~ rust[fc84]::src::quotearg::quote_mem)",
    "span": "src/quotearg.rs:1672:1: 1678:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1672:1: 1678:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:21 ~ rust[fc84]::src::c_ctype::c_isdigit)",
    "span": "src/c_ctype.rs:66:1: 68:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:66:1: 68:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:889 ~ rust[fc84]::src::xdectoumax::xnumtoumax)",
    "span": "src/xdectoumax.rs:49:1: 91:2 (#0)",
    "pieces": [
      "src/xdectoumax.rs:49:1: 91:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn xnumtoumax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: uintmax_t = 0;\n    s_err = xstrtoumax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_ulong {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}",
    "calls": [
      {
        "caller": "DefId(0:1025 ~ rust[fc84]::src::xdectoumax::xdectoumax)",
        "span": "src/xdectoumax.rs:37:5: 45:3 (#0)",
        "source": "let result = xnumtoumax(\n    std::ffi::CStr::from_ptr(n_str).to_str().unwrap(),\n    10,\n    min,\n    max,\n    suffixes,\n    err,\n    err_exit,\n);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xdectoumax.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:888 ~ rust[fc84]::src::xdectoumax::xdectoumax)",
    "span": "src/xdectoumax.rs:29:1: 47:2 (#0)",
    "pieces": [
      "src/xdectoumax.rs:29:1: 47:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xdectoumax(\n    mut n_str: *const libc::c_char,\n    mut min: uintmax_t,\n    mut max: uintmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> uintmax_t {\n    return xnumtoumax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xdectoumax.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:80 ~ rust[fc84]::src::closeout::close_stdout_set_file_name)",
    "span": "src/closeout.rs:69:1: 74:2 (#0)",
    "pieces": [
      "src/closeout.rs:69:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:67:1: 67:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:5:1: 5:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:3:1: 3:22 (#0)",
        "source": "use std::sync::Mutex;"
      },
      {
        "span": "src/closeout.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:844 ~ rust[fc84]::src::version_etc::emit_bug_reporting_address)",
    "span": "src/version_etc.rs:309:1: 324:2 (#0)",
    "pieces": [
      "src/version_etc.rs:309:1: 324:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:169 ~ rust[fc84]::src::full_read::full_read)",
    "span": "src/full_read.rs:10:1: 36:2 (#0)",
    "pieces": [
      "src/full_read.rs:10:1: 36:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn full_read(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    let mut total: size_t = 0 as libc::c_int as size_t;\n    let mut ptr: *mut libc::c_char = buf as *mut libc::c_char;\n    while count > 0 as libc::c_int as libc::c_ulong {\n        let mut n_rw: size_t = safe_read(fd, ptr as *mut libc::c_void, count);\n        if n_rw == -(1 as libc::c_int) as size_t {\n            break;\n        }\n        if n_rw == 0 as libc::c_int as libc::c_ulong {\n            *__errno_location() = 0 as libc::c_int;\n            break;\n        } else {\n            total = (total as libc::c_ulong).wrapping_add(n_rw) as size_t as size_t;\n            ptr = ptr.offset(n_rw as isize);\n            count = (count as libc::c_ulong).wrapping_sub(n_rw) as size_t as size_t;\n        }\n    }\n    return total;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/full_read.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/full_read.rs:1:1: 1:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:195 ~ rust[fc84]::src::ialloc::ireallocarray)",
    "span": "src/ialloc.rs:27:1: 53:2 (#0)",
    "pieces": [
      "src/ialloc.rs:27:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:16 (#0)",
        "source": "use std::alloc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:26 ~ rust[fc84]::src::c_ctype::c_isspace)",
    "span": "src/c_ctype.rs:116:1: 121:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:116:1: 121:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:655 ~ rust[fc84]::src::propername_lite::proper_name_lite)",
    "span": "src/propername_lite.rs:8:1: 24:2 (#0)",
    "pieces": [
      "src/propername_lite.rs:8:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/propername_lite.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:197 ~ rust[fc84]::src::ialloc::irealloc)",
    "span": "src/ialloc.rs:78:1: 87:2 (#0)",
    "pieces": [
      "src/ialloc.rs:78:1: 87:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:969 ~ rust[fc84]::src::xstrtoumax::xstrtoumax)",
    "span": "src/xstrtoumax.rs:453:1: 632:2 (#0)",
    "pieces": [
      "src/xstrtoumax.rs:453:1: 632:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 180,
    "source": "pub unsafe extern \"C\" fn xstrtoumax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut uintmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: uintmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 79],\n                &[libc::c_char; 79],\n            >(\n                b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2256: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 79],\n                    &[libc::c_char; 79],\n                >(\n                    b\"strtol_error xstrtoumax(const char *, char **, int, uintmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as uintmax_t) < -(1 as libc::c_int) as uintmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoumax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as uintmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xstrtoumax.rs:25:1: 25:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoumax.rs:22:1: 22:45 (#0)",
        "source": "pub const LONGINT_INVALID: strtol_error = 4;"
      },
      {
        "span": "src/xstrtoumax.rs:26:1: 26:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      },
      {
        "span": "src/xstrtoumax.rs:24:1: 24:57 (#0)",
        "source": "pub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoumax.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:126 ~ rust[fc84]::src::fflush::clear_ungetc_buffer_preserving_position)",
    "span": "src/fflush.rs:51:1: 55:2 (#0)",
    "pieces": [
      "src/fflush.rs:51:1: 55:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:167 ~ rust[fc84]::src::fflush::rpl_fflush)",
        "span": "src/fflush.rs:61:17: 61:60 (#0)",
        "source": "clear_ungetc_buffer_preserving_position(s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:1:1: 1:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/fflush.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:733 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
    "span": "src/quotearg.rs:1272:1: 1319:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1272:1: 1319:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}",
    "calls": [
      {
        "caller": "DefId(0:838 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
        "span": "src/quotearg.rs:1265:22: 1267:6 (#0)",
        "source": "unsafe {\n        quotearg_alloc_mem(arg_ptr, argsize.try_into().unwrap(), &mut size, o)\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:95:1: 95:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:732 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
    "span": "src/quotearg.rs:1258:1: 1269:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1258:1: 1269:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:646 ~ rust[fc84]::src::progname::set_program_name)",
    "span": "src/progname.rs:62:1: 89:2 (#0)",
    "pieces": [
      "src/progname.rs:62:1: 89:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "pub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/progname.rs:60:1: 60:77 (#0)",
        "source": "pub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/progname.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/progname.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/progname.rs:2:1: 2:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:862 ~ rust[fc84]::src::xalloc_die::xalloc_die)",
    "span": "src/xalloc_die.rs:16:1: 53:2 (#0)",
    "pieces": [
      "src/xalloc_die.rs:16:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "pub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalloc_die.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xalloc_die.rs:1:1: 1:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:766 ~ rust[fc84]::src::quotearg::quote_n)",
    "span": "src/quotearg.rs:1681:1: 1684:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1681:1: 1684:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:873 ~ rust[fc84]::src::quotearg::quote)",
        "span": "src/quotearg.rs:1687:49: 1689:2 (#0)",
        "source": "{\n    quote_n(0, arg)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:767 ~ rust[fc84]::src::quotearg::quote)",
    "span": "src/quotearg.rs:1687:1: 1689:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1687:1: 1689:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:617 ~ rust[fc84]::src::mbszero::mbszero)",
    "span": "src/mbszero.rs:27:1: 33:2 (#0)",
    "pieces": [
      "src/mbszero.rs:27:1: 33:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mbszero.rs:1:1: 1:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/mbszero.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:731 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
    "span": "src/quotearg.rs:1223:1: 1255:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1223:1: 1255:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:929 ~ rust[fc84]::src::xmalloc::xizalloc)",
    "span": "src/xmalloc.rs:1000:1: 1007:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1000:1: 1007:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:23 ~ rust[fc84]::src::c_ctype::c_islower)",
    "span": "src/c_ctype.rs:84:1: 89:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:84:1: 89:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:926 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
    "span": "src/xmalloc.rs:251:1: 280:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:251:1: 280:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:47:1: 47:47 (#0)",
        "source": "pub const DEFAULT_MXFAST: C2RustUnnamed = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:607 ~ rust[fc84]::src::mbrtoc32::mbszero)",
    "span": "src/mbrtoc32.rs:36:1: 42:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:36:1: 42:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:669 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
        "span": "src/mbrtoc32.rs:64:9: 64:21 (#0)",
        "source": "mbszero(ps);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:609 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
    "span": "src/mbrtoc32.rs:48:1: 78:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:48:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 31,
    "source": "pub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/mbrtoc32.rs:43:1: 46:3 (#0)",
        "source": "static mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};"
      }
    ],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:108 ~ rust[fc84]::src::fclose::rpl_fclose)",
    "span": "src/fclose.rs:54:1: 74:2 (#0)",
    "pieces": [
      "src/fclose.rs:54:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fclose.rs:1:19: 1:25 (#0)",
        "source": "c_long"
      },
      {
        "span": "src/fclose.rs:1:12: 1:17 (#0)",
        "source": "c_int"
      },
      {
        "span": "src/fclose.rs:1:1: 1:27 (#0)",
        "source": "use libc::{c_int, c_long};"
      },
      {
        "span": "src/fclose.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:800 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:19:1: 24:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:19:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:922 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
        "span": "src/setlocale_null_unlocked.rs:32:9: 32:52 (#0)",
        "source": "result = setlocale_null_unlocked(category);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:2:1: 2:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:18 ~ rust[fc84]::src::c_ctype::c_isascii)",
    "span": "src/c_ctype.rs:41:1: 43:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:41:1: 43:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:746 ~ rust[fc84]::src::quotearg::quotearg)",
    "span": "src/quotearg.rs:1462:1: 1467:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1462:1: 1467:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:932 ~ rust[fc84]::src::xmalloc::xmemdup)",
    "span": "src/xmalloc.rs:1025:1: 1029:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1025:1: 1029:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:935 ~ rust[fc84]::src::xmalloc::xstrdup)",
    "span": "src/xmalloc.rs:1048:1: 1051:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1048:1: 1051:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:722 ~ rust[fc84]::src::quotearg::clone_quoting_options)",
    "span": "src/quotearg.rs:187:1: 191:2 (#0)",
    "pieces": [
      "src/quotearg.rs:187:1: 191:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:35 ~ rust[fc84]::src::c_strcasecmp::c_tolower)",
    "span": "src/c_strcasecmp.rs:6:1: 11:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:6:1: 11:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:55 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:15:5: 15:54 (#0)",
        "source": "let c1 = s1.chars().map(|c| c_tolower(c as i32));"
      },
      {
        "caller": "DefId(0:55 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:16:5: 16:54 (#0)",
        "source": "let c2 = s2.chars().map(|c| c_tolower(c as i32));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:36 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
    "span": "src/c_strcasecmp.rs:14:1: 30:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:14:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "pub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_strcasecmp.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:762 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
    "span": "src/quotearg.rs:1635:1: 1650:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1635:1: 1650:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:198 ~ rust[fc84]::src::ialloc::imalloc)",
    "span": "src/ialloc.rs:92:1: 104:2 (#0)",
    "pieces": [
      "src/ialloc.rs:92:1: 104:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:4:1: 4:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:7:1: 7:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:755 ~ rust[fc84]::src::quotearg::quotearg_colon)",
    "span": "src/quotearg.rs:1545:1: 1549:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1545:1: 1549:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:726 ~ rust[fc84]::src::quotearg::set_quoting_flags)",
    "span": "src/quotearg.rs:236:1: 249:2 (#0)",
    "pieces": [
      "src/quotearg.rs:236:1: 249:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:756 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
    "span": "src/quotearg.rs:1552:1: 1556:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1552:1: 1556:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:25 ~ rust[fc84]::src::c_ctype::c_ispunct)",
    "span": "src/c_ctype.rs:104:1: 111:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:104:1: 111:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:925 ~ rust[fc84]::src::xmalloc::x2realloc)",
    "span": "src/xmalloc.rs:240:1: 248:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:240:1: 248:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:748 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
    "span": "src/quotearg.rs:1478:1: 1487:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1478:1: 1487:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:856 ~ rust[fc84]::src::quotearg::quotearg_style)",
        "span": "src/quotearg.rs:1508:1: 1508:41 (#0)",
        "source": "return quotearg_n_style(0, s, arg_cstr);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:178 ~ rust[fc84]::src::hard_locale::hard_locale)",
    "span": "src/hard_locale.rs:14:1: 32:2 (#0)",
    "pieces": [
      "src/hard_locale.rs:14:1: 32:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hard_locale.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hard_locale.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:19 ~ rust[fc84]::src::c_ctype::c_isblank)",
    "span": "src/c_ctype.rs:48:1: 50:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:48:1: 50:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:24 ~ rust[fc84]::src::c_ctype::c_isprint)",
    "span": "src/c_ctype.rs:94:1: 99:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:94:1: 99:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:801 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:26:1: 56:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:26:1: 56:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:2:1: 2:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:933 ~ rust[fc84]::src::xmalloc::ximemdup)",
    "span": "src/xmalloc.rs:1032:1: 1036:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1032:1: 1036:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:25:1: 25:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:20:1: 20:42 (#0)",
        "source": "use std::alloc::{alloc, dealloc, Layout};"
      },
      {
        "span": "src/xmalloc.rs:18:1: 18:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:20:34: 20:40 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:16 (#0)",
        "source": "use std::panic;"
      },
      {
        "span": "src/xmalloc.rs:23:5: 23:15 (#0)",
        "source": "std::panic"
      },
      {
        "span": "src/xmalloc.rs:20:25: 20:32 (#0)",
        "source": "dealloc"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/xmalloc.rs:20:18: 20:23 (#0)",
        "source": "alloc"
      },
      {
        "span": "src/xmalloc.rs:16:1: 16:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:82 ~ rust[fc84]::src::closeout::close_stdout_set_ignore_EPIPE)",
    "span": "src/closeout.rs:78:1: 82:2 (#0)",
    "pieces": [
      "src/closeout.rs:78:1: 82:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:76:1: 76:39 (#0)",
        "source": "static mut ignore_EPIPE: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/closeout.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:3:1: 3:22 (#0)",
        "source": "use std::sync::Mutex;"
      },
      {
        "span": "src/closeout.rs:5:1: 5:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:714 ~ rust[fc84]::src::quotearg::c32isprint)",
    "span": "src/quotearg.rs:141:1: 143:2 (#0)",
    "pieces": [
      "src/quotearg.rs:141:1: 143:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:750 ~ rust[fc84]::src::quotearg::quotearg_style)",
    "span": "src/quotearg.rs:1503:1: 1509:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1503:1: 1509:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:83 ~ rust[fc84]::src::closeout::close_stdout)",
    "span": "src/closeout.rs:85:1: 161:2 (#0)",
    "pieces": [
      "src/closeout.rs:85:1: 161:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:67:1: 67:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:3:1: 3:22 (#0)",
        "source": "use std::sync::Mutex;"
      },
      {
        "span": "src/closeout.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/closeout.rs:7:1: 7:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/closeout.rs:5:1: 5:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:780 ~ rust[fc84]::src::safe_read::safe_read)",
    "span": "src/safe_read.rs:15:1: 41:2 (#0)",
    "pieces": [
      "src/safe_read.rs:15:1: 41:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 23,
    "source": "pub unsafe extern \"C\" fn safe_read(\n    mut fd: libc::c_int,\n    mut buf: *mut libc::c_void,\n    mut count: size_t,\n) -> size_t {\n    loop {\n        let mut result: ssize_t = read(fd, buf, count);\n        if 0 as libc::c_int as libc::c_long <= result {\n            return result as size_t\n        } else {\n            if *__errno_location() == 4 as libc::c_int {\n                continue;\n            }\n            if *__errno_location() == 22 as libc::c_int\n                && (SYS_BUFSIZE_MAX as libc::c_int as libc::c_ulong) < count\n            {\n                count = SYS_BUFSIZE_MAX as libc::c_int as size_t;\n            } else {\n                return result as size_t\n            }\n        }\n    };\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/safe_read.rs:12:1: 12:55 (#0)",
        "source": "pub const SYS_BUFSIZE_MAX: C2RustUnnamed = 2146435072;"
      }
    ],
    "imports": [
      {
        "span": "src/safe_read.rs:2:1: 2:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/safe_read.rs:1:1: 1:13 (#0)",
        "source": "use std::io;"
      },
      {
        "span": "src/safe_read.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:591 ~ rust[fc84]::src::localcharset::locale_charset)",
    "span": "src/localcharset.rs:393:1: 408:2 (#0)",
    "pieces": [
      "src/localcharset.rs:393:1: 408:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/localcharset.rs:7:1: 7:39 (#0)",
        "source": "pub const CODESET: C2RustUnnamed = 14;"
      }
    ],
    "imports": [
      {
        "span": "src/localcharset.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/localcharset.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:17 ~ rust[fc84]::src::c_ctype::c_isalpha)",
    "span": "src/c_ctype.rs:34:1: 36:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:34:1: 36:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:127 ~ rust[fc84]::src::fflush::rpl_fflush)",
    "span": "src/fflush.rs:57:1: 67:2 (#0)",
    "pieces": [
      "src/fflush.rs:57:1: 67:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:1:1: 1:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/fflush.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:27 ~ rust[fc84]::src::c_ctype::c_isupper)",
    "span": "src/c_ctype.rs:126:1: 128:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:126:1: 128:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:22 ~ rust[fc84]::src::c_ctype::c_isgraph)",
    "span": "src/c_ctype.rs:73:1: 79:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:73:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:20:1: 20:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:16:1: 16:27 (#0)",
        "source": "use std::convert::TryFrom;"
      },
      {
        "span": "src/c_ctype.rs:18:1: 18:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/c_ctype.rs:14:1: 14:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/c_ctype.rs:12:1: 12:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:624 ~ rust[fc84]::src::offtostr::offtostr)",
    "span": "src/offtostr.rs:7:1: 35:2 (#0)",
    "pieces": [
      "src/offtostr.rs:7:1: 35:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 46,
    "source": "pub unsafe extern \"C\" fn offtostr(\n    mut i: off_t,\n    mut buf: *mut libc::c_char,\n) -> *mut libc::c_char {\n    let mut p: *mut libc::c_char = buf\n        .offset(\n            (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                .wrapping_sub(\n                    !((0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t)\n                        as libc::c_int as libc::c_ulong,\n                )\n                .wrapping_mul(146 as libc::c_int as libc::c_ulong)\n                .wrapping_add(484 as libc::c_int as libc::c_ulong)\n                .wrapping_div(485 as libc::c_int as libc::c_ulong)\n                .wrapping_add(\n                    !((0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t)\n                        as libc::c_int as libc::c_ulong,\n                ) as isize,\n        );\n    *p = 0 as libc::c_int as libc::c_char;\n    if i < 0 as libc::c_int as libc::c_long {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_long - i % 10 as libc::c_int as libc::c_long)\n                as libc::c_char;\n            i /= 10 as libc::c_int as libc::c_long;\n            if !(i != 0 as libc::c_int as libc::c_long) {\n                break;\n            }\n        }\n        p = p.offset(-1);\n        *p = '-' as i32 as libc::c_char;\n    } else {\n        loop {\n            p = p.offset(-1);\n            *p = ('0' as i32 as libc::c_long + i % 10 as libc::c_int as libc::c_long)\n                as libc::c_char;\n            i /= 10 as libc::c_int as libc::c_long;\n            if !(i != 0 as libc::c_int as libc::c_long) {\n                break;\n            }\n        }\n    }\n    return p;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/offtostr.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/offtostr.rs:1:1: 1:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:724 ~ rust[fc84]::src::quotearg::set_quoting_style)",
    "span": "src/quotearg.rs:203:1: 212:2 (#0)",
    "pieces": [
      "src/quotearg.rs:203:1: 212:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:179:1: 185:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:25:1: 25:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/quotearg.rs:27:1: 27:21 (#0)",
        "source": "use std::boxed::Box;"
      },
      {
        "span": "src/quotearg.rs:33:1: 33:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:29:1: 29:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:21:1: 21:21 (#0)",
        "source": "use std::ops::Deref;"
      },
      {
        "span": "src/quotearg.rs:31:1: 31:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:23:1: 23:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:54 ~ rust[fc84]::src::close_stream::close_stream)",
    "span": "src/close_stream.rs:51:1: 65:2 (#0)",
    "pieces": [
      "src/close_stream.rs:51:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/close_stream.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:109 ~ head[91ec]::xset_binary_mode_error)",
    "span": "src/head.rs:373:1: 378:2 (#0)",
    "pieces": [
      "src/head.rs:373:1: 378:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "unsafe extern \"C\" fn xset_binary_mode_error() {}",
    "calls": [
      {
        "caller": "DefId(0:121 ~ head[91ec]::xset_binary_mode)",
        "span": "src/head.rs:384:13: 384:38 (#0)",
        "source": "xset_binary_mode_error();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:110 ~ head[91ec]::xset_binary_mode)",
    "span": "src/head.rs:381:1: 387:2 (#0)",
    "pieces": [
      "src/head.rs:381:1: 387:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn xset_binary_mode(mut fd: libc::c_int, mut mode: libc::c_int) {\n    if set_binary_mode(fd, mode) < 0 as libc::c_int {\n        xset_binary_mode_error();\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:159 ~ head[91ec]::main_0)",
        "span": "src/head.rs:2205:1: 2205:30 (#0)",
        "source": "xset_binary_mode(fd2, mode2);"
      },
      {
        "caller": "DefId(0:157 ~ head[91ec]::head_file)",
        "span": "src/head.rs:1758:1: 1758:30 (#0)",
        "source": "xset_binary_mode(fd1, mode1);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:101 ~ head[91ec]::emit_ancillary_info)",
    "span": "src/head.rs:271:1: 337:2 (#0)",
    "pieces": [
      "src/head.rs:271:1: 337:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 115,
    "source": "unsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:128 ~ head[91ec]::usage)",
        "span": "src/head.rs:532:9: 532:76 (#0)",
        "source": "emit_ancillary_info(CStr::from_bytes_with_nul(b\"head\\0\").unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:106 ~ head[91ec]::emit_mandatory_arg_note)",
    "span": "src/head.rs:355:1: 360:2 (#0)",
    "pieces": [
      "src/head.rs:355:1: 360:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_mandatory_arg_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nMandatory arguments to long options are mandatory for short options too.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:128 ~ head[91ec]::usage)",
        "span": "src/head.rs:502:9: 502:35 (#0)",
        "source": "emit_mandatory_arg_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:105 ~ head[91ec]::emit_stdin_note)",
    "span": "src/head.rs:348:1: 352:2 (#0)",
    "pieces": [
      "src/head.rs:348:1: 352:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_stdin_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nWith no FILE, or when FILE is -, read standard input.\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:128 ~ head[91ec]::usage)",
        "span": "src/head.rs:501:9: 501:27 (#0)",
        "source": "emit_stdin_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:117 ~ head[91ec]::usage)",
    "span": "src/head.rs:486:1: 535:2 (#0)",
    "pieces": [
      "src/head.rs:486:1: 535:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 73,
    "source": "pub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s [OPTION]... [FILE]...\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n        printf(\n            gettext(\n                b\"Print the first %d lines of each FILE to standard output.\\nWith more than one FILE, precede each with a header giving the file name.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            10 as libc::c_int,\n        );\n        emit_stdin_note();\n        emit_mandatory_arg_note();\n        printf(\n            gettext(\n                b\"  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\\n                             with the leading '-', print all but the last\\n                             NUM bytes of each file\\n  -n, --lines=[-]NUM       print the first NUM lines instead of the first %d;\\n                             with the leading '-', print all but the last\\n                             NUM lines of each file\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            10 as libc::c_int,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -q, --quiet, --silent    never print headers giving file names\\n  -v, --verbose            always print headers giving file names\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -z, --zero-terminated    line delimiter is NUL, not newline\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"\\nNUM may have a multiplier suffix:\\nb 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\\nGB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(b\"head\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}",
    "calls": [
      {
        "caller": "DefId(0:159 ~ head[91ec]::main_0)",
        "span": "src/head.rs:2054:17: 2054:26 (#0)",
        "source": "usage(0);"
      },
      {
        "caller": "DefId(0:159 ~ head[91ec]::main_0)",
        "span": "src/head.rs:2126:17: 2126:26 (#0)",
        "source": "usage(1);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:154 ~ head[91ec]::string_to_integer)",
    "span": "src/head.rs:1856:1: 1872:2 (#0)",
    "pieces": [
      "src/head.rs:1856:1: 1872:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "unsafe extern \"C\" fn string_to_integer(\n    mut count_lines: bool,\n    mut n_string: *const libc::c_char,\n) -> uintmax_t {\n    return xdectoumax(\n        n_string,\n        0 as libc::c_int as uintmax_t,\n        18446744073709551615 as libc::c_ulong,\n        b\"bkKmMGTPEZYRQ0\\0\" as *const u8 as *const libc::c_char,\n        if count_lines as libc::c_int != 0 {\n            gettext(b\"invalid number of lines\\0\" as *const u8 as *const libc::c_char)\n        } else {\n            gettext(b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char)\n        },\n        0 as libc::c_int,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:159 ~ head[91ec]::main_0)",
        "span": "src/head.rs:2042:17: 2042:66 (#0)",
        "source": "n_units = string_to_integer(count_lines, optarg);"
      },
      {
        "caller": "DefId(0:159 ~ head[91ec]::main_0)",
        "span": "src/head.rs:2033:17: 2033:66 (#0)",
        "source": "n_units = string_to_integer(count_lines, optarg);"
      },
      {
        "caller": "DefId(0:159 ~ head[91ec]::main_0)",
        "span": "src/head.rs:2003:9: 2003:60 (#0)",
        "source": "n_units = string_to_integer(count_lines, n_string);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:155 ~ head[91ec]::main_0)",
    "span": "src/head.rs:1873:1: 2257:2 (#0)",
    "pieces": [
      "src/head.rs:1873:1: 2257:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 383,
    "source": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut header_mode: header_mode = multiple_files;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut c: libc::c_int = 0;\n    let mut i: size_t = 0;\n    let mut n_units: uintmax_t = 10 as libc::c_int as uintmax_t;\n    let mut count_lines: bool = 1 as libc::c_int != 0;\n    let mut elide_from_end: bool = 0 as libc::c_int != 0;\n    static mut default_file_list: [*const libc::c_char; 2] = [\n        b\"-\\0\" as *const u8 as *const libc::c_char,\n        0 as *const libc::c_char,\n    ];\n    let mut file_list: *const *const libc::c_char = 0 as *const *const libc::c_char;\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    have_read_stdin = 0 as libc::c_int != 0;\n    print_headers = 0 as libc::c_int != 0;\n    line_end = '\\n' as i32 as libc::c_char;\n    if (1 as libc::c_int) < argc\n        && *(*argv.offset(1 as libc::c_int as isize)).offset(0 as libc::c_int as isize)\n            as libc::c_int == '-' as i32\n        && (*(*argv.offset(1 as libc::c_int as isize)).offset(1 as libc::c_int as isize)\n            as libc::c_uint)\n            .wrapping_sub('0' as i32 as libc::c_uint) <= 9 as libc::c_int as libc::c_uint\n    {\n        let mut a: *mut libc::c_char = *argv.offset(1 as libc::c_int as isize);\n        a = a.offset(1);\n        let mut n_string: *mut libc::c_char = a;\n        let mut end_n_string: *mut libc::c_char = 0 as *mut libc::c_char;\n        let mut multiplier_char: libc::c_char = 0 as libc::c_int as libc::c_char;\n        loop {\n            a = a.offset(1);\n            a;\n            if !((*a as libc::c_uint).wrapping_sub('0' as i32 as libc::c_uint)\n                <= 9 as libc::c_int as libc::c_uint)\n            {\n                break;\n            }\n        }\n        end_n_string = a;\n        while *a != 0 {\n            match *a as libc::c_int {\n                99 => {\n                    count_lines = 0 as libc::c_int != 0;\n                    multiplier_char = 0 as libc::c_int as libc::c_char;\n                }\n                98 | 107 | 109 => {\n                    count_lines = 0 as libc::c_int != 0;\n                    multiplier_char = *a;\n                }\n                108 => {\n                    count_lines = 1 as libc::c_int != 0;\n                }\n                113 => {\n                    header_mode = never;\n                }\n                118 => {\n                    header_mode = always;\n                }\n                122 => {\n                    line_end = '\\0' as i32 as libc::c_char;\n                }\n                _ => {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"invalid trailing option -- %c\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            *a as libc::c_int,\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid trailing option -- %c\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                *a as libc::c_int,\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid trailing option -- %c\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                *a as libc::c_int,\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    usage(1 as libc::c_int);\n                }\n            }\n            a = a.offset(1);\n            a;\n        }\n        *end_n_string = multiplier_char;\n        if multiplier_char != 0 {\n            end_n_string = end_n_string.offset(1);\n            *end_n_string = 0 as libc::c_int as libc::c_char;\n        }\n        n_units = string_to_integer(count_lines, n_string);\n        let ref mut fresh3 = *argv.offset(1 as libc::c_int as isize);\n        *fresh3 = *argv.offset(0 as libc::c_int as isize);\n        argv = argv.offset(1);\n        argv;\n        argc -= 1;\n        argc;\n    }\n    loop {\n        c = getopt_long(\n            argc,\n            argv,\n            b\"c:n:qvz0123456789\\0\" as *const u8 as *const libc::c_char,\n            long_options.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        match c {\n            256 => {\n                presume_input_pipe = 1 as libc::c_int != 0;\n            }\n            99 => {\n                count_lines = 0 as libc::c_int != 0;\n                elide_from_end = *optarg as libc::c_int == '-' as i32;\n                if elide_from_end {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                n_units = string_to_integer(count_lines, optarg);\n            }\n            110 => {\n                count_lines = 1 as libc::c_int != 0;\n                elide_from_end = *optarg as libc::c_int == '-' as i32;\n                if elide_from_end {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                n_units = string_to_integer(count_lines, optarg);\n            }\n            113 => {\n                header_mode = never;\n            }\n            118 => {\n                header_mode = always;\n            }\n            122 => {\n                line_end = '\\0' as i32 as libc::c_char;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"head\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                        b\"David MacKenzie\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    proper_name_lite(\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                        b\"Jim Meyering\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                if (c as libc::c_uint).wrapping_sub('0' as i32 as libc::c_uint)\n                    <= 9 as libc::c_int as libc::c_uint\n                {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"invalid trailing option -- %c\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            c,\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid trailing option -- %c\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                c,\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"invalid trailing option -- %c\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                                c,\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                usage(1 as libc::c_int);\n            }\n        }\n    }\n    if header_mode as libc::c_uint == always as libc::c_int as libc::c_uint\n        || header_mode as libc::c_uint == multiple_files as libc::c_int as libc::c_uint\n            && optind < argc - 1 as libc::c_int\n    {\n        print_headers = 1 as libc::c_int != 0;\n    }\n    if !count_lines && elide_from_end as libc::c_int != 0\n        && ((if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n            -(1 as libc::c_int) as off_t\n        } else {\n            (((1 as libc::c_int as off_t)\n                << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        }) as libc::c_ulong) < n_units\n    {\n        let mut umax_buf: [libc::c_char; 21] = [0; 21];\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                75 as libc::c_int,\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                gettext(\n                    b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote(umaxtostr(n_units, umax_buf.as_mut_ptr())),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    75 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(umaxtostr(n_units, umax_buf.as_mut_ptr())),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    75 as libc::c_int,\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    gettext(\n                        b\"invalid number of bytes\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote(umaxtostr(n_units, umax_buf.as_mut_ptr())),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    file_list = if optind < argc {\n        &mut *argv.offset(optind as isize) as *mut *mut libc::c_char\n            as *const *const libc::c_char\n    } else {\n        default_file_list.as_ptr()\n    };\n    xset_binary_mode(1 as libc::c_int, 0 as libc::c_int);\n    i = 0 as libc::c_int as size_t;\n    while !(*file_list.offset(i as isize)).is_null() {\n        ok = (ok as libc::c_int\n            & head_file(\n                *file_list.offset(i as isize),\n                n_units,\n                count_lines,\n                elide_from_end,\n            ) as libc::c_int) != 0;\n        i = i.wrapping_add(1);\n        i;\n    }\n    if have_read_stdin as libc::c_int != 0 && close(0 as libc::c_int) < 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                b\"-\\0\" as *const u8 as *const libc::c_char,\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    b\"-\\0\" as *const u8 as *const libc::c_char,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    return if ok as libc::c_int != 0 { 0 as libc::c_int } else { 1 as libc::c_int };\n}",
    "calls": [
      {
        "caller": "DefId(0:164 ~ head[91ec]::main)",
        "span": "src/head.rs:2271:18: 2271:64 (#0)",
        "source": "unsafe { main_0(argc, argv_ptr.as_mut_ptr()) }"
      }
    ],
    "globals": [
      {
        "span": "src/head.rs:391:1: 391:39 (#0)",
        "source": "static mut line_end: libc::c_char = 0;"
      },
      {
        "span": "src/head.rs:390:1: 390:40 (#0)",
        "source": "static mut print_headers: bool = false;"
      },
      {
        "span": "src/head.rs:393:1: 484:3 (#0)",
        "source": "static mut long_options: [option; 10] = [\n    {\n        let mut init = option {\n            name: b\"bytes\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"lines\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'n' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"-presume-input-pipe\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: PRESUME_INPUT_PIPE_OPTION as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"quiet\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"silent\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'q' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"verbose\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'v' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"zero-terminated\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'z' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];"
      },
      {
        "span": "src/head.rs:245:1: 245:34 (#0)",
        "source": "pub const never: header_mode = 2;"
      },
      {
        "span": "src/head.rs:389:1: 389:45 (#0)",
        "source": "static mut presume_input_pipe: bool = false;"
      },
      {
        "span": "src/head.rs:392:1: 392:42 (#0)",
        "source": "static mut have_read_stdin: bool = false;"
      },
      {
        "span": "src/head.rs:247:1: 247:43 (#0)",
        "source": "pub const multiple_files: header_mode = 0;"
      },
      {
        "span": "src/head.rs:246:1: 246:35 (#0)",
        "source": "pub const always: header_mode = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:140 ~ head[91ec]::elide_tail_lines_seekable)",
    "span": "src/head.rs:1338:1: 1434:2 (#0)",
    "pieces": [
      "src/head.rs:1338:1: 1434:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 189,
    "source": "unsafe extern \"C\" fn elide_tail_lines_seekable(\n    mut pretty_filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_lines: uintmax_t,\n    mut start_pos: off_t,\n    mut size: off_t,\n) -> bool {\n    let mut buffer: [libc::c_char; 8192] = [0; 8192];\n    let mut bytes_read: size_t = 0;\n    let mut pos: off_t = size;\n    bytes_read = ((pos - start_pos) % 8192 as libc::c_int as libc::c_long) as size_t;\n    if bytes_read == 0 as libc::c_int as libc::c_ulong {\n        bytes_read = 8192 as libc::c_int as size_t;\n    }\n    pos = (pos as libc::c_ulong).wrapping_sub(bytes_read) as off_t as off_t;\n    if elseek(fd, pos, 0 as libc::c_int, pretty_filename)\n        < 0 as libc::c_int as libc::c_long\n    {\n        return 0 as libc::c_int != 0;\n    }\n    bytes_read = safe_read(fd, buffer.as_mut_ptr() as *mut libc::c_void, bytes_read);\n    if bytes_read == -(1 as libc::c_int) as size_t {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    let all_lines: bool = n_lines == 0;\n    if n_lines != 0 && bytes_read != 0\n        && buffer[bytes_read.wrapping_sub(1 as libc::c_int as libc::c_ulong) as usize]\n            as libc::c_int != line_end as libc::c_int\n    {\n        n_lines = n_lines.wrapping_sub(1);\n        n_lines;\n    }\n    loop {\n        let mut n: size_t = bytes_read;\n        while n != 0 {\n            if all_lines {\n                n = (n as libc::c_ulong).wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    as size_t as size_t;\n            } else {\n                let mut nl: *const libc::c_char = 0 as *const libc::c_char;\n                nl = memrchr(\n                    buffer.as_mut_ptr() as *const libc::c_void,\n                    line_end as libc::c_int,\n                    n,\n                ) as *const libc::c_char;\n                if nl.is_null() {\n                    break;\n                }\n                n = nl.offset_from(buffer.as_mut_ptr()) as libc::c_long as size_t;\n            }\n            let fresh1 = n_lines;\n            n_lines = n_lines.wrapping_sub(1);\n            if fresh1 == 0 as libc::c_int as libc::c_ulong {\n                if start_pos < pos {\n                    let mut err: Copy_fd_status = COPY_FD_OK;\n                    if elseek(fd, start_pos, 0 as libc::c_int, pretty_filename)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        return 0 as libc::c_int != 0;\n                    }\n                    err = copy_fd(fd, (pos - start_pos) as uintmax_t);\n                    if err as libc::c_uint != COPY_FD_OK as libc::c_int as libc::c_uint {\n                        diagnose_copy_fd_failure(err, pretty_filename);\n                        return 0 as libc::c_int != 0;\n                    }\n                }\n                xwrite_stdout(\n                    buffer.as_mut_ptr(),\n                    n.wrapping_add(1 as libc::c_int as libc::c_ulong),\n                );\n                return 0 as libc::c_int as libc::c_long\n                    <= elseek(\n                        fd,\n                        (pos as libc::c_ulong)\n                            .wrapping_add(n)\n                            .wrapping_add(1 as libc::c_int as libc::c_ulong) as off_t,\n                        0 as libc::c_int,\n                        pretty_filename,\n                    );\n            }\n        }\n        if pos == start_pos {\n            return 1 as libc::c_int != 0;\n        }\n        pos -= 8192 as libc::c_int as libc::c_long;\n        if elseek(fd, pos, 0 as libc::c_int, pretty_filename)\n            < 0 as libc::c_int as libc::c_long\n        {\n            return 0 as libc::c_int != 0;\n        }\n        bytes_read = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, pretty_filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(\n                            shell_escape_always_quoting_style,\n                            pretty_filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            return 1 as libc::c_int != 0;\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:147 ~ head[91ec]::elide_tail_lines_file)",
        "span": "src/head.rs:1460:5: 1461:100 (#0)",
        "source": "return size <= current_pos\n        || elide_tail_lines_seekable(filename, fd, n_elide.try_into().unwrap(), current_pos, size);"
      }
    ],
    "globals": [
      {
        "span": "src/head.rs:239:1: 239:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:125 ~ head[91ec]::xwrite_stdout)",
    "span": "src/head.rs:587:1: 649:2 (#0)",
    "pieces": [
      "src/head.rs:587:1: 649:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 63,
    "source": "unsafe extern \"C\" fn xwrite_stdout(\n    mut buffer: *const libc::c_char,\n    mut n_bytes: size_t,\n) {\n    if n_bytes > 0 as libc::c_int as libc::c_ulong\n        && fwrite_unlocked(\n            buffer as *const libc::c_void,\n            1 as libc::c_int as size_t,\n            n_bytes,\n            stdout,\n        ) < n_bytes\n    {\n        clearerr_unlocked(stdout);\n        fpurge(stdout);\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(\n                    shell_escape_always_quoting_style,\n                    b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error writing %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(\n                        shell_escape_always_quoting_style,\n                        b\"standard output\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ head[91ec]::elide_tail_bytes_pipe)",
        "span": "src/head.rs:1055:29: 1058:31 (#0)",
        "source": "xwrite_stdout(\n                                (*b_0.offset(i_0 as isize)).offset(n_read_0 as isize),\n                                rem,\n                            );"
      },
      {
        "caller": "DefId(0:138 ~ head[91ec]::elide_tail_bytes_pipe)",
        "span": "src/head.rs:1064:29: 1067:31 (#0)",
        "source": "xwrite_stdout(\n                                *b_0.offset(i_next as isize),\n                                rem.wrapping_sub(n_bytes_left_in_b_i),\n                            );"
      },
      {
        "caller": "DefId(0:138 ~ head[91ec]::elide_tail_bytes_pipe)",
        "span": "src/head.rs:1077:25: 1077:72 (#0)",
        "source": "xwrite_stdout(*b_0.offset(i_next as isize), x);"
      },
      {
        "caller": "DefId(0:144 ~ head[91ec]::elide_tail_lines_pipe)",
        "span": "src/head.rs:1319:13: 1322:15 (#0)",
        "source": "xwrite_stdout(\n                ((*tmp).buffer).as_mut_ptr(),\n                p_0.offset_from(((*tmp).buffer).as_mut_ptr()) as libc::c_long as size_t,\n            );"
      },
      {
        "caller": "DefId(0:144 ~ head[91ec]::elide_tail_lines_pipe)",
        "span": "src/head.rs:1174:13: 1174:65 (#0)",
        "source": "xwrite_stdout(((*tmp).buffer).as_mut_ptr(), n_read);"
      },
      {
        "caller": "DefId(0:144 ~ head[91ec]::elide_tail_lines_pipe)",
        "span": "src/head.rs:1218:21: 1218:84 (#0)",
        "source": "xwrite_stdout(((*first).buffer).as_mut_ptr(), (*first).nbytes);"
      },
      {
        "caller": "DefId(0:138 ~ head[91ec]::elide_tail_bytes_pipe)",
        "span": "src/head.rs:1038:17: 1038:71 (#0)",
        "source": "xwrite_stdout(*b_0.offset(i_next as isize), n_read_0);"
      },
      {
        "caller": "DefId(0:138 ~ head[91ec]::elide_tail_bytes_pipe)",
        "span": "src/head.rs:1060:29: 1063:31 (#0)",
        "source": "xwrite_stdout(\n                                (*b_0.offset(i_0 as isize)).offset(n_read_0 as isize),\n                                n_bytes_left_in_b_i,\n                            );"
      }
    ],
    "globals": [
      {
        "span": "src/head.rs:239:1: 239:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:139 ~ head[91ec]::elide_tail_lines_pipe)",
    "span": "src/head.rs:1141:1: 1337:2 (#0)",
    "pieces": [
      "src/head.rs:1141:1: 1337:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 197,
    "source": "unsafe extern \"C\" fn elide_tail_lines_pipe(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide: uintmax_t,\n    mut current_pos: off_t,\n) -> bool {\n    let mut desired_pos: uintmax_t = current_pos as uintmax_t;\n    let mut first: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut last: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut tmp: *mut LBUFFER = 0 as *mut LBUFFER;\n    let mut total_lines: size_t = 0 as libc::c_int as size_t;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    let mut n_read: size_t = 0;\n    last = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    first = last;\n    (*first).nlines = 0 as libc::c_int as size_t;\n    (*first).nbytes = (*first).nlines;\n    (*first).next = 0 as *mut linebuffer;\n    tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong) as *mut LBUFFER;\n    loop {\n        n_read = safe_read(\n            fd,\n            ((*tmp).buffer).as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        if n_read == 0 as libc::c_int as libc::c_ulong\n            || n_read == -(1 as libc::c_int) as size_t\n        {\n            break;\n        }\n        if n_elide == 0 {\n            desired_pos = (desired_pos as libc::c_ulong).wrapping_add(n_read)\n                as uintmax_t as uintmax_t;\n            xwrite_stdout(((*tmp).buffer).as_mut_ptr(), n_read);\n        } else {\n            (*tmp).nbytes = n_read;\n            (*tmp).nlines = 0 as libc::c_int as size_t;\n            (*tmp).next = 0 as *mut linebuffer;\n            let mut buffer_end: *mut libc::c_char = ((*tmp).buffer)\n                .as_mut_ptr()\n                .offset(n_read as isize);\n            *buffer_end = line_end;\n            let mut p: *const libc::c_char = ((*tmp).buffer).as_mut_ptr();\n            loop {\n                p = rawmemchr(p as *const libc::c_void, line_end as libc::c_int)\n                    as *const libc::c_char;\n                if !(p < buffer_end as *const libc::c_char) {\n                    break;\n                }\n                p = p.offset(1);\n                p;\n                (*tmp).nlines = ((*tmp).nlines).wrapping_add(1);\n                (*tmp).nlines;\n            }\n            total_lines = (total_lines as libc::c_ulong).wrapping_add((*tmp).nlines)\n                as size_t as size_t;\n            if ((*tmp).nbytes).wrapping_add((*last).nbytes)\n                < 8192 as libc::c_int as libc::c_ulong\n            {\n                memcpy(\n                    &mut *((*last).buffer).as_mut_ptr().offset((*last).nbytes as isize)\n                        as *mut libc::c_char as *mut libc::c_void,\n                    ((*tmp).buffer).as_mut_ptr() as *const libc::c_void,\n                    (*tmp).nbytes,\n                );\n                (*last)\n                    .nbytes = ((*last).nbytes as libc::c_ulong)\n                    .wrapping_add((*tmp).nbytes) as size_t as size_t;\n                (*last)\n                    .nlines = ((*last).nlines as libc::c_ulong)\n                    .wrapping_add((*tmp).nlines) as size_t as size_t;\n            } else {\n                (*last).next = tmp;\n                last = (*last).next;\n                if n_elide < total_lines.wrapping_sub((*first).nlines) {\n                    desired_pos = (desired_pos as libc::c_ulong)\n                        .wrapping_add((*first).nbytes) as uintmax_t as uintmax_t;\n                    xwrite_stdout(((*first).buffer).as_mut_ptr(), (*first).nbytes);\n                    tmp = first;\n                    total_lines = (total_lines as libc::c_ulong)\n                        .wrapping_sub((*first).nlines) as size_t as size_t;\n                    first = (*first).next;\n                } else {\n                    tmp = xmalloc(::core::mem::size_of::<LBUFFER>() as libc::c_ulong)\n                        as *mut LBUFFER;\n                }\n            }\n        }\n    }\n    free(tmp as *mut libc::c_void);\n    if n_read == -(1 as libc::c_int) as size_t {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        ok = 0 as libc::c_int != 0;\n    } else {\n        if (*last).nbytes != 0\n            && (*last)\n                .buffer[((*last).nbytes).wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                as usize] as libc::c_int != line_end as libc::c_int\n        {\n            (*last).nlines = ((*last).nlines).wrapping_add(1);\n            (*last).nlines;\n            total_lines = total_lines.wrapping_add(1);\n            total_lines;\n        }\n        tmp = first;\n        while n_elide < total_lines.wrapping_sub((*tmp).nlines) {\n            desired_pos = (desired_pos as libc::c_ulong).wrapping_add((*tmp).nbytes)\n                as uintmax_t as uintmax_t;\n            xwrite_stdout(((*tmp).buffer).as_mut_ptr(), (*tmp).nbytes);\n            total_lines = (total_lines as libc::c_ulong).wrapping_sub((*tmp).nlines)\n                as size_t as size_t;\n            tmp = (*tmp).next;\n        }\n        if n_elide < total_lines {\n            let mut n: size_t = total_lines.wrapping_sub(n_elide);\n            let mut buffer_end_0: *const libc::c_char = ((*tmp).buffer)\n                .as_mut_ptr()\n                .offset((*tmp).nbytes as isize);\n            let mut p_0: *const libc::c_char = ((*tmp).buffer).as_mut_ptr();\n            while n != 0\n                && {\n                    p_0 = memchr(\n                        p_0 as *const libc::c_void,\n                        line_end as libc::c_int,\n                        buffer_end_0.offset_from(p_0) as libc::c_long as libc::c_ulong,\n                    ) as *const libc::c_char;\n                    !p_0.is_null()\n                }\n            {\n                p_0 = p_0.offset(1);\n                p_0;\n                (*tmp).nlines = ((*tmp).nlines).wrapping_add(1);\n                (*tmp).nlines;\n                n = n.wrapping_sub(1);\n                n;\n            }\n            desired_pos = (desired_pos as libc::c_ulong)\n                .wrapping_add(\n                    p_0.offset_from(((*tmp).buffer).as_mut_ptr()) as libc::c_long\n                        as libc::c_ulong,\n                ) as uintmax_t as uintmax_t;\n            xwrite_stdout(\n                ((*tmp).buffer).as_mut_ptr(),\n                p_0.offset_from(((*tmp).buffer).as_mut_ptr()) as libc::c_long as size_t,\n            );\n        }\n    }\n    while !first.is_null() {\n        tmp = (*first).next;\n        free(first as *mut libc::c_void);\n        first = tmp;\n    }\n    if 0 as libc::c_int as libc::c_long <= current_pos\n        && elseek(fd, desired_pos as off_t, 0 as libc::c_int, filename)\n            < 0 as libc::c_int as libc::c_long\n    {\n        ok = 0 as libc::c_int != 0;\n    }\n    return ok;\n}",
    "calls": [
      {
        "caller": "DefId(0:147 ~ head[91ec]::elide_tail_lines_file)",
        "span": "src/head.rs:1457:5: 1459:6 (#0)",
        "source": "{\n        return elide_tail_lines_pipe(filename, fd, n_elide, current_pos)\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/head.rs:391:1: 391:39 (#0)",
        "source": "static mut line_end: libc::c_char = 0;"
      },
      {
        "span": "src/head.rs:239:1: 239:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:143 ~ head[91ec]::elide_tail_lines_file)",
    "span": "src/head.rs:1436:1: 1463:2 (#0)",
    "pieces": [
      "src/head.rs:1436:1: 1463:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 29,
    "source": "unsafe extern \"C\" fn elide_tail_lines_file(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide: uintmax_t,\n    mut st: *const stat,\n    mut current_pos: off_t,\n) -> bool {\n    let mut size: off_t = (*st).st_size;\n    if presume_input_pipe as libc::c_int != 0\n        || current_pos < 0 as libc::c_int as libc::c_long\n        || size\n            <= (if (0 as libc::c_int) < (*st).st_blksize\n                && (*st).st_blksize as libc::c_ulong\n                    <= (-(1 as libc::c_int) as size_t)\n                        .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            {\n                (*st).st_blksize\n            } else {\n                512 as libc::c_int\n            }) as libc::c_long\n    {\n        return elide_tail_lines_pipe(filename, fd, n_elide, current_pos)\n    } else {\n        return size <= current_pos\n            || elide_tail_lines_seekable(filename, fd, n_elide, current_pos, size)\n                as libc::c_int != 0\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:155 ~ head[91ec]::head)",
        "span": "src/head.rs:1730:24: 1732:10 (#0)",
        "source": "{\n            return elide_tail_lines_file(filename, fd, n_units, &mut st, current_pos)\n        }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:107 ~ head[91ec]::__gl_setmode)",
    "span": "src/head.rs:363:1: 365:2 (#0)",
    "pieces": [
      "src/head.rs:363:1: 365:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn __gl_setmode(\n    mut _fd: libc::c_int,\n    mut _mode: libc::c_int,\n) -> libc::c_int {\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:119 ~ head[91ec]::set_binary_mode)",
        "span": "src/head.rs:368:47: 370:2 (#0)",
        "source": "{\n    __gl_setmode(fd, mode)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:144 ~ head[91ec]::head_bytes)",
    "span": "src/head.rs:1464:1: 1534:2 (#0)",
    "pieces": [
      "src/head.rs:1464:1: 1534:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 71,
    "source": "unsafe extern \"C\" fn head_bytes(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut bytes_to_write: uintmax_t,\n) -> bool {\n    let mut buffer: [libc::c_char; 8192] = [0; 8192];\n    let mut bytes_to_read: size_t = 8192 as libc::c_int as size_t;\n    while bytes_to_write != 0 {\n        let mut bytes_read: size_t = 0;\n        if bytes_to_write < bytes_to_read {\n            bytes_to_read = bytes_to_write;\n        }\n        bytes_read = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            bytes_to_read,\n        );\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            break;\n        }\n        xwrite_stdout(buffer.as_mut_ptr(), bytes_read);\n        bytes_to_write = (bytes_to_write as libc::c_ulong).wrapping_sub(bytes_read)\n            as uintmax_t as uintmax_t;\n    }\n    return 1 as libc::c_int != 0;\n}",
    "calls": [
      {
        "caller": "DefId(0:155 ~ head[91ec]::head)",
        "span": "src/head.rs:1738:12: 1740:6 (#0)",
        "source": "{\n        return head_bytes(filename, fd, n_units)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:160 ~ head[91ec]::main)",
    "span": "src/head.rs:2258:1: 2273:2 (#0)",
    "pieces": [
      "src/head.rs:2258:1: 2273:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:130 ~ head[91ec]::elseek)",
    "span": "src/head.rs:678:1: 766:2 (#0)",
    "pieces": [
      "src/head.rs:678:1: 766:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 89,
    "source": "unsafe extern \"C\" fn elseek(\n    mut fd: libc::c_int,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n    mut filename: *const libc::c_char,\n) -> off_t {\n    let mut new_offset: off_t = lseek(fd, offset, whence);\n    let mut buf: [libc::c_char; 21] = [0; 21];\n    if new_offset < 0 as libc::c_int as libc::c_long {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    if whence == 0 as libc::c_int {\n                        b\"%s: cannot seek to offset %s\\0\" as *const u8\n                            as *const libc::c_char\n                    } else {\n                        b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                            as *const libc::c_char\n                    },\n                ),\n                quotearg_n_style_colon(\n                    0 as libc::c_int,\n                    shell_escape_quoting_style,\n                    filename,\n                ),\n                offtostr(offset, buf.as_mut_ptr()),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        if whence == 0 as libc::c_int {\n                            b\"%s: cannot seek to offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        } else {\n                            b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        },\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    offtostr(offset, buf.as_mut_ptr()),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        if whence == 0 as libc::c_int {\n                            b\"%s: cannot seek to offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        } else {\n                            b\"%s: cannot seek to relative offset %s\\0\" as *const u8\n                                as *const libc::c_char\n                        },\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                    offtostr(offset, buf.as_mut_ptr()),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    return new_offset;\n}",
    "calls": [
      {
        "caller": "DefId(0:155 ~ head[91ec]::head)",
        "span": "src/head.rs:1720:13: 1725:15 (#0)",
        "source": "current_pos = elseek(\n                fd,\n                0 as libc::c_int as off_t,\n                1 as libc::c_int,\n                filename,\n            );"
      }
    ],
    "globals": [
      {
        "span": "src/head.rs:240:1: 240:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      }
    ],
    "imports": [
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:126 ~ head[91ec]::copy_fd)",
    "span": "src/head.rs:650:1: 676:2 (#0)",
    "pieces": [
      "src/head.rs:650:1: 676:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "unsafe extern \"C\" fn copy_fd(\n    mut src_fd: libc::c_int,\n    mut n_bytes: uintmax_t,\n) -> Copy_fd_status {\n    let mut buf: [libc::c_char; 8192] = [0; 8192];\n    let buf_size: size_t = ::core::mem::size_of::<[libc::c_char; 8192]>()\n        as libc::c_ulong;\n    while (0 as libc::c_int as libc::c_ulong) < n_bytes {\n        let mut n_to_read: size_t = if buf_size < n_bytes { buf_size } else { n_bytes };\n        let mut n_read: size_t = safe_read(\n            src_fd,\n            buf.as_mut_ptr() as *mut libc::c_void,\n            n_to_read,\n        );\n        if n_read == -(1 as libc::c_int) as size_t {\n            return COPY_FD_READ_ERROR;\n        }\n        n_bytes = (n_bytes as libc::c_ulong).wrapping_sub(n_read) as uintmax_t\n            as uintmax_t;\n        if n_read == 0 as libc::c_int as libc::c_ulong\n            && n_bytes != 0 as libc::c_int as libc::c_ulong\n        {\n            return COPY_FD_UNEXPECTED_EOF;\n        }\n        xwrite_stdout(buf.as_mut_ptr(), n_read);\n    }\n    return COPY_FD_OK;\n}",
    "calls": [
      {
        "caller": "DefId(0:143 ~ head[91ec]::elide_tail_bytes_file)",
        "span": "src/head.rs:1133:1: 1133:54 (#0)",
        "source": "let err: Copy_fd_status = copy_fd(fd, bytes_to_copy);"
      }
    ],
    "globals": [
      {
        "span": "src/head.rs:251:1: 251:42 (#0)",
        "source": "pub const COPY_FD_OK: Copy_fd_status = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:147 ~ head[91ec]::head_lines)",
    "span": "src/head.rs:1535:1: 1642:2 (#0)",
    "pieces": [
      "src/head.rs:1535:1: 1642:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 108,
    "source": "unsafe extern \"C\" fn head_lines(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut lines_to_write: uintmax_t,\n) -> bool {\n    let mut buffer: [libc::c_char; 8192] = [0; 8192];\n    while lines_to_write != 0 {\n        let mut bytes_read: size_t = safe_read(\n            fd,\n            buffer.as_mut_ptr() as *mut libc::c_void,\n            8192 as libc::c_int as size_t,\n        );\n        let mut bytes_to_write: size_t = 0 as libc::c_int as size_t;\n        if bytes_read == -(1 as libc::c_int) as size_t {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if bytes_read == 0 as libc::c_int as libc::c_ulong {\n            break;\n        }\n        while bytes_to_write < bytes_read {\n            let fresh2 = bytes_to_write;\n            bytes_to_write = bytes_to_write.wrapping_add(1);\n            if !(buffer[fresh2 as usize] as libc::c_int == line_end as libc::c_int\n                && {\n                    lines_to_write = lines_to_write.wrapping_sub(1);\n                    lines_to_write == 0 as libc::c_int as libc::c_ulong\n                })\n            {\n                continue;\n            }\n            let mut n_bytes_past_EOL: off_t = bytes_read.wrapping_sub(bytes_to_write)\n                as off_t;\n            if lseek(fd, -n_bytes_past_EOL, 1 as libc::c_int)\n                < 0 as libc::c_int as libc::c_long\n            {\n                let mut st: stat = stat {\n                    st_dev: 0,\n                    st_ino: 0,\n                    st_mode: 0,\n                    st_nlink: 0,\n                    st_uid: 0,\n                    st_gid: 0,\n                    st_rdev: 0,\n                    __pad1: 0,\n                    st_size: 0,\n                    st_blksize: 0,\n                    __pad2: 0,\n                    st_blocks: 0,\n                    st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n                    __glibc_reserved: [0; 2],\n                };\n                if fstat(fd, &mut st) != 0 as libc::c_int\n                    || st.st_mode & 0o170000 as libc::c_int as libc::c_uint\n                        == 0o100000 as libc::c_int as libc::c_uint\n                {\n                    elseek(fd, -n_bytes_past_EOL, 1 as libc::c_int, filename);\n                }\n            }\n            break;\n        }\n        xwrite_stdout(buffer.as_mut_ptr(), bytes_to_write);\n    }\n    return 1 as libc::c_int != 0;\n}",
    "calls": [
      {
        "caller": "DefId(0:155 ~ head[91ec]::head)",
        "span": "src/head.rs:1736:20: 1738:6 (#0)",
        "source": "{\n        return head_lines(filename, fd, n_units)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:118 ~ head[91ec]::diagnose_copy_fd_failure)",
    "span": "src/head.rs:537:1: 578:2 (#0)",
    "pieces": [
      "src/head.rs:537:1: 578:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 138,
    "source": "unsafe extern \"C\" fn diagnose_copy_fd_failure(\n    mut err: Copy_fd_status,\n    mut filename: *const libc::c_char,\n) {\n    match err as libc::c_uint {\n        1 => {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"error reading %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        2 => {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"%s: file has shrunk too much\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_n_style_colon(\n                        0 as libc::c_int,\n                        shell_escape_quoting_style,\n                        filename,\n                    ),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: file has shrunk too much\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"%s: file has shrunk too much\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_n_style_colon(\n                            0 as libc::c_int,\n                            shell_escape_quoting_style,\n                            filename,\n                        ),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _ => {\n            __assert_fail(\n                b\"0\\0\" as *const u8 as *const libc::c_char,\n                b\"head.c\\0\" as *const u8 as *const libc::c_char,\n                162 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 65],\n                    &[libc::c_char; 65],\n                >(b\"void diagnose_copy_fd_failure(enum Copy_fd_status, const char *)\\0\"))\n                    .as_ptr(),\n            );\n            'c_7166: {\n                __assert_fail(\n                    b\"0\\0\" as *const u8 as *const libc::c_char,\n                    b\"head.c\\0\" as *const u8 as *const libc::c_char,\n                    162 as libc::c_int as libc::c_uint,\n                    (*::core::mem::transmute::<\n                        &[u8; 65],\n                        &[libc::c_char; 65],\n                    >(\n                        b\"void diagnose_copy_fd_failure(enum Copy_fd_status, const char *)\\0\",\n                    ))\n                        .as_ptr(),\n                );\n            };\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:143 ~ head[91ec]::elide_tail_bytes_file)",
        "span": "src/head.rs:1137:9: 1137:49 (#0)",
        "source": "diagnose_copy_fd_failure(err, filename);"
      }
    ],
    "globals": [
      {
        "span": "src/head.rs:240:1: 240:57 (#0)",
        "source": "pub const shell_escape_quoting_style: quoting_style = 3;"
      },
      {
        "span": "src/head.rs:239:1: 239:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:104 ~ head[91ec]::xnrealloc)",
    "span": "src/head.rs:340:1: 346:2 (#0)",
    "pieces": [
      "src/head.rs:340:1: 346:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn xnrealloc(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return xreallocarray(p, n, s);\n}",
    "calls": [
      {
        "caller": "DefId(0:138 ~ head[91ec]::elide_tail_bytes_pipe)",
        "span": "src/head.rs:963:17: 967:45 (#0)",
        "source": "b_0 = xnrealloc(\n                    b_0 as *mut libc::c_void,\n                    n_array_alloc,\n                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,\n                ) as *mut *mut libc::c_char;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:133 ~ head[91ec]::elide_tail_bytes_pipe)",
    "span": "src/head.rs:767:1: 1098:2 (#0)",
    "pieces": [
      "src/head.rs:767:1: 1098:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 332,
    "source": "unsafe extern \"C\" fn elide_tail_bytes_pipe(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide_0: uintmax_t,\n    mut current_pos: off_t,\n) -> bool {\n    let mut n_elide: size_t = n_elide_0;\n    let mut desired_pos: uintmax_t = current_pos as uintmax_t;\n    let mut ok: bool = 1 as libc::c_int != 0;\n    if (18446744073709551615 as libc::c_ulong)\n        < n_elide_0.wrapping_add(8192 as libc::c_int as libc::c_ulong)\n    {\n        let mut umax_buf: [libc::c_char; 21] = [0; 21];\n        if 0 != 0 {\n            error(\n                1 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s: number of bytes is too large\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                umaxtostr(n_elide_0, umax_buf.as_mut_ptr()),\n            );\n            if 1 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s: number of bytes is too large\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    umaxtostr(n_elide_0, umax_buf.as_mut_ptr()),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 1 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s: number of bytes is too large\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    umaxtostr(n_elide_0, umax_buf.as_mut_ptr()),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n    }\n    if n_elide <= (1024 as libc::c_int * 1024 as libc::c_int) as libc::c_ulong {\n        let mut first: bool = 1 as libc::c_int != 0;\n        let mut eof: bool = 0 as libc::c_int != 0;\n        let mut n_to_read: size_t = (8192 as libc::c_int as libc::c_ulong)\n            .wrapping_add(n_elide);\n        let mut i: bool = false;\n        let mut b: [*mut libc::c_char; 2] = [0 as *mut libc::c_char; 2];\n        b[0 as libc::c_int\n            as usize] = xnmalloc(2 as libc::c_int as size_t, n_to_read)\n            as *mut libc::c_char;\n        b[1 as libc::c_int\n            as usize] = (b[0 as libc::c_int as usize]).offset(n_to_read as isize);\n        i = 0 as libc::c_int != 0;\n        while !eof {\n            let mut n_read: size_t = full_read(\n                fd,\n                b[i as usize] as *mut libc::c_void,\n                n_to_read,\n            );\n            let mut delta: size_t = 0 as libc::c_int as size_t;\n            if n_read < n_to_read {\n                if *__errno_location() != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, filename),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                    break;\n                } else {\n                    if n_read <= n_elide {\n                        if !first {\n                            delta = n_elide.wrapping_sub(n_read);\n                        }\n                    }\n                    eof = 1 as libc::c_int != 0;\n                }\n            }\n            if !first {\n                desired_pos = (desired_pos as libc::c_ulong)\n                    .wrapping_add(n_elide.wrapping_sub(delta)) as uintmax_t as uintmax_t;\n                xwrite_stdout(\n                    (b[!i as libc::c_int as usize]).offset(8192 as libc::c_int as isize),\n                    n_elide.wrapping_sub(delta),\n                );\n            }\n            first = 0 as libc::c_int != 0;\n            if n_elide < n_read {\n                desired_pos = (desired_pos as libc::c_ulong)\n                    .wrapping_add(n_read.wrapping_sub(n_elide)) as uintmax_t\n                    as uintmax_t;\n                xwrite_stdout(b[i as usize], n_read.wrapping_sub(n_elide));\n            }\n            i = !i;\n        }\n        free(b[0 as libc::c_int as usize] as *mut libc::c_void);\n    } else {\n        let mut current_block_69: u64;\n        let mut eof_0: bool = 0 as libc::c_int != 0;\n        let mut n_read_0: size_t = 0;\n        let mut buffered_enough: bool = false;\n        let mut i_0: size_t = 0;\n        let mut i_next: size_t = 0;\n        let mut b_0: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n        let mut rem: size_t = (8192 as libc::c_int as libc::c_ulong)\n            .wrapping_sub(n_elide.wrapping_rem(8192 as libc::c_int as libc::c_ulong));\n        let mut n_elide_round: size_t = n_elide.wrapping_add(rem);\n        let mut n_bufs: size_t = n_elide_round\n            .wrapping_div(8192 as libc::c_int as libc::c_ulong)\n            .wrapping_add(1 as libc::c_int as libc::c_ulong);\n        let mut n_alloc: size_t = 0 as libc::c_int as size_t;\n        let mut n_array_alloc: size_t = 0 as libc::c_int as size_t;\n        buffered_enough = 0 as libc::c_int != 0;\n        i_0 = 0 as libc::c_int as size_t;\n        i_next = 1 as libc::c_int as size_t;\n        loop {\n            if eof_0 {\n                current_block_69 = 10753070352654377903;\n                break;\n            }\n            if n_array_alloc == i_0 {\n                if n_array_alloc == 0 as libc::c_int as libc::c_ulong {\n                    n_array_alloc = if n_bufs < 16 as libc::c_int as libc::c_ulong {\n                        n_bufs\n                    } else {\n                        16 as libc::c_int as libc::c_ulong\n                    };\n                } else if n_array_alloc\n                    <= n_bufs.wrapping_div(2 as libc::c_int as libc::c_ulong)\n                {\n                    n_array_alloc = (n_array_alloc as libc::c_ulong)\n                        .wrapping_mul(2 as libc::c_int as libc::c_ulong) as size_t\n                        as size_t;\n                } else {\n                    n_array_alloc = n_bufs;\n                }\n                b_0 = xnrealloc(\n                    b_0 as *mut libc::c_void,\n                    n_array_alloc,\n                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,\n                ) as *mut *mut libc::c_char;\n            }\n            if !buffered_enough {\n                let ref mut fresh0 = *b_0.offset(i_0 as isize);\n                *fresh0 = xmalloc(8192 as libc::c_int as size_t) as *mut libc::c_char;\n                n_alloc = i_0.wrapping_add(1 as libc::c_int as libc::c_ulong);\n            }\n            n_read_0 = full_read(\n                fd,\n                *b_0.offset(i_0 as isize) as *mut libc::c_void,\n                8192 as libc::c_int as size_t,\n            );\n            if n_read_0 < 8192 as libc::c_int as libc::c_ulong {\n                if *__errno_location() != 0 as libc::c_int {\n                    if 0 != 0 {\n                        error(\n                            0 as libc::c_int,\n                            *__errno_location(),\n                            gettext(\n                                b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, filename),\n                        );\n                        if 0 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 0 as libc::c_int;\n                            error(\n                                __errstatus,\n                                *__errno_location(),\n                                gettext(\n                                    b\"error reading %s\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                                quotearg_style(shell_escape_always_quoting_style, filename),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                    ok = 0 as libc::c_int != 0;\n                    current_block_69 = 10121186216371937393;\n                    break;\n                } else {\n                    eof_0 = 1 as libc::c_int != 0;\n                }\n            }\n            if i_0.wrapping_add(1 as libc::c_int as libc::c_ulong) == n_bufs {\n                buffered_enough = 1 as libc::c_int != 0;\n            }\n            if buffered_enough {\n                desired_pos = (desired_pos as libc::c_ulong).wrapping_add(n_read_0)\n                    as uintmax_t as uintmax_t;\n                xwrite_stdout(*b_0.offset(i_next as isize), n_read_0);\n            }\n            i_0 = i_next;\n            i_next = i_next\n                .wrapping_add(1 as libc::c_int as libc::c_ulong)\n                .wrapping_rem(n_bufs);\n        }\n        match current_block_69 {\n            10753070352654377903 => {\n                if rem != 0 {\n                    if buffered_enough {\n                        let mut n_bytes_left_in_b_i: size_t = (8192 as libc::c_int\n                            as libc::c_ulong)\n                            .wrapping_sub(n_read_0);\n                        desired_pos = (desired_pos as libc::c_ulong).wrapping_add(rem)\n                            as uintmax_t as uintmax_t;\n                        if rem < n_bytes_left_in_b_i {\n                            xwrite_stdout(\n                                (*b_0.offset(i_0 as isize)).offset(n_read_0 as isize),\n                                rem,\n                            );\n                        } else {\n                            xwrite_stdout(\n                                (*b_0.offset(i_0 as isize)).offset(n_read_0 as isize),\n                                n_bytes_left_in_b_i,\n                            );\n                            xwrite_stdout(\n                                *b_0.offset(i_next as isize),\n                                rem.wrapping_sub(n_bytes_left_in_b_i),\n                            );\n                        }\n                    } else if i_0.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                        == n_bufs\n                    {\n                        let mut y: size_t = (8192 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(rem);\n                        let mut x: size_t = n_read_0.wrapping_sub(y);\n                        desired_pos = (desired_pos as libc::c_ulong).wrapping_add(x)\n                            as uintmax_t as uintmax_t;\n                        xwrite_stdout(*b_0.offset(i_next as isize), x);\n                    }\n                }\n            }\n            _ => {}\n        }\n        i_0 = 0 as libc::c_int as size_t;\n        while i_0 < n_alloc {\n            free(*b_0.offset(i_0 as isize) as *mut libc::c_void);\n            i_0 = i_0.wrapping_add(1);\n            i_0;\n        }\n        free(b_0 as *mut libc::c_void);\n    }\n    if 0 as libc::c_int as libc::c_long <= current_pos\n        && elseek(fd, desired_pos as off_t, 0 as libc::c_int, filename)\n            < 0 as libc::c_int as libc::c_long\n    {\n        ok = 0 as libc::c_int != 0;\n    }\n    return ok;\n}",
    "calls": [
      {
        "caller": "DefId(0:143 ~ head[91ec]::elide_tail_bytes_file)",
        "span": "src/head.rs:1120:5: 1122:6 (#0)",
        "source": "{\n        return elide_tail_bytes_pipe(filename, fd, n_elide, current_pos)\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/head.rs:239:1: 239:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:138 ~ head[91ec]::elide_tail_bytes_file)",
    "span": "src/head.rs:1099:1: 1140:2 (#0)",
    "pieces": [
      "src/head.rs:1099:1: 1140:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 44,
    "source": "unsafe extern \"C\" fn elide_tail_bytes_file(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_elide: uintmax_t,\n    mut st: *const stat,\n    mut current_pos: off_t,\n) -> bool {\n    let mut size: off_t = (*st).st_size;\n    if presume_input_pipe as libc::c_int != 0\n        || current_pos < 0 as libc::c_int as libc::c_long\n        || size\n            <= (if (0 as libc::c_int) < (*st).st_blksize\n                && (*st).st_blksize as libc::c_ulong\n                    <= (-(1 as libc::c_int) as size_t)\n                        .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_add(1 as libc::c_int as libc::c_ulong)\n            {\n                (*st).st_blksize\n            } else {\n                512 as libc::c_int\n            }) as libc::c_long\n    {\n        return elide_tail_bytes_pipe(filename, fd, n_elide, current_pos)\n    } else {\n        let mut diff: off_t = size - current_pos;\n        let mut bytes_remaining: off_t = if diff < 0 as libc::c_int as libc::c_long {\n            0 as libc::c_int as libc::c_long\n        } else {\n            diff\n        };\n        if bytes_remaining as libc::c_ulong <= n_elide {\n            return 1 as libc::c_int != 0;\n        }\n        let mut err: Copy_fd_status = copy_fd(\n            fd,\n            (bytes_remaining as libc::c_ulong).wrapping_sub(n_elide),\n        );\n        if err as libc::c_uint == COPY_FD_OK as libc::c_int as libc::c_uint {\n            return 1 as libc::c_int != 0;\n        }\n        diagnose_copy_fd_failure(err, filename);\n        return 0 as libc::c_int != 0;\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:155 ~ head[91ec]::head)",
        "span": "src/head.rs:1732:16: 1734:10 (#0)",
        "source": "{\n            return elide_tail_bytes_file(filename, fd, n_units, &mut st, current_pos)\n        }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:123 ~ head[91ec]::write_header)",
    "span": "src/head.rs:580:1: 585:2 (#0)",
    "pieces": [
      "src/head.rs:580:1: 585:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn write_header(mut filename: *const libc::c_char) {\n    static mut first_file: bool = 1 as libc::c_int != 0;\n    printf(\n        b\"%s==> %s <==\\n\\0\" as *const u8 as *const libc::c_char,\n        if first_file as libc::c_int != 0 {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\n\\0\" as *const u8 as *const libc::c_char\n        },\n        filename,\n    );\n    first_file = 0 as libc::c_int != 0;\n}",
    "calls": [
      {
        "caller": "DefId(0:155 ~ head[91ec]::head)",
        "span": "src/head.rs:1652:1: 1652:29 (#0)",
        "source": "write_header(&filename_str);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:151 ~ head[91ec]::head)",
    "span": "src/head.rs:1643:1: 1741:2 (#0)",
    "pieces": [
      "src/head.rs:1643:1: 1741:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 98,
    "source": "unsafe extern \"C\" fn head(\n    mut filename: *const libc::c_char,\n    mut fd: libc::c_int,\n    mut n_units: uintmax_t,\n    mut count_lines: bool,\n    mut elide_from_end: bool,\n) -> bool {\n    if print_headers {\n        write_header(filename);\n    }\n    if elide_from_end {\n        let mut current_pos: off_t = -(1 as libc::c_int) as off_t;\n        let mut st: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        if fstat(fd, &mut st) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n        if !presume_input_pipe && usable_st_size(&mut st) as libc::c_int != 0 {\n            current_pos = elseek(\n                fd,\n                0 as libc::c_int as off_t,\n                1 as libc::c_int,\n                filename,\n            );\n            if current_pos < 0 as libc::c_int as libc::c_long {\n                return 0 as libc::c_int != 0;\n            }\n        }\n        if count_lines {\n            return elide_tail_lines_file(filename, fd, n_units, &mut st, current_pos)\n        } else {\n            return elide_tail_bytes_file(filename, fd, n_units, &mut st, current_pos)\n        }\n    }\n    if count_lines {\n        return head_lines(filename, fd, n_units)\n    } else {\n        return head_bytes(filename, fd, n_units)\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:157 ~ head[91ec]::head_file)",
        "span": "src/head.rs:1812:5: 1812:67 (#0)",
        "source": "ok = head(filename, fd, n_units, count_lines, elide_from_end);"
      }
    ],
    "globals": [
      {
        "span": "src/head.rs:239:1: 239:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:108 ~ head[91ec]::set_binary_mode)",
    "span": "src/head.rs:368:1: 370:2 (#0)",
    "pieces": [
      "src/head.rs:368:1: 370:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn set_binary_mode(\n    mut fd: libc::c_int,\n    mut mode: libc::c_int,\n) -> libc::c_int {\n    return __gl_setmode(fd, mode);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:153 ~ head[91ec]::head_file)",
    "span": "src/head.rs:1742:1: 1855:2 (#0)",
    "pieces": [
      "src/head.rs:1742:1: 1855:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 112,
    "source": "unsafe extern \"C\" fn head_file(\n    mut filename: *const libc::c_char,\n    mut n_units: uintmax_t,\n    mut count_lines: bool,\n    mut elide_from_end: bool,\n) -> bool {\n    let mut fd: libc::c_int = 0;\n    let mut ok: bool = false;\n    let mut is_stdin: bool = strcmp(filename, b\"-\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int;\n    if is_stdin {\n        have_read_stdin = 1 as libc::c_int != 0;\n        fd = 0 as libc::c_int;\n        filename = gettext(b\"standard input\\0\" as *const u8 as *const libc::c_char);\n        xset_binary_mode(0 as libc::c_int, 0 as libc::c_int);\n    } else {\n        fd = open(filename, 0 as libc::c_int | 0 as libc::c_int);\n        if fd < 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot open %s for reading\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot open %s for reading\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot open %s for reading\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, filename),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n    }\n    ok = head(filename, fd, n_units, count_lines, elide_from_end);\n    if !is_stdin && close(fd) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"failed to close %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, filename),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to close %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"failed to close %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, filename),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    return ok;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/head.rs:239:1: 239:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/head.rs:392:1: 392:42 (#0)",
        "source": "static mut have_read_stdin: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:100 ~ head[91ec]::usable_st_size)",
    "span": "src/head.rs:264:1: 268:2 (#0)",
    "pieces": [
      "src/head.rs:264:1: 268:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn usable_st_size(mut sb: *const stat) -> bool {\n    return (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n        || ((*sb).st_mode).wrapping_sub((*sb).st_mode) != 0 || 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/head.rs:18:1: 18:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/head.rs:21:1: 21:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/head.rs:19:1: 19:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/head.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/head.rs:14:5: 14:15 (#0)",
        "source": "libc::stat"
      },
      {
        "span": "src/head.rs:14:1: 14:29 (#0)",
        "source": "use libc::stat as libc_stat;"
      }
    ],
    "chunks": []
  }
]