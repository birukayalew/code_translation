[
  {
    "func_defid": "DefId(0:689 ~ rust[fc84]::src::quotearg::set_quoting_flags)",
    "span": "src/quotearg.rs:215:1: 226:2 (#0)",
    "pieces": [
      "src/quotearg.rs:215:1: 226:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:12 ~ rust[fc84]::src::c_ctype::c_isascii)",
    "span": "src/c_ctype.rs:30:1: 43:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:30:1: 43:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:692 ~ rust[fc84]::src::quotearg::gettext_quote)",
    "span": "src/quotearg.rs:262:1: 295:2 (#0)",
    "pieces": [
      "src/quotearg.rs:262:1: 295:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "unsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:693 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:346:21: 349:23 (#0)",
        "source": "right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );"
      },
      {
        "caller": "DefId(0:693 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:342:21: 345:23 (#0)",
        "source": "left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:693 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
    "span": "src/quotearg.rs:296:1: 1197:2 (#0)",
    "pieces": [
      "src/quotearg.rs:296:1: 1197:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 902,
    "source": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n    let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n        pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n            let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                    if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                63 => {\n                    match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }\n                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                    esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }\n                }\n                123 | 125 => {\n                    if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }\n                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                    encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                    let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;\n                    if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }\n            match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;\n        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }\n        if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }\n    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:706 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1382:9: 1392:11 (#0)",
        "source": "quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );"
      },
      {
        "caller": "DefId(0:696 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1253:5: 1264:58 (#0)",
        "source": "let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:706 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1362:5: 1372:7 (#0)",
        "source": "let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:696 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1266:5: 1276:7 (#0)",
        "source": "quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:693 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1138:41: 1150:10 (#0)",
        "source": "{\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        }"
      },
      {
        "caller": "DefId(0:693 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1167:13: 1177:15 (#0)",
        "source": "return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );"
      },
      {
        "caller": "DefId(0:694 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
        "span": "src/quotearg.rs:1212:5: 1222:7 (#0)",
        "source": "let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:52:1: 52:57 (#0)",
        "source": "pub const shell_always_quoting_style: quoting_style = 2;"
      },
      {
        "span": "src/quotearg.rs:57:1: 57:52 (#0)",
        "source": "pub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;"
      },
      {
        "span": "src/quotearg.rs:50:1: 50:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/quotearg.rs:49:1: 49:46 (#0)",
        "source": "pub const c_quoting_style: quoting_style = 5;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:848 ~ rust[fc84]::src::xmalloc::_gl_alloc_nomem)",
    "span": "src/xmalloc.rs:79:1: 82:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:79:1: 82:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:845 ~ rust[fc84]::src::xmalloc::irealloc)",
        "span": "src/xmalloc.rs:35:12: 37:6 (#0)",
        "source": "{\n        return _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:846 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:49:13: 49:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:846 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:43:13: 43:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:847 ~ rust[fc84]::src::xmalloc::ireallocarray)",
        "span": "src/xmalloc.rs:73:12: 75:6 (#0)",
        "source": "{\n        return _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:849 ~ rust[fc84]::src::xmalloc::imalloc)",
        "span": "src/xmalloc.rs:87:12: 89:6 (#0)",
        "source": "{\n        _gl_alloc_nomem()\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:849 ~ rust[fc84]::src::xmalloc::imalloc)",
    "span": "src/xmalloc.rs:84:1: 90:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:84:1: 90:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:852 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:103:5: 103:38 (#0)",
        "source": "return check_nonnull(imalloc(s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:850 ~ rust[fc84]::src::xmalloc::check_nonnull)",
    "span": "src/xmalloc.rs:91:1: 96:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:91:1: 96:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:865 ~ rust[fc84]::src::xmalloc::xcalloc)",
        "span": "src/xmalloc.rs:913:5: 913:40 (#0)",
        "source": "return check_nonnull(calloc(n, s));"
      },
      {
        "caller": "DefId(0:852 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:103:5: 103:38 (#0)",
        "source": "return check_nonnull(imalloc(s));"
      },
      {
        "caller": "DefId(0:855 ~ rust[fc84]::src::xmalloc::xirealloc)",
        "span": "src/xmalloc.rs:131:5: 131:42 (#0)",
        "source": "return check_nonnull(irealloc(p, s));"
      },
      {
        "caller": "DefId(0:851 ~ rust[fc84]::src::xmalloc::xmalloc)",
        "span": "src/xmalloc.rs:99:5: 99:37 (#0)",
        "source": "return check_nonnull(malloc(s));"
      },
      {
        "caller": "DefId(0:857 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:151:5: 151:50 (#0)",
        "source": "return check_nonnull(ireallocarray(p, n, s));"
      },
      {
        "caller": "DefId(0:866 ~ rust[fc84]::src::xmalloc::xicalloc)",
        "span": "src/xmalloc.rs:917:5: 917:41 (#0)",
        "source": "return check_nonnull(icalloc(n, s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:852 ~ rust[fc84]::src::xmalloc::ximalloc)",
    "span": "src/xmalloc.rs:102:1: 104:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:102:1: 104:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}",
    "calls": [
      {
        "caller": "DefId(0:868 ~ rust[fc84]::src::xmalloc::ximemdup)",
        "span": "src/xmalloc.rs:931:5: 931:55 (#0)",
        "source": "return memcpy(ximalloc(s), p, s as libc::c_ulong);"
      },
      {
        "caller": "DefId(0:869 ~ rust[fc84]::src::xmalloc::ximemdup0)",
        "span": "src/xmalloc.rs:938:5: 939:30 (#0)",
        "source": "let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:869 ~ rust[fc84]::src::xmalloc::ximemdup0)",
    "span": "src/xmalloc.rs:934:1: 943:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:934:1: 943:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:856 ~ rust[fc84]::src::xmalloc::xreallocarray)",
    "span": "src/xmalloc.rs:134:1: 144:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:134:1: 144:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:858 ~ rust[fc84]::src::xmalloc::xnmalloc)",
        "span": "src/xmalloc.rs:155:5: 155:56 (#0)",
        "source": "return xreallocarray(0 as *mut libc::c_void, n, s);"
      },
      {
        "caller": "DefId(0:861 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
        "span": "src/xmalloc.rs:192:5: 192:32 (#0)",
        "source": "p = xreallocarray(p, n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:858 ~ rust[fc84]::src::xmalloc::xnmalloc)",
    "span": "src/xmalloc.rs:154:1: 156:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:154:1: 156:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [
      {
        "caller": "DefId(0:853 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:111:12: 113:6 (#0)",
        "source": "{\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:694 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
    "span": "src/quotearg.rs:1199:1: 1225:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1199:1: 1225:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:10 ~ rust[fc84]::src::c_ctype::c_isalnum)",
    "span": "src/c_ctype.rs:5:1: 14:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:5:1: 14:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:24 ~ rust[fc84]::src::c_ctype::c_toupper)",
    "span": "src/c_ctype.rs:168:1: 176:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:168:1: 176:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:846 ~ rust[fc84]::src::xmalloc::icalloc)",
    "span": "src/xmalloc.rs:40:1: 54:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:40:1: 54:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:866 ~ rust[fc84]::src::xmalloc::xicalloc)",
        "span": "src/xmalloc.rs:917:5: 917:41 (#0)",
        "source": "return check_nonnull(icalloc(n, s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:866 ~ rust[fc84]::src::xmalloc::xicalloc)",
    "span": "src/xmalloc.rs:916:1: 918:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:916:1: 918:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}",
    "calls": [
      {
        "caller": "DefId(0:864 ~ rust[fc84]::src::xmalloc::xizalloc)",
        "span": "src/xmalloc.rs:909:5: 909:51 (#0)",
        "source": "return xicalloc(s, 1 as libc::c_int as idx_t);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:102 ~ rust[fc84]::src::fclose::rpl_fclose)",
    "span": "src/fclose.rs:52:1: 72:2 (#0)",
    "pieces": [
      "src/fclose.rs:52:1: 72:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fclose.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:851 ~ rust[fc84]::src::xmalloc::xmalloc)",
    "span": "src/xmalloc.rs:98:1: 100:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:98:1: 100:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}",
    "calls": [
      {
        "caller": "DefId(0:853 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:109:5: 111:6 (#0)",
        "source": "{\n        xmalloc(n)\n    }"
      },
      {
        "caller": "DefId(0:867 ~ rust[fc84]::src::xmalloc::xmemdup)",
        "span": "src/xmalloc.rs:924:5: 924:37 (#0)",
        "source": "return memcpy(xmalloc(s), p, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:847 ~ rust[fc84]::src::xmalloc::ireallocarray)",
    "span": "src/xmalloc.rs:56:1: 76:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:56:1: 76:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:857 ~ rust[fc84]::src::xmalloc::xireallocarray)",
        "span": "src/xmalloc.rs:151:5: 151:50 (#0)",
        "source": "return check_nonnull(ireallocarray(p, n, s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:857 ~ rust[fc84]::src::xmalloc::xireallocarray)",
    "span": "src/xmalloc.rs:146:1: 152:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:146:1: 152:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}",
    "calls": [
      {
        "caller": "DefId(0:859 ~ rust[fc84]::src::xmalloc::xinmalloc)",
        "span": "src/xmalloc.rs:159:5: 159:57 (#0)",
        "source": "return xireallocarray(0 as *mut libc::c_void, n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:859 ~ rust[fc84]::src::xmalloc::xinmalloc)",
    "span": "src/xmalloc.rs:158:1: 160:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:158:1: 160:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:169 ~ rust[fc84]::src::ialloc::_gl_alloc_nomem)",
    "span": "src/ialloc.rs:86:1: 89:2 (#0)",
    "pieces": [
      "src/ialloc.rs:86:1: 89:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:168 ~ rust[fc84]::src::ialloc::imalloc)",
        "span": "src/ialloc.rs:78:12: 80:6 (#0)",
        "source": "{\n        _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:167 ~ rust[fc84]::src::ialloc::irealloc)",
        "span": "src/ialloc.rs:68:12: 70:6 (#0)",
        "source": "{\n        return _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:165 ~ rust[fc84]::src::ialloc::ireallocarray)",
        "span": "src/ialloc.rs:36:12: 38:6 (#0)",
        "source": "{\n        return _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:166 ~ rust[fc84]::src::ialloc::icalloc)",
        "span": "src/ialloc.rs:52:13: 52:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:166 ~ rust[fc84]::src::ialloc::icalloc)",
        "span": "src/ialloc.rs:46:13: 46:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:167 ~ rust[fc84]::src::ialloc::irealloc)",
    "span": "src/ialloc.rs:61:1: 71:2 (#0)",
    "pieces": [
      "src/ialloc.rs:61:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:854 ~ rust[fc84]::src::xmalloc::xrealloc)",
    "span": "src/xmalloc.rs:116:1: 125:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:116:1: 125:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:862 ~ rust[fc84]::src::xmalloc::xpalloc)",
        "span": "src/xmalloc.rs:899:5: 899:41 (#0)",
        "source": "pa = xrealloc(pa, nbytes as size_t);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:21 ~ rust[fc84]::src::c_ctype::c_isupper)",
    "span": "src/c_ctype.rs:136:1: 142:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:136:1: 142:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:861 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
    "span": "src/xmalloc.rs:169:1: 195:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:169:1: 195:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:860 ~ rust[fc84]::src::xmalloc::x2realloc)",
        "span": "src/xmalloc.rs:166:5: 166:58 (#0)",
        "source": "return x2nrealloc(p, ps, 1 as libc::c_int as size_t);"
      }
    ],
    "globals": [
      {
        "span": "src/xmalloc.rs:23:1: 23:47 (#0)",
        "source": "pub const DEFAULT_MXFAST: C2RustUnnamed = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:787 ~ rust[fc84]::src::version_etc::emit_bug_reporting_address)",
    "span": "src/version_etc.rs:306:1: 324:2 (#0)",
    "pieces": [
      "src/version_etc.rs:306:1: 324:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:781 ~ rust[fc84]::src::version_etc::version_etc_arn)",
    "span": "src/version_etc.rs:65:1: 247:2 (#0)",
    "pieces": [
      "src/version_etc.rs:65:1: 247:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 183,
    "source": "pub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n    if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:783 ~ rust[fc84]::src::version_etc::version_etc_va)",
        "span": "src/version_etc.rs:284:5: 291:7 (#0)",
        "source": "version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );"
      },
      {
        "caller": "DefId(0:782 ~ rust[fc84]::src::version_etc::version_etc_ar)",
        "span": "src/version_etc.rs:262:5: 262:81 (#0)",
        "source": "version_etc_arn(stream, command_name, package, version, authors, n_authors);"
      }
    ],
    "globals": [
      {
        "span": "src/version_etc.rs:62:1: 62:48 (#0)",
        "source": "pub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;"
      }
    ],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:782 ~ rust[fc84]::src::version_etc::version_etc_ar)",
    "span": "src/version_etc.rs:249:1: 263:2 (#0)",
    "pieces": [
      "src/version_etc.rs:249:1: 263:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:853 ~ rust[fc84]::src::xmalloc::xcharalloc)",
    "span": "src/xmalloc.rs:106:1: 114:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:106:1: 114:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:13 ~ rust[fc84]::src::c_ctype::c_isblank)",
    "span": "src/c_ctype.rs:47:1: 49:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:47:1: 49:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:120 ~ rust[fc84]::src::fflush::clear_ungetc_buffer_preserving_position)",
    "span": "src/fflush.rs:49:1: 53:2 (#0)",
    "pieces": [
      "src/fflush.rs:49:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:121 ~ rust[fc84]::src::fflush::rpl_fflush)",
        "span": "src/fflush.rs:59:5: 59:53 (#0)",
        "source": "clear_ungetc_buffer_preserving_position(stream);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:121 ~ rust[fc84]::src::fflush::rpl_fflush)",
    "span": "src/fflush.rs:55:1: 61:2 (#0)",
    "pieces": [
      "src/fflush.rs:55:1: 61:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:706 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
    "span": "src/quotearg.rs:1318:1: 1396:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1318:1: 1396:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 79,
    "source": "unsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}",
    "calls": [
      {
        "caller": "DefId(0:727 ~ rust[fc84]::src::quotearg::quote_n_mem)",
        "span": "src/quotearg.rs:1588:5: 1588:76 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);"
      },
      {
        "caller": "DefId(0:711 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1435:5: 1435:82 (#0)",
        "source": "return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);"
      },
      {
        "caller": "DefId(0:707 ~ rust[fc84]::src::quotearg::quotearg_n)",
        "span": "src/quotearg.rs:1402:5: 1407:7 (#0)",
        "source": "return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );"
      },
      {
        "caller": "DefId(0:715 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1477:5: 1477:77 (#0)",
        "source": "return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);"
      },
      {
        "caller": "DefId(0:723 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1546:5: 1546:56 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut o);"
      },
      {
        "caller": "DefId(0:712 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1445:5: 1445:52 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &o);"
      },
      {
        "caller": "DefId(0:708 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
        "span": "src/quotearg.rs:1415:5: 1415:78 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);"
      },
      {
        "caller": "DefId(0:720 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1514:5: 1519:7 (#0)",
        "source": "return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:58:1: 58:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      },
      {
        "span": "src/quotearg.rs:1294:1: 1296:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1284:1: 1284:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:1285:1: 1293:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:690 ~ rust[fc84]::src::quotearg::set_custom_quoting)",
    "span": "src/quotearg.rs:228:1: 242:2 (#0)",
    "pieces": [
      "src/quotearg.rs:228:1: 242:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}",
    "calls": [
      {
        "caller": "DefId(0:723 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1545:5: 1545:57 (#0)",
        "source": "set_custom_quoting(&mut o, left_quote, right_quote);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:44:1: 44:52 (#0)",
        "source": "pub const custom_quoting_style: quoting_style = 10;"
      },
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:723 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
    "span": "src/quotearg.rs:1537:1: 1547:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1537:1: 1547:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}",
    "calls": [
      {
        "caller": "DefId(0:725 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
        "span": "src/quotearg.rs:1563:5: 1569:7 (#0)",
        "source": "return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );"
      },
      {
        "caller": "DefId(0:722 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
        "span": "src/quotearg.rs:1528:5: 1534:7 (#0)",
        "source": "return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:688 ~ rust[fc84]::src::quotearg::set_char_quoting)",
    "span": "src/quotearg.rs:184:1: 213:2 (#0)",
    "pieces": [
      "src/quotearg.rs:184:1: 213:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 30,
    "source": "pub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:720 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1513:5: 1513:82 (#0)",
        "source": "set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:715 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1476:5: 1476:58 (#0)",
        "source": "set_char_quoting(&mut options, ch, 1 as libc::c_int);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:691 ~ rust[fc84]::src::quotearg::quoting_options_from_style)",
    "span": "src/quotearg.rs:243:1: 261:2 (#0)",
    "pieces": [
      "src/quotearg.rs:243:1: 261:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}",
    "calls": [
      {
        "caller": "DefId(0:720 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1512:5: 1512:45 (#0)",
        "source": "options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:712 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1444:5: 1444:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:711 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1434:5: 1434:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:54:1: 54:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:720 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
    "span": "src/quotearg.rs:1500:1: 1520:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1500:1: 1520:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:54:1: 54:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:148 ~ rust[fc84]::src::hard_locale::hard_locale)",
    "span": "src/hard_locale.rs:12:1: 30:2 (#0)",
    "pieces": [
      "src/hard_locale.rs:12:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hard_locale.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:687 ~ rust[fc84]::src::quotearg::set_quoting_style)",
    "span": "src/quotearg.rs:177:1: 182:2 (#0)",
    "pieces": [
      "src/quotearg.rs:177:1: 182:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:22 ~ rust[fc84]::src::c_ctype::c_isxdigit)",
    "span": "src/c_ctype.rs:146:1: 152:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:146:1: 152:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:712 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
    "span": "src/quotearg.rs:1438:1: 1446:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1438:1: 1446:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:714 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
        "span": "src/quotearg.rs:1460:5: 1460:68 (#0)",
        "source": "return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:750 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:16:1: 21:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:16:1: 21:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:751 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
        "span": "src/setlocale_null_unlocked.rs:28:5: 28:77 (#0)",
        "source": "let mut result: *const libc::c_char = setlocale_null_unlocked(category);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:618 ~ rust[fc84]::src::propername_lite::proper_name_lite)",
    "span": "src/propername_lite.rs:8:1: 24:2 (#0)",
    "pieces": [
      "src/propername_lite.rs:8:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/propername_lite.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:609 ~ rust[fc84]::src::progname::set_program_name)",
    "span": "src/progname.rs:59:1: 96:2 (#0)",
    "pieces": [
      "src/progname.rs:59:1: 96:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "pub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/progname.rs:57:1: 57:77 (#0)",
        "source": "pub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/progname.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:783 ~ rust[fc84]::src::version_etc::version_etc_va)",
    "span": "src/version_etc.rs:265:1: 292:2 (#0)",
    "pieces": [
      "src/version_etc.rs:265:1: 292:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "pub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:786 ~ rust[fc84]::src::version_etc::version_etc)",
        "span": "src/version_etc.rs:303:5: 303:82 (#0)",
        "source": "version_etc_va(stream, command_name, package, version, authors.as_va_list());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:868 ~ rust[fc84]::src::xmalloc::ximemdup)",
    "span": "src/xmalloc.rs:927:1: 932:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:927:1: 932:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:74 ~ rust[fc84]::src::closeout::close_stdout_set_file_name)",
    "span": "src/closeout.rs:63:1: 65:2 (#0)",
    "pieces": [
      "src/closeout.rs:63:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:61:1: 61:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:715 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
    "span": "src/quotearg.rs:1463:1: 1478:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1463:1: 1478:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}",
    "calls": [
      {
        "caller": "DefId(0:717 ~ rust[fc84]::src::quotearg::quotearg_char)",
        "span": "src/quotearg.rs:1484:5: 1484:78 (#0)",
        "source": "return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);"
      },
      {
        "caller": "DefId(0:719 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
        "span": "src/quotearg.rs:1497:5: 1497:72 (#0)",
        "source": "return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:54:1: 54:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:717 ~ rust[fc84]::src::quotearg::quotearg_char)",
    "span": "src/quotearg.rs:1480:1: 1485:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1480:1: 1485:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}",
    "calls": [
      {
        "caller": "DefId(0:718 ~ rust[fc84]::src::quotearg::quotearg_colon)",
        "span": "src/quotearg.rs:1490:5: 1490:59 (#0)",
        "source": "return quotearg_char(arg, ':' as i32 as libc::c_char);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:20 ~ rust[fc84]::src::c_ctype::c_isspace)",
    "span": "src/c_ctype.rs:127:1: 132:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:127:1: 132:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:23 ~ rust[fc84]::src::c_ctype::c_tolower)",
    "span": "src/c_ctype.rs:156:1: 164:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:156:1: 164:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:722 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
    "span": "src/quotearg.rs:1522:1: 1535:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1522:1: 1535:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:724 ~ rust[fc84]::src::quotearg::quotearg_custom)",
        "span": "src/quotearg.rs:1554:5: 1554:78 (#0)",
        "source": "return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:685 ~ rust[fc84]::src::quotearg::clone_quoting_options)",
    "span": "src/quotearg.rs:150:1: 164:2 (#0)",
    "pieces": [
      "src/quotearg.rs:150:1: 164:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:865 ~ rust[fc84]::src::xmalloc::xcalloc)",
    "span": "src/xmalloc.rs:912:1: 914:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:912:1: 914:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}",
    "calls": [
      {
        "caller": "DefId(0:863 ~ rust[fc84]::src::xmalloc::xzalloc)",
        "span": "src/xmalloc.rs:905:5: 905:51 (#0)",
        "source": "return xcalloc(s, 1 as libc::c_int as size_t);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:863 ~ rust[fc84]::src::xmalloc::xzalloc)",
    "span": "src/xmalloc.rs:904:1: 906:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:904:1: 906:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:708 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
    "span": "src/quotearg.rs:1410:1: 1416:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1410:1: 1416:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:710 ~ rust[fc84]::src::quotearg::quotearg_mem)",
        "span": "src/quotearg.rs:1426:5: 1426:59 (#0)",
        "source": "return quotearg_n_mem(0 as libc::c_int, arg, argsize);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:725 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
    "span": "src/quotearg.rs:1557:1: 1570:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1557:1: 1570:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:704 ~ rust[fc84]::src::quotearg::quotearg_free)",
    "span": "src/quotearg.rs:1298:1: 1317:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1298:1: 1317:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:1284:1: 1284:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      },
      {
        "span": "src/quotearg.rs:1285:1: 1293:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:1283:1: 1283:50 (#0)",
        "source": "static mut slot0: [libc::c_char; 256] = [0; 256];"
      },
      {
        "span": "src/quotearg.rs:1294:1: 1296:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:18 ~ rust[fc84]::src::c_ctype::c_isprint)",
    "span": "src/c_ctype.rs:101:1: 112:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:101:1: 112:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:577 ~ rust[fc84]::src::mbrtoc32::mbszero)",
    "span": "src/mbrtoc32.rs:36:1: 42:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:36:1: 42:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:579 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
        "span": "src/mbrtoc32.rs:64:9: 64:21 (#0)",
        "source": "mbszero(ps);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:579 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
    "span": "src/mbrtoc32.rs:48:1: 78:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:48:1: 78:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 31,
    "source": "pub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/mbrtoc32.rs:43:1: 46:3 (#0)",
        "source": "static mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};"
      }
    ],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:845 ~ rust[fc84]::src::xmalloc::irealloc)",
    "span": "src/xmalloc.rs:28:1: 38:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:28:1: 38:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:855 ~ rust[fc84]::src::xmalloc::xirealloc)",
        "span": "src/xmalloc.rs:131:5: 131:42 (#0)",
        "source": "return check_nonnull(irealloc(p, s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:862 ~ rust[fc84]::src::xmalloc::xpalloc)",
    "span": "src/xmalloc.rs:197:1: 902:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:197:1: 902:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 706,
    "source": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }\n            }\n        } else {\n            if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n            let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }\n                        } else {\n                            if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    } else {\n                        if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }\n                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0\n        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:25:1: 25:51 (#0)",
        "source": "pub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:867 ~ rust[fc84]::src::xmalloc::xmemdup)",
    "span": "src/xmalloc.rs:920:1: 925:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:920:1: 925:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}",
    "calls": [
      {
        "caller": "DefId(0:870 ~ rust[fc84]::src::xmalloc::xstrdup)",
        "span": "src/xmalloc.rs:946:5: 949:28 (#0)",
        "source": "return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:719 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
    "span": "src/quotearg.rs:1493:1: 1498:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1493:1: 1498:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:751 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:23:1: 58:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:23:1: 58:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:902 ~ rust[fc84]::src::xstrtoimax::bkm_scale)",
    "span": "src/xstrtoimax.rs:39:1: 386:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:39:1: 386:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 348,
    "source": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut intmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n    let mut scaled: intmax_t = 0;\n    if if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { *x })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_long {\n                if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as intmax_t\n                    }) + scale_factor as libc::c_long\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (*x < -(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as intmax_t / -scale_factor as libc::c_long\n                    }) <= -(1 as libc::c_int) as libc::c_long - *x) as libc::c_int\n                }\n            } else {\n                if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n                        as libc::c_long + 0 as libc::c_int as intmax_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        *x\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < *x + 0 as libc::c_int as intmax_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < *x\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < *x - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as intmax_t / scale_factor as libc::c_long) < *x)\n                        as libc::c_int\n                }\n            }\n        } else {\n            if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    *x\n                                }) + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < scale_factor as libc::c_long\n                                    + 0 as libc::c_int as intmax_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_long)\n                                as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as intmax_t / *x\n                            < scale_factor as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        < *x) as libc::c_int\n                }\n            }\n        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n        *x = if *x < 0 as libc::c_int as libc::c_long {\n            !if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n                -(1 as libc::c_int) as intmax_t\n            } else {\n                (((1 as libc::c_int as intmax_t)\n                    << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }\n        } else if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n            -(1 as libc::c_int) as intmax_t\n        } else {\n            (((1 as libc::c_int as intmax_t)\n                << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        };\n        return LONGINT_OVERFLOW;\n    }\n    *x = scaled;\n    return LONGINT_OK;\n}",
    "calls": [
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:554:17: 554:66 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 2 as libc::c_int);"
      },
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:524:17: 524:69 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);"
      },
      {
        "caller": "DefId(0:903 ~ rust[fc84]::src::xstrtoimax::bkm_scale_by_power)",
        "span": "src/xstrtoimax.rs:399:9: 402:69 (#0)",
        "source": "err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);"
      },
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:521:17: 521:68 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 512 as libc::c_int);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:25:1: 25:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      },
      {
        "span": "src/xstrtoimax.rs:24:1: 24:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:903 ~ rust[fc84]::src::xstrtoimax::bkm_scale_by_power)",
    "span": "src/xstrtoimax.rs:387:1: 405:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:387:1: 405:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut intmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}",
    "calls": [
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:536:17: 536:81 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:560:17: 560:81 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);"
      },
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:542:17: 542:81 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);"
      },
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:539:17: 539:81 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);"
      },
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:557:17: 557:81 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);"
      },
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:533:17: 533:81 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);"
      },
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:545:17: 545:82 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);"
      },
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:548:17: 548:81 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);"
      },
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:530:17: 530:81 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);"
      },
      {
        "caller": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:551:17: 551:81 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:25:1: 25:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
    "span": "src/xstrtoimax.rs:407:1: 586:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:407:1: 586:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 180,
    "source": "pub unsafe extern \"C\" fn xstrtoimax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut intmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n    let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: intmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 78],\n                &[libc::c_char; 78],\n            >(\n                b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2247: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 78],\n                    &[libc::c_char; 78],\n                >(\n                    b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoimax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as intmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }\n    if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:24:1: 24:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoimax.rs:25:1: 25:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      },
      {
        "span": "src/xstrtoimax.rs:23:1: 23:57 (#0)",
        "source": "pub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;"
      },
      {
        "span": "src/xstrtoimax.rs:21:1: 21:45 (#0)",
        "source": "pub const LONGINT_INVALID: strtol_error = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:711 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
    "span": "src/quotearg.rs:1429:1: 1436:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1429:1: 1436:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:713 ~ rust[fc84]::src::quotearg::quotearg_style)",
        "span": "src/quotearg.rs:1452:5: 1452:55 (#0)",
        "source": "return quotearg_n_style(0 as libc::c_int, s, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:713 ~ rust[fc84]::src::quotearg::quotearg_style)",
    "span": "src/quotearg.rs:1448:1: 1453:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1448:1: 1453:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:15 ~ rust[fc84]::src::c_ctype::c_isdigit)",
    "span": "src/c_ctype.rs:65:1: 70:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:65:1: 70:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:77 ~ rust[fc84]::src::closeout::close_stdout)",
    "span": "src/closeout.rs:72:1: 167:2 (#0)",
    "pieces": [
      "src/closeout.rs:72:1: 167:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:61:1: 61:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:707 ~ rust[fc84]::src::quotearg::quotearg_n)",
    "span": "src/quotearg.rs:1398:1: 1408:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1398:1: 1408:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:709 ~ rust[fc84]::src::quotearg::quotearg)",
        "span": "src/quotearg.rs:1419:5: 1419:46 (#0)",
        "source": "return quotearg_n(0 as libc::c_int, arg);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:709 ~ rust[fc84]::src::quotearg::quotearg)",
    "span": "src/quotearg.rs:1418:1: 1420:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1418:1: 1420:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:870 ~ rust[fc84]::src::xmalloc::xstrdup)",
    "span": "src/xmalloc.rs:945:1: 950:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:945:1: 950:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:823 ~ rust[fc84]::src::xdectoimax::xnumtoimax)",
    "span": "src/xdectoimax.rs:28:1: 128:2 (#0)",
    "pieces": [
      "src/xdectoimax.rs:28:1: 128:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 101,
    "source": "pub unsafe extern \"C\" fn xnumtoimax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: intmax_t = 0;\n    s_err = xstrtoimax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_long {\n                *__errno_location() = 75 as libc::c_int;\n            } else if tnum\n                < ((-(2147483647 as libc::c_int) - 1 as libc::c_int) / 2 as libc::c_int)\n                    as libc::c_long\n            {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}",
    "calls": [
      {
        "caller": "DefId(0:824 ~ rust[fc84]::src::xdectoimax::xdectoimax)",
        "span": "src/xdectoimax.rs:138:5: 138:84 (#0)",
        "source": "return xnumtoimax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);"
      }
    ],
    "globals": [
      {
        "span": "src/xdectoimax.rs:26:1: 26:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xdectoimax.rs:21:1: 21:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xdectoimax.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:824 ~ rust[fc84]::src::xdectoimax::xdectoimax)",
    "span": "src/xdectoimax.rs:130:1: 139:2 (#0)",
    "pieces": [
      "src/xdectoimax.rs:130:1: 139:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xdectoimax(\n    mut n_str: *const libc::c_char,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    return xnumtoimax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xdectoimax.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:696 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
    "span": "src/quotearg.rs:1235:1: 1282:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1235:1: 1282:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}",
    "calls": [
      {
        "caller": "DefId(0:695 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
        "span": "src/quotearg.rs:1232:5: 1232:66 (#0)",
        "source": "return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:58:1: 58:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:695 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
    "span": "src/quotearg.rs:1227:1: 1233:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1227:1: 1233:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:860 ~ rust[fc84]::src::xmalloc::x2realloc)",
    "span": "src/xmalloc.rs:162:1: 167:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:162:1: 167:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:740 ~ rust[fc84]::src::setlocale_null::setlocale_null)",
    "span": "src/setlocale_null.rs:20:1: 24:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:20:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:17 ~ rust[fc84]::src::c_ctype::c_islower)",
    "span": "src/c_ctype.rs:89:1: 97:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:89:1: 97:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:727 ~ rust[fc84]::src::quotearg::quote_n_mem)",
    "span": "src/quotearg.rs:1583:1: 1589:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1583:1: 1589:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:728 ~ rust[fc84]::src::quotearg::quote_mem)",
        "span": "src/quotearg.rs:1595:5: 1595:56 (#0)",
        "source": "return quote_n_mem(0 as libc::c_int, arg, argsize);"
      },
      {
        "caller": "DefId(0:729 ~ rust[fc84]::src::quotearg::quote_n)",
        "span": "src/quotearg.rs:1602:5: 1602:71 (#0)",
        "source": "return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1572:1: 1581:3 (#0)",
        "source": "pub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:729 ~ rust[fc84]::src::quotearg::quote_n)",
    "span": "src/quotearg.rs:1598:1: 1603:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1598:1: 1603:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:730 ~ rust[fc84]::src::quotearg::quote)",
        "span": "src/quotearg.rs:1606:5: 1606:43 (#0)",
        "source": "return quote_n(0 as libc::c_int, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:730 ~ rust[fc84]::src::quotearg::quote)",
    "span": "src/quotearg.rs:1605:1: 1607:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1605:1: 1607:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:805 ~ rust[fc84]::src::xalloc_die::xalloc_die)",
    "span": "src/xalloc_die.rs:14:1: 54:2 (#0)",
    "pieces": [
      "src/xalloc_die.rs:14:1: 54:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "pub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalloc_die.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:855 ~ rust[fc84]::src::xmalloc::xirealloc)",
    "span": "src/xmalloc.rs:127:1: 132:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:127:1: 132:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:16 ~ rust[fc84]::src::c_ctype::c_isgraph)",
    "span": "src/c_ctype.rs:74:1: 85:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:74:1: 85:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:168 ~ rust[fc84]::src::ialloc::imalloc)",
    "span": "src/ialloc.rs:75:1: 81:2 (#0)",
    "pieces": [
      "src/ialloc.rs:75:1: 81:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:165 ~ rust[fc84]::src::ialloc::ireallocarray)",
    "span": "src/ialloc.rs:19:1: 39:2 (#0)",
    "pieces": [
      "src/ialloc.rs:19:1: 39:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:19 ~ rust[fc84]::src::c_ctype::c_ispunct)",
    "span": "src/c_ctype.rs:116:1: 123:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:116:1: 123:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:710 ~ rust[fc84]::src::quotearg::quotearg_mem)",
    "span": "src/quotearg.rs:1422:1: 1427:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1422:1: 1427:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:714 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
    "span": "src/quotearg.rs:1455:1: 1461:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1455:1: 1461:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:718 ~ rust[fc84]::src::quotearg::quotearg_colon)",
    "span": "src/quotearg.rs:1487:1: 1491:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1487:1: 1491:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:864 ~ rust[fc84]::src::xmalloc::xizalloc)",
    "span": "src/xmalloc.rs:908:1: 910:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:908:1: 910:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:139 ~ rust[fc84]::src::fseeko::rpl_fseeko)",
    "span": "src/fseeko.rs:50:1: 67:2 (#0)",
    "pieces": [
      "src/fseeko.rs:50:1: 67:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fseeko.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:76 ~ rust[fc84]::src::closeout::close_stdout_set_ignore_EPIPE)",
    "span": "src/closeout.rs:68:1: 70:2 (#0)",
    "pieces": [
      "src/closeout.rs:68:1: 70:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:66:1: 66:39 (#0)",
        "source": "static mut ignore_EPIPE: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:29 ~ rust[fc84]::src::c_strcasecmp::c_tolower)",
    "span": "src/c_strcasecmp.rs:3:1: 11:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:3:1: 11:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:30 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:26:9: 26:61 (#0)",
        "source": "c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;"
      },
      {
        "caller": "DefId(0:30 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:25:9: 25:61 (#0)",
        "source": "c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:30 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
    "span": "src/c_strcasecmp.rs:13:1: 46:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:13:1: 46:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "pub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:724 ~ rust[fc84]::src::quotearg::quotearg_custom)",
    "span": "src/quotearg.rs:1549:1: 1555:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1549:1: 1555:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:686 ~ rust[fc84]::src::quotearg::get_quoting_style)",
    "span": "src/quotearg.rs:166:1: 175:2 (#0)",
    "pieces": [
      "src/quotearg.rs:166:1: 175:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:142:1: 148:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:166 ~ rust[fc84]::src::ialloc::icalloc)",
    "span": "src/ialloc.rs:43:1: 57:2 (#0)",
    "pieces": [
      "src/ialloc.rs:43:1: 57:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:739 ~ rust[fc84]::src::setlocale_null::setlocale_null_r)",
    "span": "src/setlocale_null.rs:12:1: 18:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:12:1: 18:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:14 ~ rust[fc84]::src::c_ctype::c_iscntrl)",
    "span": "src/c_ctype.rs:53:1: 61:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:53:1: 61:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:677 ~ rust[fc84]::src::quotearg::c32isprint)",
    "span": "src/quotearg.rs:104:1: 106:2 (#0)",
    "pieces": [
      "src/quotearg.rs:104:1: 106:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:587 ~ rust[fc84]::src::mbszero::mbszero)",
    "span": "src/mbszero.rs:25:1: 31:2 (#0)",
    "pieces": [
      "src/mbszero.rs:25:1: 31:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mbszero.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:786 ~ rust[fc84]::src::version_etc::version_etc)",
    "span": "src/version_etc.rs:294:1: 304:2 (#0)",
    "pieces": [
      "src/version_etc.rs:294:1: 304:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:48 ~ rust[fc84]::src::close_stream::close_stream)",
    "span": "src/close_stream.rs:50:1: 65:2 (#0)",
    "pieces": [
      "src/close_stream.rs:50:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/close_stream.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:728 ~ rust[fc84]::src::quotearg::quote_mem)",
    "span": "src/quotearg.rs:1591:1: 1596:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1591:1: 1596:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:561 ~ rust[fc84]::src::localcharset::locale_charset)",
    "span": "src/localcharset.rs:391:1: 401:2 (#0)",
    "pieces": [
      "src/localcharset.rs:391:1: 401:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/localcharset.rs:5:1: 5:39 (#0)",
        "source": "pub const CODESET: C2RustUnnamed = 14;"
      }
    ],
    "imports": [
      {
        "span": "src/localcharset.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:11 ~ rust[fc84]::src::c_ctype::c_isalpha)",
    "span": "src/c_ctype.rs:18:1: 26:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:18:1: 26:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:678 ~ rust[fc84]::src::quotearg::mbszero)",
    "span": "src/quotearg.rs:108:1: 114:2 (#0)",
    "pieces": [
      "src/quotearg.rs:108:1: 114:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:100 ~ truncate[c51a]::to_uchar)",
    "span": "src/truncate.rs:332:1: 334:2 (#0)",
    "pieces": [
      "src/truncate.rs:332:1: 334:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn to_uchar(mut ch: libc::c_char) -> libc::c_uchar {\n    return ch as libc::c_uchar;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:109 ~ truncate[c51a]::do_ftruncate)",
    "span": "src/truncate.rs:496:1: 1200:2 (#0)",
    "pieces": [
      "src/truncate.rs:496:1: 1200:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 705,
    "source": "unsafe extern \"C\" fn do_ftruncate(\n    mut fd: libc::c_int,\n    mut fname: *const libc::c_char,\n    mut ssize: off_t,\n    mut rsize: off_t,\n    mut rel_mode: rel_mode_t,\n) -> bool {\n    let mut sb: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut nsize: off_t = 0;\n    if (block_mode as libc::c_int != 0\n        || rel_mode as libc::c_uint != 0 && rsize < 0 as libc::c_int as libc::c_long)\n        && fstat(fd, &mut sb) != 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, fname),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    if block_mode {\n        let mut blksize: ptrdiff_t = (if (0 as libc::c_int) < sb.st_blksize\n            && sb.st_blksize as libc::c_ulong\n                <= (-(1 as libc::c_int) as size_t)\n                    .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        {\n            sb.st_blksize\n        } else {\n            512 as libc::c_int\n        }) as ptrdiff_t;\n        let mut ssize0: intmax_t = ssize;\n        if if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t\n            && ((if 1 as libc::c_int != 0 {\n                0 as libc::c_int as libc::c_long\n            } else {\n                ssize\n            }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n            && ((if 1 as libc::c_int != 0 {\n                0 as libc::c_int as libc::c_long\n            } else {\n                blksize\n            }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n            && (if blksize < 0 as libc::c_int as libc::c_long {\n                if ssize < 0 as libc::c_int as libc::c_long {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            -(1 as libc::c_int) as off_t\n                        }) + blksize\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        (ssize < -(1 as libc::c_int) as off_t / blksize) as libc::c_int\n                    } else {\n                        ((if (if (if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            !(((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as libc::c_long\n                        }) < 0 as libc::c_int as libc::c_long\n                        {\n                            (blksize\n                                < -(if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    blksize\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) - 1 as libc::c_int as libc::c_long\n                                })) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long) < blksize) as libc::c_int\n                        }) != 0\n                        {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + -(1 as libc::c_int) as off_t\n                                >> (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        } else {\n                            -(1 as libc::c_int) as off_t / -blksize\n                        }) <= -(1 as libc::c_int) as libc::c_long - ssize) as libc::c_int\n                    }\n                } else {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) + 0 as libc::c_int as off_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) + 0 as libc::c_int as off_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    blksize\n                                }) + 0 as libc::c_int as off_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 0 as libc::c_int as off_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 0 as libc::c_int as off_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t) as libc::c_int\n                    }) != 0 && blksize == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            ssize\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < ssize + 0 as libc::c_int as off_t) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long) < ssize\n                                && (-(1 as libc::c_int) as libc::c_long\n                                    - 0 as libc::c_int as off_t)\n                                    < ssize - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as off_t / blksize < ssize) as libc::c_int\n                    }\n                }\n            } else {\n                if blksize == 0 as libc::c_int as libc::c_long {\n                    0 as libc::c_int\n                } else {\n                    if ssize < 0 as libc::c_int as libc::c_long {\n                        if (if (if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                ssize\n                            }) + 0 as libc::c_int as off_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            !(((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t\n                            }) + 0 as libc::c_int as libc::c_long\n                        }) < 0 as libc::c_int as libc::c_long\n                        {\n                            (((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                ssize\n                            }) + 0 as libc::c_int as off_t)\n                                < -(if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        ssize\n                                    }) + 0 as libc::c_int as off_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            ssize\n                                        }) + 0 as libc::c_int as off_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            ssize\n                                        }) + 0 as libc::c_int as off_t\n                                    }) - 1 as libc::c_int as libc::c_long\n                                })) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long)\n                                < (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t) as libc::c_int\n                        }) != 0 && ssize == -(1 as libc::c_int) as libc::c_long\n                        {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < blksize + 0 as libc::c_int as off_t) as libc::c_int\n                            } else {\n                                ((-(1 as libc::c_int) as libc::c_long\n                                    - 0 as libc::c_int as off_t)\n                                    < blksize - 1 as libc::c_int as libc::c_long) as libc::c_int\n                            }\n                        } else {\n                            (0 as libc::c_int as off_t / ssize < blksize) as libc::c_int\n                        }\n                    } else {\n                        (-(1 as libc::c_int) as off_t / blksize < ssize) as libc::c_int\n                    }\n                }\n            }) != 0\n        {\n            let (fresh4, _fresh5) = ssize.overflowing_mul(blksize);\n            *(&mut ssize as *mut off_t) = fresh4;\n            1 as libc::c_int\n        } else {\n            let (fresh6, fresh7) = ssize.overflowing_mul(blksize);\n            *(&mut ssize as *mut off_t) = fresh6;\n            fresh7 as libc::c_int\n        } != 0\n        {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"overflow in %jd * %td byte blocks for file %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    ssize0,\n                    blksize,\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"overflow in %jd * %td byte blocks for file %s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        ssize0,\n                        blksize,\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"overflow in %jd * %td byte blocks for file %s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        ssize0,\n                        blksize,\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;\n        }\n    }\n    if rel_mode as u64 != 0 {\n        let mut fsize: off_t = 0;\n        if 0 as libc::c_int as libc::c_long <= rsize {\n            fsize = rsize;\n        } else if usable_st_size(&mut sb) {\n            fsize = sb.st_size;\n            if fsize < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has unusable, apparently negative size\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s has unusable, apparently negative size\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s has unusable, apparently negative size\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return 0 as libc::c_int != 0;\n            }\n        } else {\n            fsize = lseek(fd, 0 as libc::c_int as __off_t, 2 as libc::c_int);\n            if fsize < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot get the size of %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot get the size of %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot get the size of %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return 0 as libc::c_int != 0;\n            }\n        }\n        if rel_mode as libc::c_uint == rm_min as libc::c_int as libc::c_uint {\n            nsize = if fsize > ssize { fsize } else { ssize };\n        } else if rel_mode as libc::c_uint == rm_max as libc::c_int as libc::c_uint {\n            nsize = if fsize < ssize { fsize } else { ssize };\n        } else if rel_mode as libc::c_uint == rm_rdn as libc::c_int as libc::c_uint {\n            nsize = fsize - fsize % ssize;\n        } else {\n            if rel_mode as libc::c_uint == rm_rup as libc::c_int as libc::c_uint {\n                let mut r: off_t = fsize % ssize;\n                ssize = if r == 0 as libc::c_int as libc::c_long {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    ssize - r\n                };\n            }\n            let (fresh8, fresh9) = fsize.overflowing_add(ssize);\n            *(&mut nsize as *mut off_t) = fresh8;\n            if fresh9 {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"overflow extending size of file %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"overflow extending size of file %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"overflow extending size of file %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return 0 as libc::c_int != 0;\n            }\n        }\n    } else {\n        nsize = ssize;\n    }\n    if nsize < 0 as libc::c_int as libc::c_long {\n        nsize = 0 as libc::c_int as off_t;\n    }\n    if ftruncate(fd, nsize) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, fname),\n                nsize,\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                    nsize,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                    nsize,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    return 1 as libc::c_int != 0;\n}",
    "calls": [
      {
        "caller": "DefId(0:111 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1894:13: 1895:88 (#0)",
        "source": "errors = (errors as libc::c_int\n                | !do_ftruncate(fd, fname, size, rsize, rel_mode) as libc::c_int) != 0;"
      }
    ],
    "globals": [
      {
        "span": "src/truncate.rs:195:1: 195:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/truncate.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:97 ~ truncate[c51a]::emit_ancillary_info)",
    "span": "src/truncate.rs:216:1: 330:2 (#0)",
    "pieces": [
      "src/truncate.rs:216:1: 330:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 115,
    "source": "unsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:108 ~ truncate[c51a]::usage)",
        "span": "src/truncate.rs:492:9: 492:80 (#0)",
        "source": "emit_ancillary_info(b\"truncate\\0\" as *const u8 as *const libc::c_char);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:102 ~ truncate[c51a]::emit_size_note)",
    "span": "src/truncate.rs:346:1: 354:2 (#0)",
    "pieces": [
      "src/truncate.rs:346:1: 354:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_size_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\\nUnits are K,M,G,T,P,E,Z,Y,R,Q (powers of 1024) or KB,MB,... (powers of 1000).\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:108 ~ truncate[c51a]::usage)",
        "span": "src/truncate.rs:484:9: 484:26 (#0)",
        "source": "emit_size_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:101 ~ truncate[c51a]::emit_mandatory_arg_note)",
    "span": "src/truncate.rs:336:1: 344:2 (#0)",
    "pieces": [
      "src/truncate.rs:336:1: 344:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_mandatory_arg_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nMandatory arguments to long options are mandatory for short options too.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:108 ~ truncate[c51a]::usage)",
        "span": "src/truncate.rs:448:9: 448:35 (#0)",
        "source": "emit_mandatory_arg_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:108 ~ truncate[c51a]::usage)",
    "span": "src/truncate.rs:424:1: 495:2 (#0)",
    "pieces": [
      "src/truncate.rs:424:1: 495:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 72,
    "source": "pub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s OPTION... FILE...\\n\\0\" as *const u8 as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Shrink or extend the size of each FILE to the specified size\\n\\nA FILE argument that does not exist is created.\\n\\nIf a FILE is larger than the specified size, the extra data is lost.\\nIf a FILE is shorter, it is extended and the sparse extended part (hole)\\nreads as zero bytes.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_mandatory_arg_note();\n        fputs_unlocked(\n            gettext(\n                b\"  -c, --no-create        do not create any files\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -r, --reference=RFILE  base size on RFILE\\n  -s, --size=SIZE        set or adjust the file size by SIZE bytes\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_size_note();\n        fputs_unlocked(\n            gettext(\n                b\"\\nSIZE may also be prefixed by one of the following modifying characters:\\n'+' extend by, '-' reduce by, '<' at most, '>' at least,\\n'/' round down to multiple of, '%' round up to multiple of.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(b\"truncate\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}",
    "calls": [
      {
        "caller": "DefId(0:111 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1569:9: 1569:33 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:111 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1640:9: 1640:33 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:111 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1325:25: 1325:49 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:111 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1498:9: 1498:33 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:111 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1682:9: 1682:33 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:111 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1423:17: 1423:41 (#0)",
        "source": "usage(1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:111 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1406:17: 1406:41 (#0)",
        "source": "usage(0 as libc::c_int);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:111 ~ truncate[c51a]::main_0)",
    "span": "src/truncate.rs:1201:1: 1948:2 (#0)",
    "pieces": [
      "src/truncate.rs:1201:1: 1948:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 748,
    "source": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n    let mut got_size: bool = 0 as libc::c_int != 0;\n    let mut size: off_t = 0 as libc::c_int as off_t;\n    let mut rsize: off_t = -(1 as libc::c_int) as off_t;\n    let mut rel_mode: rel_mode_t = rm_abs;\n    let mut c: libc::c_int = 0;\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    loop {\n        c = getopt_long(\n            argc,\n            argv,\n            b\"cor:s:\\0\" as *const u8 as *const libc::c_char,\n            longopts.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        match c {\n            99 => {\n                no_create = 1 as libc::c_int != 0;\n            }\n            111 => {\n                block_mode = 1 as libc::c_int != 0;\n            }\n            114 => {\n                ref_file = optarg;\n            }\n            115 => {\n                while *(*__ctype_b_loc())\n                    .offset(to_uchar(*optarg) as libc::c_int as isize) as libc::c_int\n                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n                {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                match *optarg as libc::c_int {\n                    60 => {\n                        rel_mode = rm_max;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    62 => {\n                        rel_mode = rm_min;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    47 => {\n                        rel_mode = rm_rdn;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    37 => {\n                        rel_mode = rm_rup;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    _ => {}\n                }\n                while *(*__ctype_b_loc())\n                    .offset(to_uchar(*optarg) as libc::c_int as isize) as libc::c_int\n                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n                {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                if *optarg as libc::c_int == '+' as i32\n                    || *optarg as libc::c_int == '-' as i32\n                {\n                    if rel_mode as u64 != 0 {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"multiple relative modifiers specified\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multiple relative modifiers specified\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multiple relative modifiers specified\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        usage(1 as libc::c_int);\n                    }\n                    rel_mode = rm_rel;\n                }\n                size = xdectoimax(\n                    optarg,\n                    !if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                        -(1 as libc::c_int) as off_t\n                    } else {\n                        (((1 as libc::c_int as off_t)\n                            << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long\n                    },\n                    if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                        -(1 as libc::c_int) as off_t\n                    } else {\n                        (((1 as libc::c_int as off_t)\n                            << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long\n                    },\n                    b\"EgGkKmMPQRtTYZ0\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"Invalid number\\0\" as *const u8 as *const libc::c_char),\n                    0 as libc::c_int,\n                );\n                if (rel_mode as libc::c_uint == rm_rup as libc::c_int as libc::c_uint\n                    || rel_mode as libc::c_uint == rm_rdn as libc::c_int as libc::c_uint)\n                    && size == 0 as libc::c_int as libc::c_long\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"division by zero\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"division by zero\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"division by zero\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                got_size = 1 as libc::c_int != 0;\n            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n                version_etc(\n                    stdout,\n                    b\"truncate\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Padraig Brady\\0\" as *const u8 as *const libc::c_char,\n                        b\"P\\xC3\\xA1draig Brady\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);\n            }\n            _ => {\n                usage(1 as libc::c_int);\n            }\n        }\n    }\n    argv = argv.offset(optind as isize);\n    argc -= optind;\n    if ref_file.is_null() && !got_size {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"you must specify either %s or %s\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote_n(\n                    1 as libc::c_int,\n                    b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify either %s or %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify either %s or %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if !ref_file.is_null() && got_size as libc::c_int != 0 && rel_mode as u64 == 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"you must specify a relative %s with %s\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote_n(\n                    1 as libc::c_int,\n                    b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify a relative %s with %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify a relative %s with %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if block_mode as libc::c_int != 0 && !got_size {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s was specified but %s was not\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote_n(\n                    1 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s was specified but %s was not\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s was specified but %s was not\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if argc < 1 as libc::c_int {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(b\"missing file operand\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"missing file operand\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"missing file operand\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if !ref_file.is_null() {\n        let mut sb: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        let mut file_size: off_t = -(1 as libc::c_int) as off_t;\n        if stat(ref_file, &mut sb) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"cannot stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, ref_file),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"cannot stat %s\\0\" as *const u8 as *const libc::c_char),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"cannot stat %s\\0\" as *const u8 as *const libc::c_char),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if usable_st_size(&mut sb) {\n            file_size = sb.st_size;\n        } else {\n            let mut ref_fd: libc::c_int = open(ref_file, 0 as libc::c_int);\n            if 0 as libc::c_int <= ref_fd {\n                let mut file_end: off_t = lseek(\n                    ref_fd,\n                    0 as libc::c_int as __off_t,\n                    2 as libc::c_int,\n                );\n                let mut saved_errno: libc::c_int = *__errno_location();\n                close(ref_fd);\n                if 0 as libc::c_int as libc::c_long <= file_end {\n                    file_size = file_end;\n                } else {\n                    *__errno_location() = saved_errno;\n                }\n            }\n        }\n        if file_size < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot get the size of %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, ref_file),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot get the size of %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot get the size of %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if !got_size {\n            size = file_size;\n        } else {\n            rsize = file_size;\n        }\n    }\n    let mut oflags: libc::c_int = 0o1 as libc::c_int\n        | (if no_create as libc::c_int != 0 {\n            0 as libc::c_int\n        } else {\n            0o100 as libc::c_int\n        }) | 0o4000 as libc::c_int;\n    let mut errors: bool = 0 as libc::c_int != 0;\n    let mut fname: *const libc::c_char = 0 as *const libc::c_char;\n    loop {\n        fname = *argv;\n        if fname.is_null() {\n            break;\n        }\n        let mut fd: libc::c_int = open(\n            fname,\n            oflags,\n            0o400 as libc::c_int | 0o200 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int,\n        );\n        if fd < 0 as libc::c_int {\n            if !(no_create as libc::c_int != 0\n                && *__errno_location() == 2 as libc::c_int)\n            {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot open %s for writing\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot open %s for writing\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot open %s for writing\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                errors = 1 as libc::c_int != 0;\n            }\n        } else {\n            errors = (errors as libc::c_int\n                | !do_ftruncate(fd, fname, size, rsize, rel_mode) as libc::c_int) != 0;\n            if close(fd) != 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to close %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to close %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to close %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                errors = 1 as libc::c_int != 0;\n            }\n        }\n        argv = argv.offset(1);\n        argv;\n    }\n    return if errors as libc::c_int != 0 { 1 as libc::c_int } else { 0 as libc::c_int };\n}",
    "calls": [
      {
        "caller": "DefId(0:113 ~ truncate[c51a]::main)",
        "span": "src/truncate.rs:1959:5: 1966:6 (#0)",
        "source": "unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/truncate.rs:195:1: 195:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/truncate.rs:203:1: 203:34 (#0)",
        "source": "pub const rm_max: rel_mode_t = 3;"
      },
      {
        "span": "src/truncate.rs:204:1: 204:34 (#0)",
        "source": "pub const rm_min: rel_mode_t = 2;"
      },
      {
        "span": "src/truncate.rs:357:1: 357:69 (#0)",
        "source": "static mut ref_file: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/truncate.rs:358:1: 422:3 (#0)",
        "source": "static mut longopts: [option; 7] = [\n    {\n        let mut init = option {\n            name: b\"no-create\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"io-blocks\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'o' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"reference\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'r' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"size\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 's' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];"
      },
      {
        "span": "src/truncate.rs:206:1: 206:34 (#0)",
        "source": "pub const rm_abs: rel_mode_t = 0;"
      },
      {
        "span": "src/truncate.rs:356:1: 356:37 (#0)",
        "source": "static mut block_mode: bool = false;"
      },
      {
        "span": "src/truncate.rs:355:1: 355:36 (#0)",
        "source": "static mut no_create: bool = false;"
      },
      {
        "span": "src/truncate.rs:202:1: 202:34 (#0)",
        "source": "pub const rm_rdn: rel_mode_t = 4;"
      },
      {
        "span": "src/truncate.rs:201:1: 201:34 (#0)",
        "source": "pub const rm_rup: rel_mode_t = 5;"
      },
      {
        "span": "src/truncate.rs:205:1: 205:34 (#0)",
        "source": "pub const rm_rel: rel_mode_t = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/truncate.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:113 ~ truncate[c51a]::main)",
    "span": "src/truncate.rs:1949:1: 1967:2 (#0)",
    "pieces": [
      "src/truncate.rs:1949:1: 1967:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:96 ~ truncate[c51a]::usable_st_size)",
    "span": "src/truncate.rs:208:1: 214:2 (#0)",
    "pieces": [
      "src/truncate.rs:208:1: 214:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn usable_st_size(mut sb: *const stat) -> bool {\n    return (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n        || ((*sb).st_mode).wrapping_sub((*sb).st_mode) != 0 || 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:3:1: 3:15 (#0)",
        "source": "use ::rust::*;"
      }
    ],
    "chunks": []
  }
]