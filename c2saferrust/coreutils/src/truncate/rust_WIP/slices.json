[
  {
    "func_defid": "DefId(0:848 ~ rust[fc84]::src::xmalloc::_gl_alloc_nomem)",
    "span": "src/xmalloc.rs:95:1: 98:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:95:1: 98:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [
      {
        "caller": "DefId(0:963 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:65:13: 65:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      },
      {
        "caller": "DefId(0:962 ~ rust[fc84]::src::xmalloc::irealloc)",
        "span": "src/xmalloc.rs:57:12: 59:6 (#0)",
        "source": "{\n        return _gl_alloc_nomem()\n    }"
      },
      {
        "caller": "DefId(0:963 ~ rust[fc84]::src::xmalloc::icalloc)",
        "span": "src/xmalloc.rs:71:13: 71:38 (#0)",
        "source": "return _gl_alloc_nomem();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:847 ~ rust[fc84]::src::xmalloc::ireallocarray)",
    "span": "src/xmalloc.rs:78:1: 91:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:78:1: 91:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:692 ~ rust[fc84]::src::quotearg::gettext_quote)",
    "span": "src/quotearg.rs:306:1: 339:2 (#0)",
    "pieces": [
      "src/quotearg.rs:306:1: 339:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "unsafe extern \"C\" fn gettext_quote(\n    mut msgid: *const libc::c_char,\n    mut s: quoting_style,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(msgid);\n    let mut locale_code: *const libc::c_char = 0 as *const libc::c_char;\n    if translation != msgid {\n        return translation;\n    }\n    locale_code = locale_charset();\n    if c_strcasecmp(locale_code, b\"UTF-8\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xE2\\x80\\x98\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xE2\\x80\\x99\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    if c_strcasecmp(locale_code, b\"GB18030\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n    {\n        return if *msgid.offset(0 as libc::c_int as isize) as libc::c_int == '`' as i32 {\n            b\"\\xA1\\x07e\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\xA1\\xAF\\0\" as *const u8 as *const libc::c_char\n        };\n    }\n    return if s as libc::c_uint == clocale_quoting_style as libc::c_int as libc::c_uint {\n        b\"\\\"\\0\" as *const u8 as *const libc::c_char\n    } else {\n        b\"'\\0\" as *const u8 as *const libc::c_char\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:776 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:386:21: 389:23 (#0)",
        "source": "left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );"
      },
      {
        "caller": "DefId(0:776 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:390:21: 393:23 (#0)",
        "source": "right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:693 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
    "span": "src/quotearg.rs:340:1: 1185:2 (#0)",
    "pieces": [
      "src/quotearg.rs:340:1: 351:4 (#0)",
      "src/quotearg.rs:1185:1: 1185:2 (#0)"
    ],
    "sub_chunks": [
      11
    ],
    "num_lines": 13,
    "source": "unsafe extern \"C\" fn quotearg_buffer_restyled(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut quoting_style: quoting_style,\n    mut flags: libc::c_int,\n    mut quote_these_too: *const libc::c_uint,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) -> size_t {\n   <<chunk 11>>}",
    "calls": [
      {
        "caller": "DefId(0:777 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
        "span": "src/quotearg.rs:1197:13: 1209:6 (#0)",
        "source": "unsafe {\n        quotearg_buffer_restyled(\n            buffer.as_mut_ptr(),\n            buffer.len() as u64,\n            arg.as_ptr(),\n            arg.len() as u64,\n            p.style,\n            p.flags,\n            p.quote_these_too.as_ptr(),\n            p.left_quote,\n            p.right_quote,\n        )\n    }"
      },
      {
        "caller": "DefId(0:779 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1257:5: 1267:7 (#0)",
        "source": "quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:776 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1155:13: 1165:15 (#0)",
        "source": "return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );"
      },
      {
        "caller": "DefId(0:776 ~ rust[fc84]::src::quotearg::quotearg_buffer_restyled)",
        "span": "src/quotearg.rs:1126:5: 1136:7 (#0)",
        "source": "return quotearg_buffer_restyled(\n        buffer,\n        orig_buffersize,\n        arg,\n        argsize,\n        c_quoting_style,\n        flags,\n        quote_these_too,\n        left_quote,\n        right_quote,\n    );"
      },
      {
        "caller": "DefId(0:789 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1378:9: 1388:11 (#0)",
        "source": "quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );"
      },
      {
        "caller": "DefId(0:789 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
        "span": "src/quotearg.rs:1358:5: 1368:7 (#0)",
        "source": "let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );"
      },
      {
        "caller": "DefId(0:779 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
        "span": "src/quotearg.rs:1244:5: 1255:58 (#0)",
        "source": "let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:87:1: 87:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/quotearg.rs:94:1: 94:52 (#0)",
        "source": "pub const QA_ELIDE_OUTER_QUOTES: quoting_flags = 2;"
      },
      {
        "span": "src/quotearg.rs:86:1: 86:46 (#0)",
        "source": "pub const c_quoting_style: quoting_style = 5;"
      },
      {
        "span": "src/quotearg.rs:89:1: 89:57 (#0)",
        "source": "pub const shell_always_quoting_style: quoting_style = 2;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/quotearg.rs:513:9: 557:2 (#0)",
        "pieces": [
          "src/quotearg.rs:513:9: 557:2 (#0)"
        ],
        "num_lines": 64,
        "source": "if backslash_escapes {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        escaping = 1 as libc::c_int != 0;\n                        if quoting_style as libc::c_uint\n                            == shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && !pending_shell_escape_end\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            pending_shell_escape_end = 1 as libc::c_int != 0;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                            && i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                                < argsize\n                            && '0' as i32\n                                <= *arg\n                                    .offset(\n                                        i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                    ) as libc::c_int\n                            && *arg\n                                .offset(\n                                    i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                ) as libc::c_int <= '9' as i32\n                        {\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = '0' as i32 as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                        }\n                        c = '0' as i32 as libc::c_uchar;\n                        current_block = 253337042034819032;\n                    } else if flags & QA_ELIDE_NULL_BYTES as libc::c_int != 0 {\n                        current_block = 13619784596304402172;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut escaping: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut escaping: bool"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/quotearg.rs:562:9: 692:22 (#0)",
        "pieces": [
          "src/quotearg.rs:562:9: 692:22 (#0)"
        ],
        "num_lines": 131,
        "source": "match quoting_style as libc::c_uint {\n                        2 => {\n                            current_block = 17954593875197965021;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        5 => {\n                            current_block = 14514781131754033399;\n                            match current_block {\n                                17954593875197965021 => {\n                                    if elide_outer_quotes {\n                                        current_block = 7928555609993211441;\n                                        break 's_25;\n                                    }\n                                }\n                                _ => {\n                                    if flags & QA_SPLIT_TRIGRAPHS as libc::c_int != 0\n                                        && i.wrapping_add(2 as libc::c_int as libc::c_ulong)\n                                            < argsize\n                                        && *arg\n                                            .offset(\n                                                i.wrapping_add(1 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int == '?' as i32\n                                    {\n                                        match *arg\n                                            .offset(\n                                                i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                            ) as libc::c_int\n                                        {\n                                            33 | 39 | 40 | 41 | 45 | 47 | 60 | 61 | 62 => {\n                                                if elide_outer_quotes {\n                                                    current_block = 7928555609993211441;\n                                                    break 's_25;\n                                                }\n                                                c = *arg\n                                                    .offset(\n                                                        i.wrapping_add(2 as libc::c_int as libc::c_ulong) as isize,\n                                                    ) as libc::c_uchar;\n                                                i = (i as libc::c_ulong)\n                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t\n                                                    as size_t;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                                if len < buffersize {\n                                                    *buffer.offset(len as isize) = '?' as i32 as libc::c_char;\n                                                }\n                                                len = len.wrapping_add(1);\n                                                len;\n                                            }\n                                            _ => {}\n                                        }\n                                    }\n                                }\n                            }\n                            current_block = 253337042034819032;\n                        }\n                        _ => {\n                            current_block = 253337042034819032;\n                        }\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut elide_outer_quotes: bool",
          "mut c: u8"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut elide_outer_quotes: bool",
          "mut c: u8"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/quotearg.rs:724:9: 735:2 (#0)",
        "pieces": [
          "src/quotearg.rs:724:9: 735:2 (#0)"
        ],
        "num_lines": 17,
        "source": "esc = c;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        current_block = 4476262310586904498;\n                    } else if backslash_escapes as libc::c_int != 0\n                        && elide_outer_quotes as libc::c_int != 0\n                        && quote_string_len != 0\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 9215498979640025612;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut esc: u8"
        ],
        "live_out": [
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut esc: u8"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/quotearg.rs:740:9: 750:22 (#0)",
        "pieces": [
          "src/quotearg.rs:740:9: 750:22 (#0)"
        ],
        "num_lines": 11,
        "source": "if if argsize == 18446744073709551615 as libc::c_ulong {\n                        (*arg.offset(1 as libc::c_int as isize) as libc::c_int\n                            == '\\0' as i32) as libc::c_int\n                    } else {\n                        (argsize == 1 as libc::c_int as libc::c_ulong) as libc::c_int\n                    } == 0\n                    {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 16442922512115311366;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut current_block: u64"
        ],
        "live_out": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/quotearg.rs:772:9: 809:2 (#0)",
        "pieces": [
          "src/quotearg.rs:772:9: 809:2 (#0)"
        ],
        "num_lines": 33,
        "source": "encountered_single_quote = 1 as libc::c_int != 0;\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                    {\n                        if elide_outer_quotes {\n                            current_block = 7928555609993211441;\n                            break 's_25;\n                        }\n                        if buffersize != 0 && orig_buffersize == 0 {\n                            orig_buffersize = buffersize;\n                            buffersize = 0 as libc::c_int as size_t;\n                        }\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/quotearg.rs:823:9: 892:58 (#0)",
        "pieces": [
          "src/quotearg.rs:823:9: 892:58 (#0)"
        ],
        "num_lines": 70,
        "source": "let mut m: size_t = 0;\n                    let mut printable: bool = false;\n                    if unibyte_locale {\n                        m = 1 as libc::c_int as size_t;\n                        printable = *(*__ctype_b_loc()).offset(c as libc::c_int as isize)\n                            as libc::c_int\n                            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int\n                            != 0 as libc::c_int;\n                    } else {\n                        let mut mbstate: mbstate_t = mbstate_t {\n                            __count: 0,\n                            __value: C2RustUnnamed { __wch: 0 },\n                        };\n                        mbszero(&mut mbstate);\n                        m = 0 as libc::c_int as size_t;\n                        printable = 1 as libc::c_int != 0;\n                        if argsize == 18446744073709551615 as libc::c_ulong {\n                            argsize = strlen(arg);\n                        }\n                        let mut w: char32_t = 0;\n                        let mut bytes: size_t = rpl_mbrtoc32(\n                            &mut w,\n                            &*arg.offset(i.wrapping_add(m) as isize),\n                            argsize.wrapping_sub(i.wrapping_add(m)),\n                            &mut mbstate,\n                        );\n                        if !(bytes == 0 as libc::c_int as libc::c_ulong) {\n                            if bytes == -(1 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                            } else if bytes == -(2 as libc::c_int) as size_t {\n                                printable = 0 as libc::c_int != 0;\n                                while i.wrapping_add(m) < argsize\n                                    && *arg.offset(i.wrapping_add(m) as isize) as libc::c_int\n                                        != 0\n                                {\n                                    m = m.wrapping_add(1);\n                                    m;\n                                }\n                            } else {\n                                if '[' as i32 == 0x5b as libc::c_int\n                                    && elide_outer_quotes as libc::c_int != 0\n                                    && quoting_style as libc::c_uint\n                                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                {\n                                    let mut j: size_t = 0;\n                                    j = 1 as libc::c_int as size_t;\n                                    while j < bytes {\n                                        match *arg\n                                            .offset(i.wrapping_add(m).wrapping_add(j) as isize)\n                                            as libc::c_int\n                                        {\n                                            91 | 92 | 94 | 96 | 124 => {\n                                                current_block = 7928555609993211441;\n                                                break 's_25;\n                                            }\n                                            _ => {}\n                                        }\n                                        j = j.wrapping_add(1);\n                                        j;\n                                    }\n                                }\n                                if c32isprint(w) == 0 {\n                                    printable = 0 as libc::c_int != 0;\n                                }\n                                m = (m as libc::c_ulong).wrapping_add(bytes) as size_t\n                                    as size_t;\n                            }\n                        }\n                    }\n                    c_and_shell_quote_compat = printable;",
        "sub_chunks": [],
        "live_in": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut i: u64",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut current_block: u64",
          "mut i: u64",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut c_and_shell_quote_compat: bool",
          "mut m: u64",
          "mut printable: bool"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/quotearg.rs:894:9: 963:2 (#0)",
        "pieces": [
          "src/quotearg.rs:894:9: 963:2 (#0)"
        ],
        "num_lines": 96,
        "source": "if (1 as libc::c_int as libc::c_ulong) < m\n                        || backslash_escapes as libc::c_int != 0 && !printable\n                    {\n                        let mut ilim: size_t = i.wrapping_add(m);\n                        loop {\n                            if backslash_escapes as libc::c_int != 0 && !printable {\n                                if elide_outer_quotes {\n                                    current_block = 7928555609993211441;\n                                    break 's_25;\n                                }\n                                escaping = 1 as libc::c_int != 0;\n                                if quoting_style as libc::c_uint\n                                    == shell_always_quoting_style as libc::c_int as libc::c_uint\n                                    && !pending_shell_escape_end\n                                {\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    if len < buffersize {\n                                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                    }\n                                    len = len.wrapping_add(1);\n                                    len;\n                                    pending_shell_escape_end = 1 as libc::c_int != 0;\n                                }\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32 + (c as libc::c_int >> 6 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer\n                                        .offset(\n                                            len as isize,\n                                        ) = ('0' as i32\n                                        + (c as libc::c_int >> 3 as libc::c_int & 7 as libc::c_int))\n                                        as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                c = ('0' as i32 + (c as libc::c_int & 7 as libc::c_int))\n                                    as libc::c_uchar;\n                            } else if is_right_quote {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                is_right_quote = 0 as libc::c_int != 0;\n                            }\n                            if ilim <= i.wrapping_add(1 as libc::c_int as libc::c_ulong)\n                            {\n                                break;\n                            }\n                            if pending_shell_escape_end as libc::c_int != 0 && !escaping\n                            {\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                if len < buffersize {\n                                    *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                                }\n                                len = len.wrapping_add(1);\n                                len;\n                                pending_shell_escape_end = 0 as libc::c_int != 0;\n                            }\n                            if len < buffersize {\n                                *buffer.offset(len as isize) = c as libc::c_char;\n                            }\n                            len = len.wrapping_add(1);\n                            len;\n                            i = i.wrapping_add(1);\n                            c = *arg.offset(i as isize) as libc::c_uchar;\n                        }\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 253337042034819032;\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut m: u64",
          "mut printable: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut quoting_style: u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut m: u64",
          "mut printable: bool"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/quotearg.rs:484:13: 1019:3 (#0)",
        "pieces": [
          "src/quotearg.rs:484:13: 513:8 (#0)",
          "src/quotearg.rs:559:1: 562:8 (#0)",
          "src/quotearg.rs:693:1: 724:8 (#0)",
          "src/quotearg.rs:737:1: 740:8 (#0)",
          "src/quotearg.rs:751:1: 772:8 (#0)",
          "src/quotearg.rs:811:1: 823:8 (#0)",
          "src/quotearg.rs:893:1: 894:8 (#0)",
          "src/quotearg.rs:965:1: 1019:3 (#0)"
        ],
        "num_lines": 154,
        "source": "let mut c: libc::c_uchar = 0;\n            let mut esc: libc::c_uchar = 0;\n            let mut is_right_quote: bool = 0 as libc::c_int != 0;\n            let mut escaping: bool = 0 as libc::c_int != 0;\n            let mut c_and_shell_quote_compat: bool = 0 as libc::c_int != 0;\n            if backslash_escapes as libc::c_int != 0\n                && quoting_style as libc::c_uint\n                    != shell_always_quoting_style as libc::c_int as libc::c_uint\n                && quote_string_len != 0\n                && i.wrapping_add(quote_string_len)\n                    <= (if argsize == 18446744073709551615 as libc::c_ulong\n                        && (1 as libc::c_int as libc::c_ulong) < quote_string_len\n                    {\n                        argsize = strlen(arg);\n                        argsize\n                    } else {\n                        argsize\n                    })\n                && memcmp(\n                    arg.offset(i as isize) as *const libc::c_void,\n                    quote_string as *const libc::c_void,\n                    quote_string_len,\n                ) == 0 as libc::c_int\n            {\n                if elide_outer_quotes {\n                    current_block = 7928555609993211441;\n                    break 's_25;\n                }\n                is_right_quote = 1 as libc::c_int != 0;\n            }\n            c = *arg.offset(i as isize) as libc::c_uchar;\n            match c as libc::c_int {\n                0 => {\n                   <<chunk 0>>                }\n                63 => {\n                   <<chunk 1>>                }\n                7 => {\n                    esc = 'a' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                8 => {\n                    esc = 'b' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                12 => {\n                    esc = 'f' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                10 => {\n                    esc = 'n' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                13 => {\n                    esc = 'r' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                9 => {\n                    esc = 't' as i32 as libc::c_uchar;\n                    current_block = 9215498979640025612;\n                }\n                11 => {\n                    esc = 'v' as i32 as libc::c_uchar;\n                    current_block = 1190876092451756080;\n                }\n                92 => {\n                   <<chunk 2>>                }\n                123 | 125 => {\n                   <<chunk 3>>                }\n                35 | 126 => {\n                    current_block = 16442922512115311366;\n                }\n                32 => {\n                    current_block = 4634307283396172174;\n                }\n                33 => {\n                    current_block = 7549413860336125482;\n                }\n                34 | 36 | 38 | 40 | 41 | 42 | 59 | 60 | 61 => {\n                    current_block = 13059411171234995867;\n                }\n                62 | 91 | 94 => {\n                    current_block = 16620298045565028098;\n                }\n                96 | 124 => {\n                    current_block = 15155215915847730705;\n                }\n                39 => {\n                   <<chunk 4>>                }\n                37 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56\n                | 57 | 58 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76\n                | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90\n                | 93 | 95 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107\n                | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119\n                | 120 | 121 | 122 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 253337042034819032;\n                }\n                _ => {\n                   <<chunk 5>>                   <<chunk 6>>                }\n            }\n            match current_block {\n                16442922512115311366 => {\n                    if i != 0 as libc::c_int as libc::c_ulong {\n                        current_block = 253337042034819032;\n                    } else {\n                        current_block = 4634307283396172174;\n                    }\n                }\n                9215498979640025612 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 1190876092451756080;\n                }\n                _ => {}\n            }\n            match current_block {\n                1190876092451756080 => {\n                    if backslash_escapes {\n                        c = esc;\n                        current_block = 3173013908131212616;\n                    } else {\n                        current_block = 253337042034819032;\n                    }\n                }\n                4634307283396172174 => {\n                    c_and_shell_quote_compat = 1 as libc::c_int != 0;\n                    current_block = 7549413860336125482;\n                }\n                _ => {}\n            }\n            match current_block {\n                7549413860336125482 => {\n                    current_block = 13059411171234995867;\n                }\n                _ => {}\n            }\n            match current_block {\n                13059411171234995867 => {\n                    current_block = 16620298045565028098;\n                }\n                _ => {}\n            }",
        "sub_chunks": [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut c: u8",
          "mut esc: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut c_and_shell_quote_compat: bool",
          "arg_slice: &[u8]",
          "mut current_block: u64"
        ]
      },
      {
        "chunk_id": 8,
        "span": "src/quotearg.rs:1021:13: 1107:8 (#0)",
        "pieces": [
          "src/quotearg.rs:1021:13: 1107:8 (#0)"
        ],
        "num_lines": 113,
        "source": "match current_block {\n                16620298045565028098 => {\n                    current_block = 15155215915847730705;\n                }\n                _ => {}\n            }\n            match current_block {\n                15155215915847730705 => {\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && elide_outer_quotes as libc::c_int != 0\n                    {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    current_block = 253337042034819032;\n                }\n                _ => {}\n            }\n            match current_block {\n                253337042034819032 => {\n                    if !((backslash_escapes as libc::c_int != 0\n                        && quoting_style as libc::c_uint\n                            != shell_always_quoting_style as libc::c_int as libc::c_uint\n                        || elide_outer_quotes as libc::c_int != 0)\n                        && !quote_these_too.is_null()\n                        && *quote_these_too\n                            .offset(\n                                (c as libc::c_ulong)\n                                    .wrapping_div(\n                                        (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                    ) as isize,\n                            )\n                            >> (c as libc::c_ulong)\n                                .wrapping_rem(\n                                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                                ) & 1 as libc::c_int as libc::c_uint != 0)\n                        && !is_right_quote\n                    {\n                        current_block = 4476262310586904498;\n                    } else {\n                        current_block = 3173013908131212616;\n                    }\n                }\n                _ => {}\n            }\n            match current_block {\n                3173013908131212616 => {\n                    if elide_outer_quotes {\n                        current_block = 7928555609993211441;\n                        break 's_25;\n                    }\n                    escaping = 1 as libc::c_int != 0;\n                    if quoting_style as libc::c_uint\n                        == shell_always_quoting_style as libc::c_int as libc::c_uint\n                        && !pending_shell_escape_end\n                    {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '$' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 1 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\\\' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    current_block = 4476262310586904498;\n                }\n                _ => {}\n            }\n            match current_block {\n                4476262310586904498 => {\n                    if pending_shell_escape_end as libc::c_int != 0 && !escaping {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        pending_shell_escape_end = 0 as libc::c_int != 0;\n                    }\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = c as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    if !c_and_shell_quote_compat {\n                        all_c_and_shell_quote_compat = 0 as libc::c_int != 0;\n                    }\n                }\n                _ => {}\n            }\n            i = i.wrapping_add(1);\n            i;",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut quote_these_too: *const u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut all_c_and_shell_quote_compat: bool",
          "mut c: u8",
          "mut is_right_quote: bool",
          "mut escaping: bool",
          "mut c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut quoting_style: u32",
          "mut quote_these_too: *const u32",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut backslash_escapes: bool",
          "mut elide_outer_quotes: bool",
          "mut all_c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 9,
        "span": "src/quotearg.rs:366:9: 1124:10 (#0)",
        "pieces": [
          "src/quotearg.rs:366:9: 484:12 (#0)",
          "src/quotearg.rs:1021:1: 1021:12 (#0)",
          "src/quotearg.rs:1109:1: 1124:10 (#0)"
        ],
        "num_lines": 136,
        "source": "pending_shell_escape_end = 0 as libc::c_int != 0;\n        let mut current_block_48: u64;\n        match quoting_style as libc::c_uint {\n            6 => {\n                quoting_style = c_quoting_style;\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 1283995450065962895;\n            }\n            5 => {\n                current_block_48 = 1283995450065962895;\n            }\n            7 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            8 | 9 | 10 => {\n                if quoting_style as libc::c_uint\n                    != custom_quoting_style as libc::c_int as libc::c_uint\n                {\n                    left_quote = gettext_quote(\n                        b\"`\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                    right_quote = gettext_quote(\n                        b\"'\\0\" as *const u8 as *const libc::c_char,\n                        quoting_style,\n                    );\n                }\n                if !elide_outer_quotes {\n                    quote_string = left_quote;\n                    while *quote_string != 0 {\n                        if len < buffersize {\n                            *buffer.offset(len as isize) = *quote_string;\n                        }\n                        len = len.wrapping_add(1);\n                        len;\n                        quote_string = quote_string.offset(1);\n                        quote_string;\n                    }\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = right_quote;\n                quote_string_len = strlen(quote_string);\n                current_block_48 = 2989495919056355252;\n            }\n            3 => {\n                backslash_escapes = 1 as libc::c_int != 0;\n                current_block_48 = 2694013637280298776;\n            }\n            1 => {\n                current_block_48 = 2694013637280298776;\n            }\n            4 => {\n                current_block_48 = 2266290538919981374;\n            }\n            2 => {\n                current_block_48 = 14141891332124833771;\n            }\n            0 => {\n                elide_outer_quotes = 0 as libc::c_int != 0;\n                current_block_48 = 2989495919056355252;\n            }\n            _ => {\n                abort();\n            }\n        }\n        match current_block_48 {\n            1283995450065962895 => {\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\"' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                backslash_escapes = 1 as libc::c_int != 0;\n                quote_string = b\"\\\"\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n                current_block_48 = 2989495919056355252;\n            }\n            2694013637280298776 => {\n                elide_outer_quotes = 1 as libc::c_int != 0;\n                current_block_48 = 2266290538919981374;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            2266290538919981374 => {\n                if !elide_outer_quotes {\n                    backslash_escapes = 1 as libc::c_int != 0;\n                }\n                current_block_48 = 14141891332124833771;\n            }\n            _ => {}\n        }\n        match current_block_48 {\n            14141891332124833771 => {\n                quoting_style = shell_always_quoting_style;\n                if !elide_outer_quotes {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = '\\'' as i32 as libc::c_char;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                }\n                quote_string = b\"'\\0\" as *const u8 as *const libc::c_char;\n                quote_string_len = 1 as libc::c_int as size_t;\n            }\n            _ => {}\n        }\n        i = 0 as libc::c_int as size_t;\n        while if argsize == 18446744073709551615 as libc::c_ulong {\n            (*arg.offset(i as isize) as libc::c_int == '\\0' as i32) as libc::c_int\n        } else {\n            (i == argsize) as libc::c_int\n        } == 0\n        {\n           <<chunk 7>>           <<chunk 8>>        }\n        if len == 0 as libc::c_int as libc::c_ulong\n            && quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && elide_outer_quotes as libc::c_int != 0\n        {\n            current_block = 7928555609993211441;\n            break;\n        }\n        if !(quoting_style as libc::c_uint\n            == shell_always_quoting_style as libc::c_int as libc::c_uint\n            && !elide_outer_quotes && encountered_single_quote as libc::c_int != 0)\n        {\n            current_block = 6412618891452676311;\n            break;\n        }",
        "sub_chunks": [
          7,
          8
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool",
          "mut current_block_48: u64"
        ]
      },
      {
        "chunk_id": 10,
        "span": "src/quotearg.rs:1125:9: 1144:2 (#0)",
        "pieces": [
          "src/quotearg.rs:1125:9: 1144:2 (#0)"
        ],
        "num_lines": 20,
        "source": "if all_c_and_shell_quote_compat {\n            return quotearg_buffer_restyled(\n                buffer,\n                orig_buffersize,\n                arg,\n                argsize,\n                c_quoting_style,\n                flags,\n                quote_these_too,\n                left_quote,\n                right_quote,\n            )\n        } else {\n            if !(buffersize == 0 && orig_buffersize != 0) {\n                current_block = 6412618891452676311;\n                break;\n            }\n            buffersize = orig_buffersize;\n            len = 0 as libc::c_int as size_t;\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut all_c_and_shell_quote_compat: bool"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut current_block: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut all_c_and_shell_quote_compat: bool"
        ]
      },
      {
        "chunk_id": 11,
        "span": "src/quotearg.rs:351:5: 1184:7 (#0)",
        "pieces": [
          "src/quotearg.rs:351:5: 366:8 (#0)",
          "src/quotearg.rs:1125:1: 1125:8 (#0)",
          "src/quotearg.rs:1146:1: 1184:7 (#0)"
        ],
        "num_lines": 56,
        "source": "let mut pending_shell_escape_end: bool = false;\n    let mut current_block: u64;\n    let mut i: size_t = 0;\n    let mut len: size_t = 0 as libc::c_int as size_t;\n    let mut orig_buffersize: size_t = 0 as libc::c_int as size_t;\n    let mut quote_string: *const libc::c_char = 0 as *const libc::c_char;\n    let mut quote_string_len: size_t = 0 as libc::c_int as size_t;\n    let mut backslash_escapes: bool = 0 as libc::c_int != 0;\n    let mut unibyte_locale: bool = __ctype_get_mb_cur_max()\n        == 1 as libc::c_int as libc::c_ulong;\n    let mut elide_outer_quotes: bool = flags & QA_ELIDE_OUTER_QUOTES as libc::c_int\n        != 0 as libc::c_int;\n    let mut encountered_single_quote: bool = 0 as libc::c_int != 0;\n    let mut all_c_and_shell_quote_compat: bool = 1 as libc::c_int != 0;\n    's_25: loop {\n       <<chunk 9>>       <<chunk 10>>    }\n    match current_block {\n        7928555609993211441 => {\n            if quoting_style as libc::c_uint\n                == shell_always_quoting_style as libc::c_int as libc::c_uint\n                && backslash_escapes as libc::c_int != 0\n            {\n                quoting_style = shell_escape_always_quoting_style;\n            }\n            return quotearg_buffer_restyled(\n                buffer,\n                buffersize,\n                arg,\n                argsize,\n                quoting_style,\n                flags & !(QA_ELIDE_OUTER_QUOTES as libc::c_int),\n                0 as *const libc::c_uint,\n                left_quote,\n                right_quote,\n            );\n        }\n        _ => {\n            if !quote_string.is_null() && !elide_outer_quotes {\n                while *quote_string != 0 {\n                    if len < buffersize {\n                        *buffer.offset(len as isize) = *quote_string;\n                    }\n                    len = len.wrapping_add(1);\n                    len;\n                    quote_string = quote_string.offset(1);\n                    quote_string;\n                }\n            }\n            if len < buffersize {\n                *buffer.offset(len as isize) = '\\0' as i32 as libc::c_char;\n            }\n            return len;\n        }\n    };",
        "sub_chunks": [
          9,
          10
        ],
        "live_in": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8"
        ],
        "live_out": [
          "mut buffer: *mut i8",
          "mut buffersize: u64",
          "mut arg: *const i8",
          "mut argsize: u64",
          "mut quoting_style: u32",
          "mut flags: i32",
          "mut quote_these_too: *const u32",
          "mut left_quote: *const i8",
          "mut right_quote: *const i8",
          "mut pending_shell_escape_end: bool",
          "mut current_block: u64",
          "mut i: u64",
          "mut len: u64",
          "mut orig_buffersize: u64",
          "mut quote_string: *const i8",
          "mut quote_string_len: u64",
          "mut backslash_escapes: bool",
          "mut unibyte_locale: bool",
          "mut elide_outer_quotes: bool",
          "mut encountered_single_quote: bool",
          "mut all_c_and_shell_quote_compat: bool"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:706 ~ rust[fc84]::src::quotearg::quotearg_n_options)",
    "span": "src/quotearg.rs:1314:1: 1392:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1314:1: 1392:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 79,
    "source": "unsafe extern \"C\" fn quotearg_n_options(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut options: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut e: libc::c_int = *__errno_location();\n    let mut sv: *mut slotvec = slotvec;\n    let mut nslots_max: libc::c_int = (if (2147483647 as libc::c_int as libc::c_long)\n        < 9223372036854775807 as libc::c_long\n    {\n        2147483647 as libc::c_int as libc::c_long\n    } else {\n        9223372036854775807 as libc::c_long\n    }) as libc::c_int;\n    if !(0 as libc::c_int <= n && n < nslots_max) {\n        abort();\n    }\n    if nslots <= n {\n        let mut preallocated: bool = sv == &mut slotvec0 as *mut slotvec;\n        let mut new_nslots: idx_t = nslots as idx_t;\n        sv = xpalloc(\n            (if preallocated as libc::c_int != 0 { 0 as *mut slotvec } else { sv })\n                as *mut libc::c_void,\n            &mut new_nslots,\n            (n - nslots + 1 as libc::c_int) as idx_t,\n            nslots_max as ptrdiff_t,\n            ::core::mem::size_of::<slotvec>() as libc::c_ulong as idx_t,\n        ) as *mut slotvec;\n        slotvec = sv;\n        if preallocated {\n            *sv = slotvec0;\n        }\n        memset(\n            sv.offset(nslots as isize) as *mut libc::c_void,\n            0 as libc::c_int,\n            ((new_nslots - nslots as libc::c_long) as libc::c_ulong)\n                .wrapping_mul(::core::mem::size_of::<slotvec>() as libc::c_ulong),\n        );\n        nslots = new_nslots as libc::c_int;\n    }\n    let mut size: size_t = (*sv.offset(n as isize)).size;\n    let mut val: *mut libc::c_char = (*sv.offset(n as isize)).val;\n    let mut flags: libc::c_int = (*options).flags | QA_ELIDE_NULL_BYTES as libc::c_int;\n    let mut qsize: size_t = quotearg_buffer_restyled(\n        val,\n        size,\n        arg,\n        argsize,\n        (*options).style,\n        flags,\n        ((*options).quote_these_too).as_ptr(),\n        (*options).left_quote,\n        (*options).right_quote,\n    );\n    if size <= qsize {\n        size = qsize.wrapping_add(1 as libc::c_int as libc::c_ulong);\n        (*sv.offset(n as isize)).size = size;\n        if val != slot0.as_mut_ptr() {\n            free(val as *mut libc::c_void);\n        }\n        val = xcharalloc(size);\n        let ref mut fresh0 = (*sv.offset(n as isize)).val;\n        *fresh0 = val;\n        quotearg_buffer_restyled(\n            val,\n            size,\n            arg,\n            argsize,\n            (*options).style,\n            flags,\n            ((*options).quote_these_too).as_ptr(),\n            (*options).left_quote,\n            (*options).right_quote,\n        );\n    }\n    *__errno_location() = e;\n    return val;\n}",
    "calls": [
      {
        "caller": "DefId(0:794 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1439:5: 1441:6 (#0)",
        "source": "unsafe {\n        quotearg_n_options(n, arg.as_ptr(), u64::MAX, &o)\n    }"
      },
      {
        "caller": "DefId(0:810 ~ rust[fc84]::src::quotearg::quote_n_mem)",
        "span": "src/quotearg.rs:1629:5: 1629:76 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);"
      },
      {
        "caller": "DefId(0:795 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1452:5: 1452:64 (#0)",
        "source": "unsafe { quotearg_n_options(n, arg.as_ptr(), argsize, &o) }"
      },
      {
        "caller": "DefId(0:790 ~ rust[fc84]::src::quotearg::quotearg_n)",
        "span": "src/quotearg.rs:1398:5: 1403:7 (#0)",
        "source": "return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );"
      },
      {
        "caller": "DefId(0:806 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1565:5: 1565:56 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut o);"
      },
      {
        "caller": "DefId(0:798 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1488:5: 1488:77 (#0)",
        "source": "return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);"
      },
      {
        "caller": "DefId(0:791 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
        "span": "src/quotearg.rs:1411:5: 1411:78 (#0)",
        "source": "return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);"
      },
      {
        "caller": "DefId(0:803 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1530:9: 1535:11 (#0)",
        "source": "let result = quotearg_n_options(\n            n,\n            arg.as_ptr(),\n            u64::MAX,\n            &mut options,\n        );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1276:1: 1284:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:1285:1: 1287:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:95:1: 95:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      },
      {
        "span": "src/quotearg.rs:1275:1: 1275:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:727 ~ rust[fc84]::src::quotearg::quote_n_mem)",
    "span": "src/quotearg.rs:1624:1: 1630:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1624:1: 1630:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quote_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut quote_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:812 ~ rust[fc84]::src::quotearg::quote_n)",
        "span": "src/quotearg.rs:1641:5: 1641:59 (#0)",
        "source": "unsafe { quote_n_mem(n, c_string.as_ptr(), u64::MAX) }"
      },
      {
        "caller": "DefId(0:811 ~ rust[fc84]::src::quotearg::quote_mem)",
        "span": "src/quotearg.rs:1634:37: 1634:85 (#0)",
        "source": "unsafe { quote_n_mem(0, arg.as_ptr(), argsize) }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:1613:1: 1622:3 (#0)",
        "source": "pub static mut quote_quoting_options: quoting_options = {\n    let mut init = quoting_options {\n        style: locale_quoting_style,\n        flags: 0 as libc::c_int,\n        quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    init\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:850 ~ rust[fc84]::src::xmalloc::check_nonnull)",
    "span": "src/xmalloc.rs:114:1: 119:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:114:1: 119:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn check_nonnull(mut p: *mut libc::c_void) -> *mut libc::c_void {\n    if p.is_null() {\n        xalloc_die();\n    }\n    return p;\n}",
    "calls": [
      {
        "caller": "DefId(0:969 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:128:1: 128:40 (#0)",
        "source": "return check_nonnull(allocated_memory);"
      },
      {
        "caller": "DefId(0:968 ~ rust[fc84]::src::xmalloc::xmalloc)",
        "span": "src/xmalloc.rs:123:5: 123:37 (#0)",
        "source": "return check_nonnull(malloc(s));"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:857 ~ rust[fc84]::src::xmalloc::xireallocarray)",
    "span": "src/xmalloc.rs:182:1: 188:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:182:1: 188:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn xireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(ireallocarray(p, n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:148 ~ rust[fc84]::src::hard_locale::hard_locale)",
    "span": "src/hard_locale.rs:14:1: 30:2 (#0)",
    "pieces": [
      "src/hard_locale.rs:14:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn hard_locale(mut category: libc::c_int) -> bool {\n    let mut locale: [libc::c_char; 257] = [0; 257];\n    if setlocale_null_r(\n        category,\n        locale.as_mut_ptr(),\n        ::core::mem::size_of::<[libc::c_char; 257]>() as libc::c_ulong,\n    ) != 0\n    {\n        return 0 as libc::c_int != 0;\n    }\n    if !(strcmp(locale.as_mut_ptr(), b\"C\\0\" as *const u8 as *const libc::c_char)\n        == 0 as libc::c_int\n        || strcmp(locale.as_mut_ptr(), b\"POSIX\\0\" as *const u8 as *const libc::c_char)\n            == 0 as libc::c_int)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/hard_locale.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/hard_locale.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:169 ~ rust[fc84]::src::ialloc::_gl_alloc_nomem)",
    "span": "src/ialloc.rs:110:1: 116:2 (#0)",
    "pieces": [
      "src/ialloc.rs:110:1: 116:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 4,
    "source": "pub unsafe extern \"C\" fn _gl_alloc_nomem() -> *mut libc::c_void {\n    *__errno_location() = 12 as libc::c_int;\n    return 0 as *mut libc::c_void;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:10:1: 10:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/ialloc.rs:2:1: 2:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/ialloc.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:16 (#0)",
        "source": "use std::alloc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:865 ~ rust[fc84]::src::xmalloc::xcalloc)",
    "span": "src/xmalloc.rs:965:1: 970:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:965:1: 970:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xcalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(calloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:863 ~ rust[fc84]::src::xmalloc::xzalloc)",
    "span": "src/xmalloc.rs:948:1: 951:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:948:1: 951:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xzalloc(mut s: size_t) -> *mut libc::c_void {\n    return xcalloc(s, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:845 ~ rust[fc84]::src::xmalloc::irealloc)",
    "span": "src/xmalloc.rs:50:1: 60:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:50:1: 60:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:856 ~ rust[fc84]::src::xmalloc::xreallocarray)",
    "span": "src/xmalloc.rs:170:1: 180:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:170:1: 180:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn xreallocarray(\n    mut p: *mut libc::c_void,\n    mut n: size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = reallocarray(p, n, s);\n    if r.is_null() && (p.is_null() || n != 0 && s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:975 ~ rust[fc84]::src::xmalloc::xnmalloc)",
        "span": "src/xmalloc.rs:192:5: 192:56 (#0)",
        "source": "return xreallocarray(0 as *mut libc::c_void, n, s);"
      },
      {
        "caller": "DefId(0:978 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
        "span": "src/xmalloc.rs:236:5: 236:32 (#0)",
        "source": "p = xreallocarray(p, n, s);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:858 ~ rust[fc84]::src::xmalloc::xnmalloc)",
    "span": "src/xmalloc.rs:191:1: 193:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:191:1: 193:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xnmalloc(mut n: size_t, mut s: size_t) -> *mut libc::c_void {\n    return xreallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [
      {
        "caller": "DefId(0:970 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:136:12: 138:6 (#0)",
        "source": "{\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:849 ~ rust[fc84]::src::xmalloc::imalloc)",
    "span": "src/xmalloc.rs:100:1: 112:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:100:1: 112:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:969 ~ rust[fc84]::src::xmalloc::ximalloc)",
        "span": "src/xmalloc.rs:127:5: 127:59 (#0)",
        "source": "let allocated_memory = imalloc(s.try_into().unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:852 ~ rust[fc84]::src::xmalloc::ximalloc)",
    "span": "src/xmalloc.rs:126:1: 129:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:126:1: 129:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn ximalloc(mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(imalloc(s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:869 ~ rust[fc84]::src::xmalloc::ximemdup0)",
    "span": "src/xmalloc.rs:994:1: 999:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:994:1: 999:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn ximemdup0(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_char {\n    let mut result: *mut libc::c_char = ximalloc(s + 1 as libc::c_int as libc::c_long)\n        as *mut libc::c_char;\n    *result.offset(s as isize) = 0 as libc::c_int as libc::c_char;\n    return memcpy(result as *mut libc::c_void, p, s as libc::c_ulong)\n        as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:166 ~ rust[fc84]::src::ialloc::icalloc)",
    "span": "src/ialloc.rs:55:1: 71:2 (#0)",
    "pieces": [
      "src/ialloc.rs:55:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:2:1: 2:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:618 ~ rust[fc84]::src::propername_lite::proper_name_lite)",
    "span": "src/propername_lite.rs:8:1: 24:2 (#0)",
    "pieces": [
      "src/propername_lite.rs:8:1: 24:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn proper_name_lite(\n    mut name_ascii: *const libc::c_char,\n    mut name_utf8: *const libc::c_char,\n) -> *const libc::c_char {\n    let mut translation: *const libc::c_char = gettext(name_ascii);\n    return if translation != name_ascii {\n        translation\n    } else if c_strcasecmp(\n        locale_charset(),\n        b\"UTF-8\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        name_utf8\n    } else {\n        name_ascii\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/propername_lite.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:561 ~ rust[fc84]::src::localcharset::locale_charset)",
    "span": "src/localcharset.rs:393:1: 402:2 (#0)",
    "pieces": [
      "src/localcharset.rs:393:1: 402:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn locale_charset() -> *const libc::c_char {\n    let mut codeset: *const libc::c_char = 0 as *const libc::c_char;\n    codeset = nl_langinfo(CODESET as libc::c_int);\n    if codeset.is_null() {\n        codeset = b\"\\0\" as *const u8 as *const libc::c_char;\n    }\n    if *codeset.offset(0 as libc::c_int as isize) as libc::c_int == '\\0' as i32 {\n        codeset = b\"ASCII\\0\" as *const u8 as *const libc::c_char;\n    }\n    return codeset;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/localcharset.rs:7:1: 7:39 (#0)",
        "source": "pub const CODESET: C2RustUnnamed = 14;"
      }
    ],
    "imports": [
      {
        "span": "src/localcharset.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/localcharset.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:687 ~ rust[fc84]::src::quotearg::set_quoting_style)",
    "span": "src/quotearg.rs:210:1: 222:2 (#0)",
    "pieces": [
      "src/quotearg.rs:210:1: 222:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn set_quoting_style(\n    mut o: *mut quoting_options,\n    mut s: quoting_style,\n) {\n    (*if !o.is_null() { o } else { &mut default_quoting_options }).style = s;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:17 ~ rust[fc84]::src::c_ctype::c_islower)",
    "span": "src/c_ctype.rs:88:1: 93:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:88:1: 93:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_islower(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:846 ~ rust[fc84]::src::xmalloc::icalloc)",
    "span": "src/xmalloc.rs:62:1: 76:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:62:1: 76:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "unsafe extern \"C\" fn icalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    if (18446744073709551615 as libc::c_ulong) < n as libc::c_ulong {\n        if s != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        n = 0 as libc::c_int as idx_t;\n    }\n    if (18446744073709551615 as libc::c_ulong) < s as libc::c_ulong {\n        if n != 0 as libc::c_int as libc::c_long {\n            return _gl_alloc_nomem();\n        }\n        s = 0 as libc::c_int as idx_t;\n    }\n    return calloc(n as libc::c_ulong, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:866 ~ rust[fc84]::src::xmalloc::xicalloc)",
    "span": "src/xmalloc.rs:973:1: 977:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:973:1: 977:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xicalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return check_nonnull(icalloc(n, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:864 ~ rust[fc84]::src::xmalloc::xizalloc)",
    "span": "src/xmalloc.rs:954:1: 962:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:954:1: 962:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xizalloc(mut s: idx_t) -> *mut libc::c_void {\n    return xicalloc(s, 1 as libc::c_int as idx_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:690 ~ rust[fc84]::src::quotearg::set_custom_quoting)",
    "span": "src/quotearg.rs:268:1: 287:2 (#0)",
    "pieces": [
      "src/quotearg.rs:268:1: 287:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn set_custom_quoting(\n    mut o: *mut quoting_options,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n) {\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    (*o).style = custom_quoting_style;\n    if left_quote.is_null() || right_quote.is_null() {\n        abort();\n    }\n    (*o).left_quote = left_quote;\n    (*o).right_quote = right_quote;\n}",
    "calls": [
      {
        "caller": "DefId(0:806 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
        "span": "src/quotearg.rs:1564:5: 1564:81 (#0)",
        "source": "set_custom_quoting(&mut o as *mut quoting_options, left_quote, right_quote);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:81:1: 81:52 (#0)",
        "source": "pub const custom_quoting_style: quoting_style = 10;"
      },
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:723 ~ rust[fc84]::src::quotearg::quotearg_n_custom_mem)",
    "span": "src/quotearg.rs:1556:1: 1566:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1556:1: 1566:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom_mem(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let mut o: quoting_options = default_quoting_options;\n    set_custom_quoting(&mut o, left_quote, right_quote);\n    return quotearg_n_options(n, arg, argsize, &mut o);\n}",
    "calls": [
      {
        "caller": "DefId(0:808 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
        "span": "src/quotearg.rs:1600:9: 1606:11 (#0)",
        "source": "result_ptr = quotearg_n_custom_mem(\n            0,\n            left_quote_c.as_ptr(),\n            right_quote_c.as_ptr(),\n            arg_c.as_ptr(),\n            argsize,\n        );"
      },
      {
        "caller": "DefId(0:805 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
        "span": "src/quotearg.rs:1547:5: 1553:7 (#0)",
        "source": "return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:722 ~ rust[fc84]::src::quotearg::quotearg_n_custom)",
    "span": "src/quotearg.rs:1541:1: 1554:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1541:1: 1554:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_n_custom(\n    mut n: libc::c_int,\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        n,\n        left_quote,\n        right_quote,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:807 ~ rust[fc84]::src::quotearg::quotearg_custom)",
        "span": "src/quotearg.rs:1579:9: 1579:110 (#0)",
        "source": "quoted_arg_ptr = quotearg_n_custom(0, left_quote_c.as_ptr(), right_quote_c.as_ptr(), arg_c.as_ptr());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:609 ~ rust[fc84]::src::progname::set_program_name)",
    "span": "src/progname.rs:62:1: 89:2 (#0)",
    "pieces": [
      "src/progname.rs:62:1: 89:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 38,
    "source": "pub unsafe extern \"C\" fn set_program_name(mut argv0: *const libc::c_char) {\n    let mut slash: *const libc::c_char = 0 as *const libc::c_char;\n    let mut base: *const libc::c_char = 0 as *const libc::c_char;\n    if argv0.is_null() {\n        fputs(\n            b\"A NULL argv[0] was passed through an exec system call.\\n\\0\" as *const u8\n                as *const libc::c_char,\n            stderr,\n        );\n        abort();\n    }\n    slash = strrchr(argv0, '/' as i32);\n    base = if !slash.is_null() {\n        slash.offset(1 as libc::c_int as isize)\n    } else {\n        argv0\n    };\n    if base.offset_from(argv0) as libc::c_long >= 7 as libc::c_int as libc::c_long\n        && strncmp(\n            base.offset(-(7 as libc::c_int as isize)),\n            b\"/.libs/\\0\" as *const u8 as *const libc::c_char,\n            7 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n    {\n        argv0 = base;\n        if strncmp(\n            base,\n            b\"lt-\\0\" as *const u8 as *const libc::c_char,\n            3 as libc::c_int as libc::c_ulong,\n        ) == 0 as libc::c_int\n        {\n            argv0 = base.offset(3 as libc::c_int as isize);\n            program_invocation_short_name = argv0 as *mut libc::c_char;\n        }\n    }\n    program_name = argv0;\n    program_invocation_name = argv0 as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/progname.rs:60:1: 60:77 (#0)",
        "source": "pub static mut program_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/progname.rs:2:1: 2:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/progname.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/progname.rs:1:1: 1:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:165 ~ rust[fc84]::src::ialloc::ireallocarray)",
    "span": "src/ialloc.rs:30:1: 50:2 (#0)",
    "pieces": [
      "src/ialloc.rs:30:1: 50:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn ireallocarray(\n    mut p: *mut libc::c_void,\n    mut n: idx_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if n as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n        && s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong\n    {\n        let mut nx: size_t = n as size_t;\n        let mut sx: size_t = s as size_t;\n        if n == 0 as libc::c_int as libc::c_long || s == 0 as libc::c_int as libc::c_long\n        {\n            sx = 1 as libc::c_int as size_t;\n            nx = sx;\n        }\n        p = reallocarray(p, nx, sx);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:2:1: 2:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:854 ~ rust[fc84]::src::xmalloc::xrealloc)",
    "span": "src/xmalloc.rs:141:1: 158:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:141:1: 158:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xrealloc(\n    mut p: *mut libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut r: *mut libc::c_void = realloc(p, s);\n    if r.is_null() && (p.is_null() || s != 0) {\n        xalloc_die();\n    }\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:979 ~ rust[fc84]::src::xmalloc::xpalloc)",
        "span": "src/xmalloc.rs:943:5: 943:61 (#0)",
        "source": "pa = xrealloc(pa as *mut libc::c_void, nbytes as usize);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:862 ~ rust[fc84]::src::xmalloc::xpalloc)",
    "span": "src/xmalloc.rs:241:1: 946:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:241:1: 248:4 (#0)",
      "src/xmalloc.rs:946:1: 946:2 (#0)"
    ],
    "sub_chunks": [
      7
    ],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xpalloc(\n    mut pa: *mut libc::c_void,\n    mut pn: *mut idx_t,\n    mut n_incr_min: idx_t,\n    mut n_max: ptrdiff_t,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n   <<chunk 7>>}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:47:1: 47:51 (#0)",
        "source": "pub const DEFAULT_MXFAST_0: C2RustUnnamed_0 = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xmalloc.rs:267:17: 346:18 (#0)",
        "pieces": [
          "src/xmalloc.rs:267:17: 346:18 (#0)"
        ],
        "num_lines": 80,
        "source": "if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as idx_t\n                    }) + s\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (s\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + -(1 as libc::c_int) as idx_t\n                            >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as idx_t / -s\n                    }) <= -(1 as libc::c_int) as libc::c_long - n) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xmalloc.rs:348:17: 453:18 (#0)",
        "pieces": [
          "src/xmalloc.rs:348:17: 453:18 (#0)"
        ],
        "num_lines": 106,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) + 0 as libc::c_int as idx_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                s\n                            }) + 0 as libc::c_int as idx_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < n + 0 as libc::c_int as idx_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < n\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/xmalloc.rs:456:13: 569:14 (#0)",
        "pieces": [
          "src/xmalloc.rs:456:13: 569:14 (#0)"
        ],
        "num_lines": 114,
        "source": "if s == 0 as libc::c_int as libc::c_long {\n                0 as libc::c_int\n            } else {\n                if n < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            n\n                        }) + 0 as libc::c_int as idx_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                n\n                            }) + 0 as libc::c_int as idx_t) as libc::c_int\n                    }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            s\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < s + 0 as libc::c_int as idx_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as idx_t)\n                                < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                    }\n                } else {\n                    (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/xmalloc.rs:623:29: 704:30 (#0)",
        "pieces": [
          "src/xmalloc.rs:623:29: 704:30 (#0)"
        ],
        "num_lines": 82,
        "source": "if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    -(1 as libc::c_int) as idx_t\n                                }) + s\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                (n < -(1 as libc::c_int) as idx_t / s) as libc::c_int\n                            } else {\n                                ((if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (s\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < s) as libc::c_int\n                                }) != 0\n                                {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + -(1 as libc::c_int) as idx_t\n                                        >> (::core::mem::size_of::<idx_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                                } else {\n                                    -(1 as libc::c_int) as idx_t / -s\n                                }) <= -(1 as libc::c_int) as libc::c_long - n)\n                                    as libc::c_int\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/xmalloc.rs:706:29: 812:30 (#0)",
        "pieces": [
          "src/xmalloc.rs:706:29: 812:30 (#0)"
        ],
        "num_lines": 107,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                !(((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long)\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t\n                                }) + 0 as libc::c_int as libc::c_long\n                            }) < 0 as libc::c_int as libc::c_long\n                            {\n                                (((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    s\n                                }) + 0 as libc::c_int as idx_t)\n                                    < -(if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            s\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) + 1 as libc::c_int as libc::c_long)\n                                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                            - 1 as libc::c_int as libc::c_long)\n                                            * 2 as libc::c_int as libc::c_long\n                                            + 1 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                s\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long\n                                    })) as libc::c_int\n                            } else {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) + 0 as libc::c_int as idx_t) as libc::c_int\n                            }) != 0 && s == -(1 as libc::c_int) as libc::c_long\n                            {\n                                if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    n\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < n + 0 as libc::c_int as idx_t) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long) < n\n                                        && (-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < n - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                }\n                            } else {\n                                (0 as libc::c_int as idx_t / s < n) as libc::c_int\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/xmalloc.rs:815:25: 928:26 (#0)",
        "pieces": [
          "src/xmalloc.rs:815:25: 928:26 (#0)"
        ],
        "num_lines": 114,
        "source": "if s == 0 as libc::c_int as libc::c_long {\n                            0 as libc::c_int\n                        } else {\n                            if n < 0 as libc::c_int as libc::c_long {\n                                if (if (if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    !(((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long)\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t\n                                    }) + 0 as libc::c_int as libc::c_long\n                                }) < 0 as libc::c_int as libc::c_long\n                                {\n                                    (((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        n\n                                    }) + 0 as libc::c_int as idx_t)\n                                        < -(if ((if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                n\n                                            }) + 0 as libc::c_int as idx_t\n                                        }) - 1 as libc::c_int as libc::c_long)\n                                            < 0 as libc::c_int as libc::c_long\n                                        {\n                                            ((((if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) + 1 as libc::c_int as libc::c_long)\n                                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                                - 1 as libc::c_int as libc::c_long)\n                                                * 2 as libc::c_int as libc::c_long\n                                                + 1 as libc::c_int as libc::c_long\n                                        } else {\n                                            (if 1 as libc::c_int != 0 {\n                                                0 as libc::c_int as libc::c_long\n                                            } else {\n                                                (if 1 as libc::c_int != 0 {\n                                                    0 as libc::c_int as libc::c_long\n                                                } else {\n                                                    n\n                                                }) + 0 as libc::c_int as idx_t\n                                            }) - 1 as libc::c_int as libc::c_long\n                                        })) as libc::c_int\n                                } else {\n                                    ((0 as libc::c_int as libc::c_long)\n                                        < (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            n\n                                        }) + 0 as libc::c_int as idx_t) as libc::c_int\n                                }) != 0 && n == -(1 as libc::c_int) as libc::c_long\n                                {\n                                    if ((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        s\n                                    }) - 1 as libc::c_int as libc::c_long)\n                                        < 0 as libc::c_int as libc::c_long\n                                    {\n                                        ((0 as libc::c_int as libc::c_long)\n                                            < s + 0 as libc::c_int as idx_t) as libc::c_int\n                                    } else {\n                                        ((-(1 as libc::c_int) as libc::c_long\n                                            - 0 as libc::c_int as idx_t)\n                                            < s - 1 as libc::c_int as libc::c_long) as libc::c_int\n                                    }\n                                } else {\n                                    (0 as libc::c_int as idx_t / n < s) as libc::c_int\n                                }\n                            } else {\n                                (-(1 as libc::c_int) as idx_t / s < n) as libc::c_int\n                            }\n                        }",
        "sub_chunks": [],
        "live_in": [
          "mut s: i64",
          "mut n: i64"
        ],
        "live_out": [
          "mut s: i64",
          "mut n: i64"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/xmalloc.rs:604:13: 938:24 (#0)",
        "pieces": [
          "src/xmalloc.rs:604:13: 623:28 (#0)",
          "src/xmalloc.rs:705:1: 706:28 (#0)",
          "src/xmalloc.rs:813:1: 815:24 (#0)",
          "src/xmalloc.rs:929:1: 938:24 (#0)"
        ],
        "num_lines": 35,
        "source": "let (fresh12, fresh13) = n0.overflowing_add(n_incr_min);\n            *(&mut n as *mut idx_t) = fresh12;\n            fresh13 as libc::c_int != 0\n                || 0 as libc::c_int as libc::c_long <= n_max && n_max < n\n                || (if (0 as libc::c_int as idx_t) < -(1 as libc::c_int) as idx_t\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        n\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        s\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    && (if s < 0 as libc::c_int as libc::c_long {\n                        if n < 0 as libc::c_int as libc::c_long {\n                           <<chunk 3>>                        } else {\n                           <<chunk 4>>                        }\n                    } else {\n                       <<chunk 5>>                    }) != 0\n                {\n                    let (fresh18, _fresh19) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh18;\n                    1 as libc::c_int\n                } else {\n                    let (fresh20, fresh21) = n.overflowing_mul(s);\n                    *(&mut nbytes as *mut idx_t) = fresh20;\n                    fresh21 as libc::c_int\n                }) != 0",
        "sub_chunks": [
          3,
          4,
          5
        ],
        "live_in": [
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64",
          "mut n0: i64",
          "mut n: i64",
          "mut nbytes: i64"
        ],
        "live_out": [
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64",
          "mut n0: i64",
          "mut n: i64",
          "mut nbytes: i64",
          "fresh12: i64",
          "fresh13: bool"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/xmalloc.rs:248:5: 945:15 (#0)",
        "pieces": [
          "src/xmalloc.rs:248:5: 267:16 (#0)",
          "src/xmalloc.rs:347:1: 348:16 (#0)",
          "src/xmalloc.rs:454:1: 456:12 (#0)",
          "src/xmalloc.rs:570:1: 604:12 (#0)",
          "src/xmalloc.rs:939:1: 945:15 (#0)"
        ],
        "num_lines": 67,
        "source": "let mut n0: idx_t = *pn;\n    let mut n: idx_t = 0;\n    let (fresh2, fresh3) = n0.overflowing_add(n0 >> 1 as libc::c_int);\n    *(&mut n as *mut idx_t) = fresh2;\n    if fresh3 {\n        n = 9223372036854775807 as libc::c_long;\n    }\n    if 0 as libc::c_int as libc::c_long <= n_max && n_max < n {\n        n = n_max;\n    }\n    let mut nbytes: idx_t = 0;\n    let mut adjusted_nbytes: idx_t = (if if (0 as libc::c_int as idx_t)\n        < -(1 as libc::c_int) as idx_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { n })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { s })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && (if s < 0 as libc::c_int as libc::c_long {\n            if n < 0 as libc::c_int as libc::c_long {\n               <<chunk 0>>            } else {\n               <<chunk 1>>            }\n        } else {\n           <<chunk 2>>        }) != 0\n    {\n        let (fresh8, _fresh9) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh8;\n        1 as libc::c_int\n    } else {\n        let (fresh10, fresh11) = n.overflowing_mul(s);\n        *(&mut nbytes as *mut idx_t) = fresh10;\n        fresh11 as libc::c_int\n    } != 0\n    {\n        if (9223372036854775807 as libc::c_long as libc::c_ulong)\n            < 18446744073709551615 as libc::c_ulong\n        {\n            9223372036854775807 as libc::c_long as libc::c_ulong\n        } else {\n            18446744073709551615 as libc::c_ulong\n        }\n    } else {\n        (if nbytes < DEFAULT_MXFAST_0 as libc::c_int as libc::c_long {\n            DEFAULT_MXFAST_0 as libc::c_int\n        } else {\n            0 as libc::c_int\n        }) as libc::c_ulong\n    }) as idx_t;\n    if adjusted_nbytes != 0 {\n        n = adjusted_nbytes / s;\n        nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n    if pa.is_null() {\n        *pn = 0 as libc::c_int as idx_t;\n    }\n    if n - n0 < n_incr_min\n        && {\n           <<chunk 6>>        }\n    {\n        xalloc_die();\n    }\n    pa = xrealloc(pa, nbytes as size_t);\n    *pn = n;\n    return pa;",
        "sub_chunks": [
          0,
          1,
          2,
          6
        ],
        "live_in": [
          "mut pa: *mut libc::c_void",
          "mut pn: *mut i64",
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64"
        ],
        "live_out": [
          "mut pa: *mut libc::c_void",
          "mut pn: *mut i64",
          "mut n_incr_min: i64",
          "mut n_max: i64",
          "mut s: i64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:14 ~ rust[fc84]::src::c_ctype::c_iscntrl)",
    "span": "src/c_ctype.rs:60:1: 66:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:60:1: 66:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_iscntrl(mut c: libc::c_int) -> bool {\n    match c {\n        7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16 | 17\n        | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127 => {\n            return 1 as libc::c_int != 0;\n        }\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:19 ~ rust[fc84]::src::c_ctype::c_ispunct)",
    "span": "src/c_ctype.rs:114:1: 121:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:114:1: 121:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn c_ispunct(mut c: libc::c_int) -> bool {\n    match c {\n        33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58\n        | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125\n        | 126 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:677 ~ rust[fc84]::src::quotearg::c32isprint)",
    "span": "src/quotearg.rs:141:1: 147:2 (#0)",
    "pieces": [
      "src/quotearg.rs:141:1: 147:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn c32isprint(mut wc: wint_t) -> libc::c_int {\n    return iswprint(wc);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:688 ~ rust[fc84]::src::quotearg::set_char_quoting)",
    "span": "src/quotearg.rs:225:1: 254:2 (#0)",
    "pieces": [
      "src/quotearg.rs:225:1: 254:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 30,
    "source": "pub unsafe extern \"C\" fn set_char_quoting(\n    mut o: *mut quoting_options,\n    mut c: libc::c_char,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut uc: libc::c_uchar = c as libc::c_uchar;\n    let mut p: *mut libc::c_uint = ((*(if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options\n    }))\n        .quote_these_too)\n        .as_mut_ptr()\n        .offset(\n            (uc as libc::c_ulong)\n                .wrapping_div(\n                    (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n                ) as isize,\n        );\n    let mut shift: libc::c_int = (uc as libc::c_ulong)\n        .wrapping_rem(\n            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                .wrapping_mul(8 as libc::c_int as libc::c_ulong),\n        ) as libc::c_int;\n    let mut r: libc::c_int = (*p >> shift & 1 as libc::c_int as libc::c_uint)\n        as libc::c_int;\n    *p ^= ((i & 1 as libc::c_int ^ r) << shift) as libc::c_uint;\n    return r;\n}",
    "calls": [
      {
        "caller": "DefId(0:798 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
        "span": "src/quotearg.rs:1487:5: 1487:58 (#0)",
        "source": "set_char_quoting(&mut options, ch, 1 as libc::c_int);"
      },
      {
        "caller": "DefId(0:803 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1529:9: 1529:61 (#0)",
        "source": "set_char_quoting(&mut options, ':' as i32 as i8, 1);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:715 ~ rust[fc84]::src::quotearg::quotearg_char_mem)",
    "span": "src/quotearg.rs:1474:1: 1489:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1474:1: 1489:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn quotearg_char_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = default_quoting_options;\n    set_char_quoting(&mut options, ch, 1 as libc::c_int);\n    return quotearg_n_options(0 as libc::c_int, arg, argsize, &mut options);\n}",
    "calls": [
      {
        "caller": "DefId(0:802 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
        "span": "src/quotearg.rs:1507:22: 1509:6 (#0)",
        "source": "unsafe {\n        quotearg_char_mem(arg.as_ptr() as *const libc::c_char, argsize, ':' as i32 as libc::c_char)\n    }"
      },
      {
        "caller": "DefId(0:800 ~ rust[fc84]::src::quotearg::quotearg_char)",
        "span": "src/quotearg.rs:1493:22: 1495:6 (#0)",
        "source": "unsafe {\n        quotearg_char_mem(arg.as_ptr(), 18446744073709551615 as libc::c_ulong, ch_as_c_char)\n    }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:91:1: 91:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      },
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:717 ~ rust[fc84]::src::quotearg::quotearg_char)",
    "span": "src/quotearg.rs:1491:1: 1497:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1491:1: 1497:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_char(\n    mut arg: *const libc::c_char,\n    mut ch: libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, 18446744073709551615 as libc::c_ulong, ch);\n}",
    "calls": [
      {
        "caller": "DefId(0:801 ~ rust[fc84]::src::quotearg::quotearg_colon)",
        "span": "src/quotearg.rs:1500:46: 1502:2 (#0)",
        "source": "{\n    quotearg_char(arg, ':' as char)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:718 ~ rust[fc84]::src::quotearg::quotearg_colon)",
    "span": "src/quotearg.rs:1500:1: 1502:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1500:1: 1502:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn quotearg_colon(\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_char(arg, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:24 ~ rust[fc84]::src::c_ctype::c_toupper)",
    "span": "src/c_ctype.rs:160:1: 165:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:160:1: 165:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_toupper(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 => {\n            return c - 'a' as i32 + 'A' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:729 ~ rust[fc84]::src::quotearg::quote_n)",
    "span": "src/quotearg.rs:1639:1: 1642:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1639:1: 1642:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *const libc::c_char {\n    return quote_n_mem(n, arg, 18446744073709551615 as libc::c_ulong);\n}",
    "calls": [
      {
        "caller": "DefId(0:813 ~ rust[fc84]::src::quotearg::quote)",
        "span": "src/quotearg.rs:1647:1: 1647:29 (#0)",
        "source": "return quote_n(0, &arg_str);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:730 ~ rust[fc84]::src::quotearg::quote)",
    "span": "src/quotearg.rs:1645:1: 1648:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1645:1: 1648:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quote(mut arg: *const libc::c_char) -> *const libc::c_char {\n    return quote_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:74 ~ rust[fc84]::src::closeout::close_stdout_set_file_name)",
    "span": "src/closeout.rs:66:1: 71:2 (#0)",
    "pieces": [
      "src/closeout.rs:66:1: 71:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_file_name(mut file: *const libc::c_char) {\n    file_name = file;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:64:1: 64:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:781 ~ rust[fc84]::src::version_etc::version_etc_arn)",
    "span": "src/version_etc.rs:68:1: 246:2 (#0)",
    "pieces": [
      "src/version_etc.rs:68:1: 76:4 (#0)",
      "src/version_etc.rs:108:1: 108:4 (#0)",
      "src/version_etc.rs:246:1: 246:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc_arn(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n    mut n_authors: size_t,\n) {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [
      {
        "caller": "DefId(0:875 ~ rust[fc84]::src::version_etc::version_etc_va)",
        "span": "src/version_etc.rs:283:5: 290:7 (#0)",
        "source": "version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );"
      },
      {
        "caller": "DefId(0:874 ~ rust[fc84]::src::version_etc::version_etc_ar)",
        "span": "src/version_etc.rs:261:5: 261:81 (#0)",
        "source": "version_etc_arn(stream, command_name, package, version, authors, n_authors);"
      }
    ],
    "globals": [
      {
        "span": "src/version_etc.rs:65:1: 65:48 (#0)",
        "source": "pub const COPYRIGHT_YEAR: C2RustUnnamed = 2024;"
      }
    ],
    "imports": [
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:14 (#0)",
        "source": "use std::ffi;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/version_etc.rs:76:5: 107:73 (#0)",
        "pieces": [
          "src/version_etc.rs:76:5: 107:73 (#0)"
        ],
        "num_lines": 32,
        "source": "if !command_name.is_null() {\n        fprintf(\n            stream,\n            b\"%s (%s) %s\\n\\0\" as *const u8 as *const libc::c_char,\n            command_name,\n            package,\n            version,\n        );\n    } else {\n        fprintf(\n            stream,\n            b\"%s %s\\n\\0\" as *const u8 as *const libc::c_char,\n            package,\n            version,\n        );\n    }\n    fprintf(\n        stream,\n        version_etc_copyright.as_ptr(),\n        gettext(b\"(C)\\0\" as *const u8 as *const libc::c_char),\n        COPYRIGHT_YEAR as libc::c_int,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);\n    fprintf(\n        stream,\n        gettext(\n            b\"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        b\"https://gnu.org/licenses/gpl.html\\0\" as *const u8 as *const libc::c_char,\n    );\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stream);",
        "sub_chunks": [],
        "live_in": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut command_name: *const i8",
          "mut package: *const i8",
          "mut version: *const i8"
        ],
        "live_out": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut command_name: *const i8",
          "mut package: *const i8",
          "mut version: *const i8"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/version_etc.rs:108:5: 244:3 (#0)",
        "pieces": [
          "src/version_etc.rs:108:5: 244:3 (#0)"
        ],
        "num_lines": 142,
        "source": "match n_authors {\n        0 => {}\n        1 => {\n            fprintf(\n                stream,\n                gettext(b\"Written by %s.\\n\\0\" as *const u8 as *const libc::c_char),\n                *authors.offset(0 as libc::c_int as isize),\n            );\n        }\n        2 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n            );\n        }\n        3 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, and %s.\\n\\0\" as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n            );\n        }\n        4 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n            );\n        }\n        5 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n            );\n        }\n        6 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n            );\n        }\n        7 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n            );\n        }\n        8 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n            );\n        }\n        9 => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n        _ => {\n            fprintf(\n                stream,\n                gettext(\n                    b\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\\0\"\n                        as *const u8 as *const libc::c_char,\n                ),\n                *authors.offset(0 as libc::c_int as isize),\n                *authors.offset(1 as libc::c_int as isize),\n                *authors.offset(2 as libc::c_int as isize),\n                *authors.offset(3 as libc::c_int as isize),\n                *authors.offset(4 as libc::c_int as isize),\n                *authors.offset(5 as libc::c_int as isize),\n                *authors.offset(6 as libc::c_int as isize),\n                *authors.offset(7 as libc::c_int as isize),\n                *authors.offset(8 as libc::c_int as isize),\n            );\n        }\n    };",
        "sub_chunks": [],
        "live_in": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut authors: *const *const i8",
          "mut n_authors: u64"
        ],
        "live_out": [
          "mut stream: *mut src::version_etc::_IO_FILE",
          "mut authors: *const *const i8",
          "mut n_authors: u64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:783 ~ rust[fc84]::src::version_etc::version_etc_va)",
    "span": "src/version_etc.rs:264:1: 291:2 (#0)",
    "pieces": [
      "src/version_etc.rs:264:1: 291:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 28,
    "source": "pub unsafe extern \"C\" fn version_etc_va(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: ::core::ffi::VaList,\n) {\n    let mut n_authors: size_t = 0;\n    let mut authtab: [*const libc::c_char; 10] = [0 as *const libc::c_char; 10];\n    n_authors = 0 as libc::c_int as size_t;\n    while n_authors < 10 as libc::c_int as libc::c_ulong\n        && {\n            authtab[n_authors as usize] = authors.arg::<*const libc::c_char>();\n            !(authtab[n_authors as usize]).is_null()\n        }\n    {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(\n        stream,\n        command_name,\n        package,\n        version,\n        authtab.as_mut_ptr(),\n        n_authors,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:878 ~ rust[fc84]::src::version_etc::version_etc)",
        "span": "src/version_etc.rs:302:5: 302:82 (#0)",
        "source": "version_etc_va(stream, command_name, package, version, authors.as_va_list());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:2:1: 2:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:786 ~ rust[fc84]::src::version_etc::version_etc)",
    "span": "src/version_etc.rs:293:1: 303:2 (#0)",
    "pieces": [
      "src/version_etc.rs:293:1: 303:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn version_etc(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut args: ...\n) {\n    let mut authors: ::core::ffi::VaListImpl;\n    authors = args.clone();\n    version_etc_va(stream, command_name, package, version, authors.as_va_list());\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:14 (#0)",
        "source": "use std::ffi;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:724 ~ rust[fc84]::src::quotearg::quotearg_custom)",
    "span": "src/quotearg.rs:1568:1: 1585:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1568:1: 1585:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_custom(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_custom(0 as libc::c_int, left_quote, right_quote, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:13 ~ rust[fc84]::src::c_ctype::c_isblank)",
    "span": "src/c_ctype.rs:53:1: 55:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:53:1: 55:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn c_isblank(mut c: libc::c_int) -> bool {\n    return c == ' ' as i32 || c == '\\t' as i32;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:707 ~ rust[fc84]::src::quotearg::quotearg_n)",
    "span": "src/quotearg.rs:1394:1: 1404:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1394:1: 1404:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn quotearg_n(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut default_quoting_options,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:792 ~ rust[fc84]::src::quotearg::quotearg)",
        "span": "src/quotearg.rs:1416:9: 1416:98 (#0)",
        "source": "let quoted_arg = quotearg_n(0, CString::new(arg).expect(\"CString::new failed\").as_ptr());"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:689 ~ rust[fc84]::src::quotearg::set_quoting_flags)",
    "span": "src/quotearg.rs:256:1: 265:2 (#0)",
    "pieces": [
      "src/quotearg.rs:256:1: 265:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn set_quoting_flags(\n    mut o: *mut quoting_options,\n    mut i: libc::c_int,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    if o.is_null() {\n        o = &mut default_quoting_options;\n    }\n    r = (*o).flags;\n    (*o).flags = i;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:740 ~ rust[fc84]::src::setlocale_null::setlocale_null)",
    "span": "src/setlocale_null.rs:28:1: 35:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:28:1: 35:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn setlocale_null(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    return setlocale_null_unlocked(category);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:851 ~ rust[fc84]::src::xmalloc::xmalloc)",
    "span": "src/xmalloc.rs:122:1: 124:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:122:1: 124:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xmalloc(mut s: size_t) -> *mut libc::c_void {\n    return check_nonnull(malloc(s));\n}",
    "calls": [
      {
        "caller": "DefId(0:970 ~ rust[fc84]::src::xmalloc::xcharalloc)",
        "span": "src/xmalloc.rs:134:5: 136:6 (#0)",
        "source": "{\n        xmalloc(n)\n    }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:20 ~ rust[fc84]::src::c_ctype::c_isspace)",
    "span": "src/c_ctype.rs:126:1: 131:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:126:1: 131:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isspace(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 9 | 10 | 11 | 12 | 13 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:29 ~ rust[fc84]::src::c_strcasecmp::c_tolower)",
    "span": "src/c_strcasecmp.rs:4:1: 9:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:4:1: 9:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:33 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:25:9: 25:46 (#0)",
        "source": "let c2 = c_tolower(*p2 as i32) as u8;"
      },
      {
        "caller": "DefId(0:33 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
        "span": "src/c_strcasecmp.rs:24:9: 24:46 (#0)",
        "source": "let c1 = c_tolower(*p1 as i32) as u8;"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:120 ~ rust[fc84]::src::fflush::clear_ungetc_buffer_preserving_position)",
    "span": "src/fflush.rs:53:1: 59:2 (#0)",
    "pieces": [
      "src/fflush.rs:53:1: 59:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn clear_ungetc_buffer_preserving_position(mut fp: *mut FILE) {\n    if (*fp)._flags & 0x100 as libc::c_int != 0 {\n        rpl_fseeko(fp, 0 as libc::c_int as off_t, 1 as libc::c_int);\n    }\n}",
    "calls": [
      {
        "caller": "DefId(0:133 ~ rust[fc84]::src::fflush::rpl_fflush)",
        "span": "src/fflush.rs:65:13: 65:66 (#0)",
        "source": "unsafe { clear_ungetc_buffer_preserving_position(s) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/fflush.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fflush.rs:3:1: 3:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:18 ~ rust[fc84]::src::c_ctype::c_isprint)",
    "span": "src/c_ctype.rs:98:1: 109:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:98:1: 109:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isprint(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:577 ~ rust[fc84]::src::mbrtoc32::mbszero)",
    "span": "src/mbrtoc32.rs:41:1: 45:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:41:1: 45:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:628 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
        "span": "src/mbrtoc32.rs:81:9: 81:37 (#0)",
        "source": "unsafe { mbszero(local_ps) }"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:2:1: 2:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/mbrtoc32.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/mbrtoc32.rs:4:1: 4:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/mbrtoc32.rs:3:1: 3:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:823 ~ rust[fc84]::src::xdectoimax::xnumtoimax)",
    "span": "src/xdectoimax.rs:28:1: 128:2 (#0)",
    "pieces": [
      "src/xdectoimax.rs:28:1: 128:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 101,
    "source": "pub unsafe extern \"C\" fn xnumtoimax(\n    mut n_str: *const libc::c_char,\n    mut base: libc::c_int,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    let mut s_err: strtol_error = LONGINT_OK;\n    let mut tnum: intmax_t = 0;\n    s_err = xstrtoimax(n_str, 0 as *mut *mut libc::c_char, base, &mut tnum, suffixes);\n    if s_err as libc::c_uint == LONGINT_OK as libc::c_int as libc::c_uint {\n        if tnum < min || max < tnum {\n            s_err = LONGINT_OVERFLOW;\n            if tnum > (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_long {\n                *__errno_location() = 75 as libc::c_int;\n            } else if tnum\n                < ((-(2147483647 as libc::c_int) - 1 as libc::c_int) / 2 as libc::c_int)\n                    as libc::c_long\n            {\n                *__errno_location() = 75 as libc::c_int;\n            } else {\n                *__errno_location() = 34 as libc::c_int;\n            }\n        }\n    } else if s_err as libc::c_uint == LONGINT_OVERFLOW as libc::c_int as libc::c_uint {\n        *__errno_location() = 75 as libc::c_int;\n    } else if s_err as libc::c_uint\n        == LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW as libc::c_int as libc::c_uint\n    {\n        *__errno_location() = 0 as libc::c_int;\n    }\n    if s_err as libc::c_uint != LONGINT_OK as libc::c_int as libc::c_uint {\n        if 0 != 0 {\n            error(\n                if err_exit != 0 { err_exit } else { 1 as libc::c_int },\n                if *__errno_location() == 22 as libc::c_int {\n                    0 as libc::c_int\n                } else {\n                    *__errno_location()\n                },\n                b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                err,\n                quote(n_str),\n            );\n            if (if err_exit != 0 { err_exit } else { 1 as libc::c_int })\n                != 0 as libc::c_int\n            {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = if err_exit != 0 {\n                    err_exit\n                } else {\n                    1 as libc::c_int\n                };\n                error(\n                    __errstatus,\n                    if *__errno_location() == 22 as libc::c_int {\n                        0 as libc::c_int\n                    } else {\n                        *__errno_location()\n                    },\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    err,\n                    quote(n_str),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        unreachable!();\n    }\n    return tnum;\n}",
    "calls": [
      {
        "caller": "DefId(0:919 ~ rust[fc84]::src::xdectoimax::xdectoimax)",
        "span": "src/xdectoimax.rs:138:5: 138:84 (#0)",
        "source": "return xnumtoimax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);"
      }
    ],
    "globals": [
      {
        "span": "src/xdectoimax.rs:21:1: 21:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      },
      {
        "span": "src/xdectoimax.rs:26:1: 26:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/xdectoimax.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:824 ~ rust[fc84]::src::xdectoimax::xdectoimax)",
    "span": "src/xdectoimax.rs:130:1: 139:2 (#0)",
    "pieces": [
      "src/xdectoimax.rs:130:1: 139:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xdectoimax(\n    mut n_str: *const libc::c_char,\n    mut min: intmax_t,\n    mut max: intmax_t,\n    mut suffixes: *const libc::c_char,\n    mut err: *const libc::c_char,\n    mut err_exit: libc::c_int,\n) -> intmax_t {\n    return xnumtoimax(n_str, 10 as libc::c_int, min, max, suffixes, err, err_exit);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xdectoimax.rs:1:1: 1:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:867 ~ rust[fc84]::src::xmalloc::xmemdup)",
    "span": "src/xmalloc.rs:980:1: 984:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:980:1: 984:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xmemdup(\n    mut p: *const libc::c_void,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    return memcpy(xmalloc(s), p, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:870 ~ rust[fc84]::src::xmalloc::xstrdup)",
    "span": "src/xmalloc.rs:1002:1: 1008:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:1002:1: 1008:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xstrdup(mut string: *const libc::c_char) -> *mut libc::c_char {\n    return xmemdup(\n        string as *const libc::c_void,\n        (strlen(string)).wrapping_add(1 as libc::c_int as libc::c_ulong),\n    ) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:16 ~ rust[fc84]::src::c_ctype::c_isgraph)",
    "span": "src/c_ctype.rs:78:1: 83:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:78:1: 83:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn c_isgraph(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40\n        | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 91 | 92\n        | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69 | 70 | 71\n        | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n        | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:750 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:18:1: 23:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:18:1: 23:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn setlocale_null_unlocked(\n    mut category: libc::c_int,\n) -> *const libc::c_char {\n    let mut result: *const libc::c_char = setlocale(category, 0 as *const libc::c_char);\n    return result;\n}",
    "calls": [
      {
        "caller": "DefId(0:840 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
        "span": "src/setlocale_null_unlocked.rs:32:9: 32:52 (#0)",
        "source": "result = setlocale_null_unlocked(category);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:696 ~ rust[fc84]::src::quotearg::quotearg_alloc_mem)",
    "span": "src/quotearg.rs:1226:1: 1273:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1226:1: 1273:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 48,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut size: *mut size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut flags: libc::c_int = (*p).flags\n        | (if !size.is_null() {\n            0 as libc::c_int\n        } else {\n            QA_ELIDE_NULL_BYTES as libc::c_int\n        });\n    let mut bufsize: size_t = (quotearg_buffer_restyled(\n        0 as *mut libc::c_char,\n        0 as libc::c_int as size_t,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    ))\n        .wrapping_add(1 as libc::c_int as libc::c_ulong);\n    let mut buf: *mut libc::c_char = xcharalloc(bufsize);\n    quotearg_buffer_restyled(\n        buf,\n        bufsize,\n        arg,\n        argsize,\n        (*p).style,\n        flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    if !size.is_null() {\n        *size = bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n    }\n    return buf;\n}",
    "calls": [
      {
        "caller": "DefId(0:778 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
        "span": "src/quotearg.rs:1222:5: 1222:75 (#0)",
        "source": "unsafe { quotearg_alloc_mem(c_string.as_ptr(), argsize, size_ptr, o) }"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      },
      {
        "span": "src/quotearg.rs:95:1: 95:50 (#0)",
        "source": "pub const QA_ELIDE_NULL_BYTES: quoting_flags = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:76 ~ rust[fc84]::src::closeout::close_stdout_set_ignore_EPIPE)",
    "span": "src/closeout.rs:75:1: 79:2 (#0)",
    "pieces": [
      "src/closeout.rs:75:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn close_stdout_set_ignore_EPIPE(mut ignore: bool) {\n    ignore_EPIPE = ignore;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:73:1: 73:39 (#0)",
        "source": "static mut ignore_EPIPE: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:121 ~ rust[fc84]::src::fflush::rpl_fflush)",
    "span": "src/fflush.rs:62:1: 70:2 (#0)",
    "pieces": [
      "src/fflush.rs:62:1: 70:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn rpl_fflush(mut stream: *mut FILE) -> libc::c_int {\n    if stream.is_null() || !(__freading(stream) != 0 as libc::c_int) {\n        return fflush(stream);\n    }\n    clear_ungetc_buffer_preserving_position(stream);\n    return fflush(stream);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fflush.rs:5:1: 5:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/fflush.rs:2:1: 2:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/fflush.rs:3:1: 3:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:694 ~ rust[fc84]::src::quotearg::quotearg_buffer)",
    "span": "src/quotearg.rs:1187:1: 1212:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1187:1: 1212:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn quotearg_buffer(\n    mut buffer: *mut libc::c_char,\n    mut buffersize: size_t,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> size_t {\n    let mut p: *const quoting_options = if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    };\n    let mut e: libc::c_int = *__errno_location();\n    let mut r: size_t = quotearg_buffer_restyled(\n        buffer,\n        buffersize,\n        arg,\n        argsize,\n        (*p).style,\n        (*p).flags,\n        ((*p).quote_these_too).as_ptr(),\n        (*p).left_quote,\n        (*p).right_quote,\n    );\n    *__errno_location() = e;\n    return r;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:22 ~ rust[fc84]::src::c_ctype::c_isxdigit)",
    "span": "src/c_ctype.rs:143:1: 145:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:143:1: 145:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isxdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 65 | 66 | 67 | 68 | 69 | 70 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:48 ~ rust[fc84]::src::close_stream::close_stream)",
    "span": "src/close_stream.rs:51:1: 65:2 (#0)",
    "pieces": [
      "src/close_stream.rs:51:1: 65:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 16,
    "source": "pub unsafe extern \"C\" fn close_stream(mut stream: *mut FILE) -> libc::c_int {\n    let some_pending: bool = __fpending(stream) != 0 as libc::c_int as libc::c_ulong;\n    let prev_fail: bool = ferror_unlocked(stream) != 0 as libc::c_int;\n    let fclose_fail: bool = rpl_fclose(stream) != 0 as libc::c_int;\n    if prev_fail as libc::c_int != 0\n        || fclose_fail as libc::c_int != 0\n            && (some_pending as libc::c_int != 0\n                || *__errno_location() != 9 as libc::c_int)\n    {\n        if !fclose_fail {\n            *__errno_location() = 0 as libc::c_int;\n        }\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/close_stream.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:678 ~ rust[fc84]::src::quotearg::mbszero)",
    "span": "src/quotearg.rs:150:1: 156:2 (#0)",
    "pieces": [
      "src/quotearg.rs:150:1: 156:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:77 ~ rust[fc84]::src::closeout::close_stdout)",
    "span": "src/closeout.rs:82:1: 177:2 (#0)",
    "pieces": [
      "src/closeout.rs:82:1: 177:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 96,
    "source": "pub unsafe extern \"C\" fn close_stdout() {\n    if close_stream(stdout) != 0 as libc::c_int\n        && !(ignore_EPIPE as libc::c_int != 0\n            && *__errno_location() == 32 as libc::c_int)\n    {\n        let mut write_error: *const libc::c_char = gettext(\n            b\"write error\\0\" as *const u8 as *const libc::c_char,\n        );\n        if !file_name.is_null() {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                    quotearg_colon(file_name),\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s: %s\\0\" as *const u8 as *const libc::c_char,\n                        quotearg_colon(file_name),\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        } else {\n            if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    *__errno_location(),\n                    b\"%s\\0\" as *const u8 as *const libc::c_char,\n                    write_error,\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        b\"%s\\0\" as *const u8 as *const libc::c_char,\n                        write_error,\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        _exit(exit_failure);\n    }\n    if SANITIZE_ADDRESS as libc::c_int == 0 && close_stream(stderr) != 0 as libc::c_int {\n        _exit(exit_failure);\n    }\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/closeout.rs:64:1: 64:70 (#0)",
        "source": "static mut file_name: *const libc::c_char = 0 as *const libc::c_char;"
      }
    ],
    "imports": [
      {
        "span": "src/closeout.rs:2:1: 2:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/closeout.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:861 ~ rust[fc84]::src::xmalloc::x2nrealloc)",
    "span": "src/xmalloc.rs:213:1: 239:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:213:1: 239:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 27,
    "source": "pub unsafe extern \"C\" fn x2nrealloc(\n    mut p: *mut libc::c_void,\n    mut pn: *mut size_t,\n    mut s: size_t,\n) -> *mut libc::c_void {\n    let mut n: size_t = *pn;\n    if p.is_null() {\n        if n == 0 {\n            n = (DEFAULT_MXFAST as libc::c_int as libc::c_ulong).wrapping_div(s);\n            n = (n as libc::c_ulong)\n                .wrapping_add((n == 0) as libc::c_int as libc::c_ulong) as size_t\n                as size_t;\n        }\n    } else {\n        let (fresh0, fresh1) = n\n            .overflowing_add(\n                (n >> 1 as libc::c_int).wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n        *(&mut n as *mut size_t) = fresh0;\n        if fresh1 {\n            xalloc_die();\n        }\n    }\n    p = xreallocarray(p, n, s);\n    *pn = n;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/xmalloc.rs:45:1: 45:47 (#0)",
        "source": "pub const DEFAULT_MXFAST: C2RustUnnamed = 128;"
      }
    ],
    "imports": [
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:860 ~ rust[fc84]::src::xmalloc::x2realloc)",
    "span": "src/xmalloc.rs:201:1: 210:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:201:1: 210:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn x2realloc(\n    mut p: *mut libc::c_void,\n    mut ps: *mut size_t,\n) -> *mut libc::c_void {\n    return x2nrealloc(p, ps, 1 as libc::c_int as size_t);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:855 ~ rust[fc84]::src::xmalloc::xirealloc)",
    "span": "src/xmalloc.rs:161:1: 167:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:161:1: 167:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn xirealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return check_nonnull(irealloc(p, s));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:167 ~ rust[fc84]::src::ialloc::irealloc)",
    "span": "src/ialloc.rs:76:1: 87:2 (#0)",
    "pieces": [
      "src/ialloc.rs:76:1: 87:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn irealloc(\n    mut p: *mut libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        p = realloc(p, (s | (s == 0) as libc::c_int as libc::c_long) as libc::c_ulong);\n        return p;\n    } else {\n        return _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:8:1: 8:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:2:1: 2:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:725 ~ rust[fc84]::src::quotearg::quotearg_custom_mem)",
    "span": "src/quotearg.rs:1588:1: 1610:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1588:1: 1610:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn quotearg_custom_mem(\n    mut left_quote: *const libc::c_char,\n    mut right_quote: *const libc::c_char,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_custom_mem(\n        0 as libc::c_int,\n        left_quote,\n        right_quote,\n        arg,\n        argsize,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:719 ~ rust[fc84]::src::quotearg::quotearg_colon_mem)",
    "span": "src/quotearg.rs:1505:1: 1511:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1505:1: 1511:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_colon_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_char_mem(arg, argsize, ':' as i32 as libc::c_char);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:23 ~ rust[fc84]::src::c_ctype::c_tolower)",
    "span": "src/c_ctype.rs:150:1: 155:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:150:1: 155:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_tolower(mut c: libc::c_int) -> libc::c_int {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => {\n            return c - 'A' as i32 + 'a' as i32;\n        }\n        _ => return c,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:30 ~ rust[fc84]::src::c_strcasecmp::c_strcasecmp)",
    "span": "src/c_strcasecmp.rs:12:1: 45:2 (#0)",
    "pieces": [
      "src/c_strcasecmp.rs:12:1: 45:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 34,
    "source": "pub unsafe extern \"C\" fn c_strcasecmp(\n    mut s1: *const libc::c_char,\n    mut s2: *const libc::c_char,\n) -> libc::c_int {\n    let mut p1: *const libc::c_uchar = s1 as *const libc::c_uchar;\n    let mut p2: *const libc::c_uchar = s2 as *const libc::c_uchar;\n    let mut c1: libc::c_uchar = 0;\n    let mut c2: libc::c_uchar = 0;\n    if p1 == p2 {\n        return 0 as libc::c_int;\n    }\n    loop {\n        c1 = c_tolower(*p1 as libc::c_int) as libc::c_uchar;\n        c2 = c_tolower(*p2 as libc::c_int) as libc::c_uchar;\n        if c1 as libc::c_int == '\\0' as i32 {\n            break;\n        }\n        p1 = p1.offset(1);\n        p1;\n        p2 = p2.offset(1);\n        p2;\n        if !(c1 as libc::c_int == c2 as libc::c_int) {\n            break;\n        }\n    }\n    if 127 as libc::c_int * 2 as libc::c_int + 1 as libc::c_int\n        <= 2147483647 as libc::c_int\n    {\n        return c1 as libc::c_int - c2 as libc::c_int\n    } else {\n        return (c1 as libc::c_int > c2 as libc::c_int) as libc::c_int\n            - ((c1 as libc::c_int) < c2 as libc::c_int) as libc::c_int\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_strcasecmp.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:691 ~ rust[fc84]::src::quotearg::quoting_options_from_style)",
    "span": "src/quotearg.rs:289:1: 304:2 (#0)",
    "pieces": [
      "src/quotearg.rs:289:1: 304:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn quoting_options_from_style(\n    mut style: quoting_style,\n) -> quoting_options {\n    let mut o: quoting_options = {\n        let mut init = quoting_options {\n            style: literal_quoting_style,\n            flags: 0 as libc::c_int,\n            quote_these_too: [0 as libc::c_int as libc::c_uint, 0, 0, 0, 0, 0, 0, 0],\n            left_quote: 0 as *const libc::c_char,\n            right_quote: 0 as *const libc::c_char,\n        };\n        init\n    };\n    if style as libc::c_uint == custom_quoting_style as libc::c_int as libc::c_uint {\n        abort();\n    }\n    o.style = style;\n    return o;\n}",
    "calls": [
      {
        "caller": "DefId(0:795 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
        "span": "src/quotearg.rs:1450:5: 1450:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:803 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
        "span": "src/quotearg.rs:1526:5: 1526:45 (#0)",
        "source": "options = quoting_options_from_style(s);"
      },
      {
        "caller": "DefId(0:794 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
        "span": "src/quotearg.rs:1438:5: 1438:60 (#0)",
        "source": "let o: quoting_options = quoting_options_from_style(s);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:91:1: 91:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:712 ~ rust[fc84]::src::quotearg::quotearg_n_style_mem)",
    "span": "src/quotearg.rs:1445:1: 1453:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1445:1: 1453:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_mem(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, argsize, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:797 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
        "span": "src/quotearg.rs:1469:5: 1469:54 (#0)",
        "source": "let result_ptr = quotearg_n_style_mem(0, s, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:714 ~ rust[fc84]::src::quotearg::quotearg_style_mem)",
    "span": "src/quotearg.rs:1465:1: 1471:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1465:1: 1471:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_style_mem(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_style_mem(0 as libc::c_int, s, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:12 ~ rust[fc84]::src::c_ctype::c_isascii)",
    "span": "src/c_ctype.rs:35:1: 48:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:35:1: 48:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn c_isascii(mut c: libc::c_int) -> bool {\n    match c {\n        32 | 7 | 8 | 12 | 10 | 13 | 9 | 11 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 14 | 15 | 16\n        | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 127\n        | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101\n        | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114\n        | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 33 | 34 | 35 | 36 | 37 | 38\n        | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 58 | 59 | 60 | 61 | 62 | 63 | 64\n        | 91 | 92 | 93 | 94 | 95 | 96 | 123 | 124 | 125 | 126 | 65 | 66 | 67 | 68 | 69\n        | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85\n        | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:739 ~ rust[fc84]::src::setlocale_null::setlocale_null_r)",
    "span": "src/setlocale_null.rs:15:1: 25:2 (#0)",
    "pieces": [
      "src/setlocale_null.rs:15:1: 25:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    return setlocale_null_r_unlocked(category, buf, bufsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null.rs:2:1: 2:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:902 ~ rust[fc84]::src::xstrtoimax::bkm_scale)",
    "span": "src/xstrtoimax.rs:41:1: 388:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:41:1: 45:4 (#0)",
      "src/xstrtoimax.rs:388:1: 388:2 (#0)"
    ],
    "sub_chunks": [
      4
    ],
    "num_lines": 6,
    "source": "unsafe extern \"C\" fn bkm_scale(\n    mut x: *mut intmax_t,\n    mut scale_factor: libc::c_int,\n) -> strtol_error {\n   <<chunk 4>>}",
    "calls": [
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:516:13: 516:49 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 512);"
      },
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:519:13: 519:50 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 1024);"
      },
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:549:13: 549:47 (#0)",
        "source": "overflow = bkm_scale(&mut tmp, 2);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:26:1: 26:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoimax.rs:27:1: 27:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xstrtoimax.rs:53:17: 127:18 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:53:17: 127:18 (#0)"
        ],
        "num_lines": 75,
        "source": "if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        -(1 as libc::c_int) as intmax_t\n                    }) + scale_factor as libc::c_long\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    (*x < -(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        as libc::c_int\n                } else {\n                    ((if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) - 1 as libc::c_int) < 0 as libc::c_int\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 1 as libc::c_int)\n                            << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) + 0 as libc::c_int\n                    }) < 0 as libc::c_int\n                    {\n                        (scale_factor\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) - 1 as libc::c_int) < 0 as libc::c_int\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) + 1 as libc::c_int)\n                                    << (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) - 1 as libc::c_int\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int) < scale_factor) as libc::c_int\n                    }) != 0\n                    {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + -(1 as libc::c_int) as intmax_t\n                            >> (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                    } else {\n                        -(1 as libc::c_int) as intmax_t / -scale_factor as libc::c_long\n                    }) <= -(1 as libc::c_int) as libc::c_long - *x) as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xstrtoimax.rs:129:17: 232:18 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:129:17: 232:18 (#0)"
        ],
        "num_lines": 104,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    (if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n                        as libc::c_long + 0 as libc::c_int as intmax_t\n                }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n                {\n                    !(((((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 1 as libc::c_int as libc::c_long)\n                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                        - 1 as libc::c_int as libc::c_long)\n                        * 2 as libc::c_int as libc::c_long\n                        + 1 as libc::c_int as libc::c_long)\n                } else {\n                    (if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t\n                    }) + 0 as libc::c_int as libc::c_long\n                }) < 0 as libc::c_int as libc::c_long\n                {\n                    (((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int\n                    } else {\n                        scale_factor\n                    }) as libc::c_long + 0 as libc::c_int as intmax_t)\n                        < -(if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int\n                            } else {\n                                scale_factor\n                            }) as libc::c_long + 0 as libc::c_int as intmax_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int\n                                } else {\n                                    scale_factor\n                                }) as libc::c_long + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long\n                        })) as libc::c_int\n                } else {\n                    ((0 as libc::c_int as libc::c_long)\n                        < (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) as libc::c_long + 0 as libc::c_int as intmax_t) as libc::c_int\n                }) != 0 && scale_factor == -(1 as libc::c_int)\n                {\n                    if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        *x\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        ((0 as libc::c_int as libc::c_long)\n                            < *x + 0 as libc::c_int as intmax_t) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long) < *x\n                            && (-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < *x - 1 as libc::c_int as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((0 as libc::c_int as intmax_t / scale_factor as libc::c_long) < *x)\n                        as libc::c_int\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/xstrtoimax.rs:235:13: 351:14 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:235:13: 351:14 (#0)"
        ],
        "num_lines": 117,
        "source": "if scale_factor == 0 as libc::c_int {\n                0 as libc::c_int\n            } else {\n                if *x < 0 as libc::c_int as libc::c_long {\n                    if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            *x\n                        }) + 0 as libc::c_int as intmax_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    *x\n                                }) + 0 as libc::c_int as intmax_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        *x\n                                    }) + 0 as libc::c_int as intmax_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                *x\n                            }) + 0 as libc::c_int as intmax_t) as libc::c_int\n                    }) != 0 && *x == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int\n                        } else {\n                            scale_factor\n                        }) - 1 as libc::c_int) < 0 as libc::c_int\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < scale_factor as libc::c_long\n                                    + 0 as libc::c_int as intmax_t) as libc::c_int\n                        } else {\n                            ((-(1 as libc::c_int) as libc::c_long\n                                - 0 as libc::c_int as intmax_t)\n                                < (scale_factor - 1 as libc::c_int) as libc::c_long)\n                                as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as intmax_t / *x\n                            < scale_factor as libc::c_long) as libc::c_int\n                    }\n                } else {\n                    ((-(1 as libc::c_int) as intmax_t / scale_factor as libc::c_long)\n                        < *x) as libc::c_int\n                }\n            }",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/xstrtoimax.rs:363:9: 384:33 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:363:9: 384:33 (#0)"
        ],
        "num_lines": 22,
        "source": "*x = if *x < 0 as libc::c_int as libc::c_long {\n            !if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n                -(1 as libc::c_int) as intmax_t\n            } else {\n                (((1 as libc::c_int as intmax_t)\n                    << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                    - 1 as libc::c_int as libc::c_long)\n                    * 2 as libc::c_int as libc::c_long + 1 as libc::c_int as libc::c_long\n            }\n        } else if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n            -(1 as libc::c_int) as intmax_t\n        } else {\n            (((1 as libc::c_int as intmax_t)\n                << (::core::mem::size_of::<intmax_t>() as libc::c_ulong)\n                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                - 1 as libc::c_int as libc::c_long) * 2 as libc::c_int as libc::c_long\n                + 1 as libc::c_int as libc::c_long\n        };\n        return LONGINT_OVERFLOW;",
        "sub_chunks": [],
        "live_in": [
          "mut x: *mut i64"
        ],
        "live_out": [
          "mut x: *mut i64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/xstrtoimax.rs:45:5: 387:23 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:45:5: 53:16 (#0)",
          "src/xstrtoimax.rs:128:1: 129:16 (#0)",
          "src/xstrtoimax.rs:233:1: 235:12 (#0)",
          "src/xstrtoimax.rs:352:1: 363:8 (#0)",
          "src/xstrtoimax.rs:385:1: 387:23 (#0)"
        ],
        "num_lines": 29,
        "source": "let mut scaled: intmax_t = 0;\n    if if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int as libc::c_long } else { *x })\n            - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n        && ((if 1 as libc::c_int != 0 { 0 as libc::c_int } else { scale_factor })\n            - 1 as libc::c_int) < 0 as libc::c_int\n        && (if scale_factor < 0 as libc::c_int {\n            if *x < 0 as libc::c_int as libc::c_long {\n               <<chunk 0>>            } else {\n               <<chunk 1>>            }\n        } else {\n           <<chunk 2>>        }) != 0\n    {\n        let (fresh4, _fresh5) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh4;\n        1 as libc::c_int\n    } else {\n        let (fresh6, fresh7) = (*x).overflowing_mul(scale_factor.into());\n        *(&mut scaled as *mut intmax_t) = fresh6;\n        fresh7 as libc::c_int\n    } != 0\n    {\n       <<chunk 3>>    }\n    *x = scaled;\n    return LONGINT_OK;",
        "sub_chunks": [
          0,
          1,
          2,
          3
        ],
        "live_in": [
          "mut x: *mut i64",
          "mut scale_factor: i32"
        ],
        "live_out": [
          "mut x: *mut i64",
          "mut scale_factor: i32",
          "mut scaled: i64"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:903 ~ rust[fc84]::src::xstrtoimax::bkm_scale_by_power)",
    "span": "src/xstrtoimax.rs:389:1: 403:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:389:1: 403:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "unsafe extern \"C\" fn bkm_scale_by_power(\n    mut x: *mut intmax_t,\n    mut base: libc::c_int,\n    mut power: libc::c_int,\n) -> strtol_error {\n    let mut err: strtol_error = LONGINT_OK;\n    loop {\n        let fresh8 = power;\n        power = power - 1;\n        if !(fresh8 != 0) {\n            break;\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | bkm_scale(x, base) as libc::c_uint);\n    }\n    return err;\n}",
    "calls": [
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:528:13: 528:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 3);"
      },
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:537:13: 537:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 5);"
      },
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:543:13: 543:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 9);"
      },
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:540:13: 540:63 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 10);"
      },
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:531:13: 531:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 1);"
      },
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:555:13: 555:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 7);"
      },
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:546:13: 546:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 4);"
      },
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:552:13: 552:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 8);"
      },
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:525:13: 525:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 6);"
      },
      {
        "caller": "DefId(0:1021 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
        "span": "src/xstrtoimax.rs:534:13: 534:62 (#0)",
        "source": "overflow = bkm_scale_by_power(&mut tmp, base, 2);"
      }
    ],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:27:1: 27:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:139 ~ rust[fc84]::src::fseeko::rpl_fseeko)",
    "span": "src/fseeko.rs:52:1: 74:2 (#0)",
    "pieces": [
      "src/fseeko.rs:52:1: 74:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 18,
    "source": "pub unsafe extern \"C\" fn rpl_fseeko(\n    mut fp: *mut FILE,\n    mut offset: off_t,\n    mut whence: libc::c_int,\n) -> libc::c_int {\n    if (*fp)._IO_read_end == (*fp)._IO_read_ptr\n        && (*fp)._IO_write_ptr == (*fp)._IO_write_base && ((*fp)._IO_save_base).is_null()\n    {\n        let mut pos: off_t = lseek(fileno(fp), offset, whence);\n        if pos == -(1 as libc::c_int) as libc::c_long {\n            return -(1 as libc::c_int);\n        }\n        (*fp)._flags &= !(0x10 as libc::c_int);\n        (*fp)._offset = pos;\n        return 0 as libc::c_int;\n    }\n    return fseeko(fp, offset, whence);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fseeko.rs:1:1: 1:25 (#0)",
        "source": "use std::os::raw::c_int;"
      },
      {
        "span": "src/fseeko.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:782 ~ rust[fc84]::src::version_etc::version_etc_ar)",
    "span": "src/version_etc.rs:248:1: 262:2 (#0)",
    "pieces": [
      "src/version_etc.rs:248:1: 262:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn version_etc_ar(\n    mut stream: *mut FILE,\n    mut command_name: *const libc::c_char,\n    mut package: *const libc::c_char,\n    mut version: *const libc::c_char,\n    mut authors: *const *const libc::c_char,\n) {\n    let mut n_authors: size_t = 0;\n    n_authors = 0 as libc::c_int as size_t;\n    while !(*authors.offset(n_authors as isize)).is_null() {\n        n_authors = n_authors.wrapping_add(1);\n        n_authors;\n    }\n    version_etc_arn(stream, command_name, package, version, authors, n_authors);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:2:1: 2:14 (#0)",
        "source": "use std::ffi;"
      },
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:720 ~ rust[fc84]::src::quotearg::quotearg_n_style_colon)",
    "span": "src/quotearg.rs:1514:1: 1538:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1514:1: 1538:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style_colon(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut options: quoting_options = quoting_options {\n        style: literal_quoting_style,\n        flags: 0,\n        quote_these_too: [0; 8],\n        left_quote: 0 as *const libc::c_char,\n        right_quote: 0 as *const libc::c_char,\n    };\n    options = quoting_options_from_style(s);\n    set_char_quoting(&mut options, ':' as i32 as libc::c_char, 1 as libc::c_int);\n    return quotearg_n_options(\n        n,\n        arg,\n        18446744073709551615 as libc::c_ulong,\n        &mut options,\n    );\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:91:1: 91:52 (#0)",
        "source": "pub const literal_quoting_style: quoting_style = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:686 ~ rust[fc84]::src::quotearg::get_quoting_style)",
    "span": "src/quotearg.rs:201:1: 207:2 (#0)",
    "pieces": [
      "src/quotearg.rs:201:1: 207:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn get_quoting_style(\n    mut o: *const quoting_options,\n) -> quoting_style {\n    return (*if !o.is_null() {\n        o\n    } else {\n        &mut default_quoting_options as *mut quoting_options as *const quoting_options\n    })\n        .style;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:704 ~ rust[fc84]::src::quotearg::quotearg_free)",
    "span": "src/quotearg.rs:1289:1: 1312:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1289:1: 1312:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 20,
    "source": "pub unsafe extern \"C\" fn quotearg_free() {\n    let mut sv: *mut slotvec = slotvec;\n    let mut i: libc::c_int = 0;\n    i = 1 as libc::c_int;\n    while i < nslots {\n        free((*sv.offset(i as isize)).val as *mut libc::c_void);\n        i += 1;\n        i;\n    }\n    if (*sv.offset(0 as libc::c_int as isize)).val != slot0.as_mut_ptr() {\n        free((*sv.offset(0 as libc::c_int as isize)).val as *mut libc::c_void);\n        slotvec0.size = ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong;\n        slotvec0.val = slot0.as_mut_ptr();\n    }\n    if sv != &mut slotvec0 as *mut slotvec {\n        free(sv as *mut libc::c_void);\n        slotvec = &mut slotvec0;\n    }\n    nslots = 1 as libc::c_int;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:1274:1: 1274:50 (#0)",
        "source": "static mut slot0: [libc::c_char; 256] = [0; 256];"
      },
      {
        "span": "src/quotearg.rs:1285:1: 1287:3 (#0)",
        "source": "static mut slotvec: *mut slotvec = unsafe {\n    &slotvec0 as *const slotvec as *mut slotvec\n};"
      },
      {
        "span": "src/quotearg.rs:1276:1: 1284:3 (#0)",
        "source": "static mut slotvec0: slotvec = unsafe {\n    {\n        let mut init = slotvec {\n            size: ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,\n            val: slot0.as_ptr() as *mut _,\n        };\n        init\n    }\n};"
      },
      {
        "span": "src/quotearg.rs:1275:1: 1275:51 (#0)",
        "source": "static mut nslots: libc::c_int = 1 as libc::c_int;"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:904 ~ rust[fc84]::src::xstrtoimax::xstrtoimax)",
    "span": "src/xstrtoimax.rs:406:1: 572:2 (#0)",
    "pieces": [
      "src/xstrtoimax.rs:406:1: 413:4 (#0)",
      "src/xstrtoimax.rs:483:1: 483:4 (#0)",
      "src/xstrtoimax.rs:572:1: 572:2 (#0)"
    ],
    "sub_chunks": [
      0,
      1
    ],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn xstrtoimax(\n    mut s: *const libc::c_char,\n    mut ptr: *mut *mut libc::c_char,\n    mut strtol_base: libc::c_int,\n    mut val: *mut intmax_t,\n    mut valid_suffixes: *const libc::c_char,\n) -> strtol_error {\n   <<chunk 0>>   <<chunk 1>>}",
    "calls": [],
    "globals": [
      {
        "span": "src/xstrtoimax.rs:23:1: 23:45 (#0)",
        "source": "pub const LONGINT_INVALID: strtol_error = 4;"
      },
      {
        "span": "src/xstrtoimax.rs:26:1: 26:46 (#0)",
        "source": "pub const LONGINT_OVERFLOW: strtol_error = 1;"
      },
      {
        "span": "src/xstrtoimax.rs:25:1: 25:57 (#0)",
        "source": "pub const LONGINT_INVALID_SUFFIX_CHAR: strtol_error = 2;"
      },
      {
        "span": "src/xstrtoimax.rs:27:1: 27:40 (#0)",
        "source": "pub const LONGINT_OK: strtol_error = 0;"
      }
    ],
    "imports": [
      {
        "span": "src/xstrtoimax.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/xstrtoimax.rs:413:5: 482:6 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:413:5: 482:6 (#0)"
        ],
        "num_lines": 70,
        "source": "let mut t_ptr: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;\n    let mut tmp: intmax_t = 0;\n    let mut err: strtol_error = LONGINT_OK;\n    if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n        __assert_fail(\n            b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                as *const libc::c_char,\n            b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n            86 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 78],\n                &[libc::c_char; 78],\n            >(\n                b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_2247: {\n        if 0 as libc::c_int <= strtol_base && strtol_base <= 36 as libc::c_int {} else {\n            __assert_fail(\n                b\"0 <= strtol_base && strtol_base <= 36\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"./include/xstrtol.c\\0\" as *const u8 as *const libc::c_char,\n                86 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 78],\n                    &[libc::c_char; 78],\n                >(\n                    b\"strtol_error xstrtoimax(const char *, char **, int, intmax_t *, const char *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    p = if !ptr.is_null() { ptr } else { &mut t_ptr };\n    *__errno_location() = 0 as libc::c_int;\n    if (0 as libc::c_int as intmax_t) < -(1 as libc::c_int) as intmax_t {\n        let mut q: *const libc::c_char = s;\n        let mut ch: libc::c_uchar = *q as libc::c_uchar;\n        while *(*__ctype_b_loc()).offset(ch as libc::c_int as isize) as libc::c_int\n            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n        {\n            q = q.offset(1);\n            ch = *q as libc::c_uchar;\n        }\n        if ch as libc::c_int == '-' as i32 {\n            return LONGINT_INVALID;\n        }\n    }\n    tmp = strtoimax(s, p, strtol_base);\n    if *p == s as *mut libc::c_char {\n        if !valid_suffixes.is_null() && **p as libc::c_int != 0\n            && !(strchr(valid_suffixes, **p as libc::c_int)).is_null()\n        {\n            tmp = 1 as libc::c_int as intmax_t;\n        } else {\n            return LONGINT_INVALID\n        }\n    } else if *__errno_location() != 0 as libc::c_int {\n        if *__errno_location() != 34 as libc::c_int {\n            return LONGINT_INVALID;\n        }\n        err = LONGINT_OVERFLOW;\n    }\n    if valid_suffixes.is_null() {\n        *val = tmp;\n        return err;\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut s: *const i8",
          "mut ptr: *mut *mut i8",
          "mut strtol_base: i32",
          "mut val: *mut i64",
          "mut valid_suffixes: *const i8"
        ],
        "live_out": [
          "mut s: *const i8",
          "mut ptr: *mut *mut i8",
          "mut strtol_base: i32",
          "mut val: *mut i64",
          "mut valid_suffixes: *const i8",
          "mut t_ptr: *mut i8",
          "mut p: *mut *mut i8",
          "mut tmp: i64",
          "mut err: u32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/xstrtoimax.rs:483:5: 570:12 (#0)",
        "pieces": [
          "src/xstrtoimax.rs:483:5: 570:12 (#0)"
        ],
        "num_lines": 102,
        "source": "if **p as libc::c_int != '\\0' as i32 {\n        let mut base: libc::c_int = 1024 as libc::c_int;\n        let mut suffixes: libc::c_int = 1 as libc::c_int;\n        let mut overflow: strtol_error = LONGINT_OK;\n        if (strchr(valid_suffixes, **p as libc::c_int)).is_null() {\n            *val = tmp;\n            return (err as libc::c_uint\n                | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                as strtol_error;\n        }\n        match **p as libc::c_int {\n            69 | 71 | 103 | 107 | 75 | 77 | 109 | 80 | 81 | 82 | 84 | 116 | 89 | 90 => {\n                if !(strchr(valid_suffixes, '0' as i32)).is_null() {\n                    match *(*p.offset(0 as libc::c_int as isize))\n                        .offset(1 as libc::c_int as isize) as libc::c_int\n                    {\n                        105 => {\n                            if *(*p.offset(0 as libc::c_int as isize))\n                                .offset(2 as libc::c_int as isize) as libc::c_int\n                                == 'B' as i32\n                            {\n                                suffixes += 2 as libc::c_int;\n                            }\n                        }\n                        66 | 68 => {\n                            base = 1000 as libc::c_int;\n                            suffixes += 1;\n                            suffixes;\n                        }\n                        _ => {}\n                    }\n                }\n            }\n            _ => {}\n        }\n        match **p as libc::c_int {\n            98 => {\n                overflow = bkm_scale(&mut tmp, 512 as libc::c_int);\n            }\n            66 => {\n                overflow = bkm_scale(&mut tmp, 1024 as libc::c_int);\n            }\n            99 => {\n                overflow = LONGINT_OK;\n            }\n            69 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 6 as libc::c_int);\n            }\n            71 | 103 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 3 as libc::c_int);\n            }\n            107 | 75 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 1 as libc::c_int);\n            }\n            77 | 109 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 2 as libc::c_int);\n            }\n            80 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 5 as libc::c_int);\n            }\n            81 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 10 as libc::c_int);\n            }\n            82 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 9 as libc::c_int);\n            }\n            84 | 116 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 4 as libc::c_int);\n            }\n            119 => {\n                overflow = bkm_scale(&mut tmp, 2 as libc::c_int);\n            }\n            89 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 8 as libc::c_int);\n            }\n            90 => {\n                overflow = bkm_scale_by_power(&mut tmp, base, 7 as libc::c_int);\n            }\n            _ => {\n                *val = tmp;\n                return (err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint)\n                    as strtol_error;\n            }\n        }\n        err = ::core::mem::transmute::<\n            libc::c_uint,\n            strtol_error,\n        >(err as libc::c_uint | overflow as libc::c_uint);\n        *p = (*p).offset(suffixes as isize);\n        if **p != 0 {\n            err = ::core::mem::transmute::<\n                libc::c_uint,\n                strtol_error,\n            >(\n                err as libc::c_uint\n                    | LONGINT_INVALID_SUFFIX_CHAR as libc::c_int as libc::c_uint,\n            );\n        }\n    }\n    *val = tmp;\n    return err;",
        "sub_chunks": [],
        "live_in": [
          "mut val: *mut i64",
          "mut valid_suffixes: *const i8",
          "mut p: *mut *mut i8",
          "mut tmp: i64",
          "mut err: u32"
        ],
        "live_out": [
          "mut val: *mut i64",
          "mut valid_suffixes: *const i8",
          "mut p: *mut *mut i8",
          "mut tmp: i64",
          "mut err: u32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:15 ~ rust[fc84]::src::c_ctype::c_isdigit)",
    "span": "src/c_ctype.rs:71:1: 73:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:71:1: 73:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn c_isdigit(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:859 ~ rust[fc84]::src::xmalloc::xinmalloc)",
    "span": "src/xmalloc.rs:195:1: 198:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:195:1: 198:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn xinmalloc(mut n: idx_t, mut s: idx_t) -> *mut libc::c_void {\n    return xireallocarray(0 as *mut libc::c_void, n, s);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:10 ~ rust[fc84]::src::c_ctype::c_isalnum)",
    "span": "src/c_ctype.rs:21:1: 23:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:21:1: 23:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn c_isalnum(mut c: libc::c_int) -> bool {\n    match c {\n        48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 97 | 98 | 99 | 100 | 101 | 102\n        | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115\n        | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72\n        | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88\n        | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:695 ~ rust[fc84]::src::quotearg::quotearg_alloc)",
    "span": "src/quotearg.rs:1215:1: 1223:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1215:1: 1223:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_alloc(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n    mut o: *const quoting_options,\n) -> *mut libc::c_char {\n    return quotearg_alloc_mem(arg, argsize, 0 as *mut size_t, o);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:711 ~ rust[fc84]::src::quotearg::quotearg_n_style)",
    "span": "src/quotearg.rs:1433:1: 1442:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1433:1: 1442:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn quotearg_n_style(\n    mut n: libc::c_int,\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    let o: quoting_options = quoting_options_from_style(s);\n    return quotearg_n_options(n, arg, 18446744073709551615 as libc::c_ulong, &o);\n}",
    "calls": [
      {
        "caller": "DefId(0:796 ~ rust[fc84]::src::quotearg::quotearg_style)",
        "span": "src/quotearg.rs:1460:5: 1460:50 (#0)",
        "source": "let result_ptr = quotearg_n_style(0, s, arg);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:21 ~ rust[fc84]::src::c_ctype::c_isupper)",
    "span": "src/c_ctype.rs:136:1: 138:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:136:1: 138:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn c_isupper(mut c: libc::c_int) -> bool {\n    match c {\n        65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80\n        | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      },
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:709 ~ rust[fc84]::src::quotearg::quotearg)",
    "span": "src/quotearg.rs:1414:1: 1419:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1414:1: 1419:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn quotearg(mut arg: *const libc::c_char) -> *mut libc::c_char {\n    return quotearg_n(0 as libc::c_int, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:708 ~ rust[fc84]::src::quotearg::quotearg_n_mem)",
    "span": "src/quotearg.rs:1406:1: 1412:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1406:1: 1412:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn quotearg_n_mem(\n    mut n: libc::c_int,\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_options(n, arg, argsize, &mut default_quoting_options);\n}",
    "calls": [
      {
        "caller": "DefId(0:793 ~ rust[fc84]::src::quotearg::quotearg_mem)",
        "span": "src/quotearg.rs:1427:9: 1427:68 (#0)",
        "source": "result_ptr = quotearg_n_mem(0, c_string.as_ptr(), argsize);"
      }
    ],
    "globals": [
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:685 ~ rust[fc84]::src::quotearg::clone_quoting_options)",
    "span": "src/quotearg.rs:192:1: 198:2 (#0)",
    "pieces": [
      "src/quotearg.rs:192:1: 198:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 15,
    "source": "pub unsafe extern \"C\" fn clone_quoting_options(\n    mut o: *mut quoting_options,\n) -> *mut quoting_options {\n    let mut e: libc::c_int = *__errno_location();\n    let mut p: *mut quoting_options = xmemdup(\n        (if !o.is_null() {\n            o\n        } else {\n            &mut default_quoting_options as *mut quoting_options\n        }) as *const libc::c_void,\n        ::core::mem::size_of::<quoting_options>() as libc::c_ulong,\n    ) as *mut quoting_options;\n    *__errno_location() = e;\n    return p;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/quotearg.rs:184:1: 190:3 (#0)",
        "source": "static mut default_quoting_options: quoting_options = quoting_options {\n    style: literal_quoting_style,\n    flags: 0,\n    quote_these_too: [0; 8],\n    left_quote: 0 as *const libc::c_char,\n    right_quote: 0 as *const libc::c_char,\n};"
      }
    ],
    "imports": [
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:787 ~ rust[fc84]::src::version_etc::emit_bug_reporting_address)",
    "span": "src/version_etc.rs:305:1: 320:2 (#0)",
    "pieces": [
      "src/version_etc.rs:305:1: 320:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub unsafe extern \"C\" fn emit_bug_reporting_address() {\n    fputs_unlocked(b\"\\n\\0\" as *const u8 as *const libc::c_char, stdout);\n    printf(\n        gettext(b\"Report bugs to: %s\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"bug-coreutils@gnu.org\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(b\"%s home page: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    printf(\n        gettext(\n            b\"General help using GNU software: <%s>\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        b\"https://www.gnu.org/gethelp/\\0\" as *const u8 as *const libc::c_char,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/version_etc.rs:4:1: 4:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/version_etc.rs:2:1: 2:14 (#0)",
        "source": "use std::ffi;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:102 ~ rust[fc84]::src::fclose::rpl_fclose)",
    "span": "src/fclose.rs:53:1: 79:2 (#0)",
    "pieces": [
      "src/fclose.rs:53:1: 79:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 21,
    "source": "pub unsafe extern \"C\" fn rpl_fclose(mut fp: *mut FILE) -> libc::c_int {\n    let mut saved_errno: libc::c_int = 0 as libc::c_int;\n    let mut fd: libc::c_int = 0;\n    let mut result: libc::c_int = 0 as libc::c_int;\n    fd = fileno(fp);\n    if fd < 0 as libc::c_int {\n        return fclose(fp);\n    }\n    if (!(__freading(fp) != 0 as libc::c_int)\n        || lseek(fileno(fp), 0 as libc::c_int as __off_t, 1 as libc::c_int)\n            != -(1 as libc::c_int) as libc::c_long) && rpl_fflush(fp) != 0\n    {\n        saved_errno = *__errno_location();\n    }\n    result = fclose(fp);\n    if saved_errno != 0 as libc::c_int {\n        *__errno_location() = saved_errno;\n        result = -(1 as libc::c_int);\n    }\n    return result;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/fclose.rs:2:1: 2:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:587 ~ rust[fc84]::src::mbszero::mbszero)",
    "span": "src/mbszero.rs:27:1: 31:2 (#0)",
    "pieces": [
      "src/mbszero.rs:27:1: 31:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn mbszero(mut ps: *mut mbstate_t) {\n    memset(\n        ps as *mut libc::c_void,\n        0 as libc::c_int,\n        ::core::mem::size_of::<mbstate_t>() as libc::c_ulong,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/mbszero.rs:1:1: 1:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/mbszero.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:868 ~ rust[fc84]::src::xmalloc::ximemdup)",
    "span": "src/xmalloc.rs:987:1: 991:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:987:1: 991:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn ximemdup(\n    mut p: *const libc::c_void,\n    mut s: idx_t,\n) -> *mut libc::c_void {\n    return memcpy(ximalloc(s), p, s as libc::c_ulong);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:168 ~ rust[fc84]::src::ialloc::imalloc)",
    "span": "src/ialloc.rs:92:1: 104:2 (#0)",
    "pieces": [
      "src/ialloc.rs:92:1: 104:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn imalloc(mut s: idx_t) -> *mut libc::c_void {\n    return if s as libc::c_ulong <= 18446744073709551615 as libc::c_ulong {\n        malloc(s as libc::c_ulong)\n    } else {\n        _gl_alloc_nomem()\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/ialloc.rs:12:1: 12:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/ialloc.rs:6:1: 6:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/ialloc.rs:8:1: 8:16 (#0)",
        "source": "use std::alloc;"
      },
      {
        "span": "src/ialloc.rs:4:1: 4:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/ialloc.rs:9:1: 9:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/ialloc.rs:2:1: 2:16 (#0)",
        "source": "use std::usize;"
      },
      {
        "span": "src/ialloc.rs:10:1: 10:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:710 ~ rust[fc84]::src::quotearg::quotearg_mem)",
    "span": "src/quotearg.rs:1422:1: 1430:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1422:1: 1430:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *mut libc::c_char {\n    return quotearg_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:713 ~ rust[fc84]::src::quotearg::quotearg_style)",
    "span": "src/quotearg.rs:1456:1: 1462:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1456:1: 1462:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quotearg_style(\n    mut s: quoting_style,\n    mut arg: *const libc::c_char,\n) -> *mut libc::c_char {\n    return quotearg_n_style(0 as libc::c_int, s, arg);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:11 ~ rust[fc84]::src::c_ctype::c_isalpha)",
    "span": "src/c_ctype.rs:28:1: 30:2 (#0)",
    "pieces": [
      "src/c_ctype.rs:28:1: 30:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn c_isalpha(mut c: libc::c_int) -> bool {\n    match c {\n        97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110\n        | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 65 | 66\n        | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82\n        | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 => return 1 as libc::c_int != 0,\n        _ => return 0 as libc::c_int != 0,\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/c_ctype.rs:17:1: 17:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/c_ctype.rs:15:1: 15:30 (#0)",
        "source": "use std::ops::RangeInclusive;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:579 ~ rust[fc84]::src::mbrtoc32::rpl_mbrtoc32)",
    "span": "src/mbrtoc32.rs:52:1: 93:2 (#0)",
    "pieces": [
      "src/mbrtoc32.rs:52:1: 93:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 31,
    "source": "pub unsafe extern \"C\" fn rpl_mbrtoc32(\n    mut pwc: *mut char32_t,\n    mut s: *const libc::c_char,\n    mut n: size_t,\n    mut ps: *mut mbstate_t,\n) -> size_t {\n    if s.is_null() {\n        pwc = 0 as *mut char32_t;\n        s = b\"\\0\" as *const u8 as *const libc::c_char;\n        n = 1 as libc::c_int as size_t;\n    }\n    if ps.is_null() {\n        ps = &mut internal_state;\n    }\n    let mut ret: size_t = mbrtoc32(pwc, s, n, ps);\n    if ret < -(3 as libc::c_int) as size_t && mbsinit(ps) == 0 {\n        mbszero(ps);\n    }\n    if ret == -(3 as libc::c_int) as size_t {\n        abort();\n    }\n    if -(2 as libc::c_int) as size_t <= ret && n != 0 as libc::c_int as libc::c_ulong\n        && !hard_locale(0 as libc::c_int)\n    {\n        if !pwc.is_null() {\n            *pwc = *s as libc::c_uchar as char32_t;\n        }\n        return 1 as libc::c_int as size_t;\n    }\n    return ret;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/mbrtoc32.rs:47:1: 50:3 (#0)",
        "source": "static mut internal_state: mbstate_t = mbstate_t {\n    __count: 0,\n    __value: C2RustUnnamed { __wch: 0 },\n};"
      }
    ],
    "imports": [
      {
        "span": "src/mbrtoc32.rs:2:1: 2:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/mbrtoc32.rs:3:1: 3:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/mbrtoc32.rs:6:1: 6:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/mbrtoc32.rs:4:1: 4:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:805 ~ rust[fc84]::src::xalloc_die::xalloc_die)",
    "span": "src/xalloc_die.rs:16:1: 53:2 (#0)",
    "pieces": [
      "src/xalloc_die.rs:16:1: 53:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 41,
    "source": "pub unsafe extern \"C\" fn xalloc_die() {\n    if 0 != 0 {\n        error(\n            exit_failure,\n            0 as libc::c_int,\n            b\"%s\\0\" as *const u8 as *const libc::c_char,\n            gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n        );\n        if exit_failure != 0 as libc::c_int {\n            unreachable!();\n        } else {};\n    } else {\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n        ({\n            let __errstatus: libc::c_int = exit_failure;\n            error(\n                __errstatus,\n                0 as libc::c_int,\n                b\"%s\\0\" as *const u8 as *const libc::c_char,\n                gettext(b\"memory exhausted\\0\" as *const u8 as *const libc::c_char),\n            );\n            if __errstatus != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n            \n        });\n    };\n    abort();\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xalloc_die.rs:1:1: 1:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/xalloc_die.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:853 ~ rust[fc84]::src::xmalloc::xcharalloc)",
    "span": "src/xmalloc.rs:131:1: 139:2 (#0)",
    "pieces": [
      "src/xmalloc.rs:131:1: 139:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "pub unsafe extern \"C\" fn xcharalloc(mut n: size_t) -> *mut libc::c_char {\n    return (if ::core::mem::size_of::<libc::c_char>() as libc::c_ulong\n        == 1 as libc::c_int as libc::c_ulong\n    {\n        xmalloc(n)\n    } else {\n        xnmalloc(n, ::core::mem::size_of::<libc::c_char>() as libc::c_ulong)\n    }) as *mut libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/xmalloc.rs:17:18: 17:22 (#0)",
        "source": "self"
      },
      {
        "span": "src/xmalloc.rs:13:1: 13:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/xmalloc.rs:15:1: 15:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/xmalloc.rs:23:1: 23:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/xmalloc.rs:17:24: 17:30 (#0)",
        "source": "Layout"
      },
      {
        "span": "src/xmalloc.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/xmalloc.rs:17:1: 17:32 (#0)",
        "source": "use std::alloc::{self, Layout};"
      },
      {
        "span": "src/xmalloc.rs:21:1: 21:19 (#0)",
        "source": "use std::vec::Vec;"
      },
      {
        "span": "src/xmalloc.rs:11:1: 11:25 (#0)",
        "source": "use std::option::Option;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:728 ~ rust[fc84]::src::quotearg::quote_mem)",
    "span": "src/quotearg.rs:1632:1: 1636:2 (#0)",
    "pieces": [
      "src/quotearg.rs:1632:1: 1636:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn quote_mem(\n    mut arg: *const libc::c_char,\n    mut argsize: size_t,\n) -> *const libc::c_char {\n    return quote_n_mem(0 as libc::c_int, arg, argsize);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/quotearg.rs:32:1: 32:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/quotearg.rs:26:1: 26:23 (#0)",
        "source": "use std::clone::Clone;"
      },
      {
        "span": "src/quotearg.rs:38:1: 38:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/quotearg.rs:34:1: 34:26 (#0)",
        "source": "use std::os::raw::c_char;"
      },
      {
        "span": "src/quotearg.rs:36:1: 36:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/quotearg.rs:30:1: 30:25 (#0)",
        "source": "use std::option::Option;"
      },
      {
        "span": "src/quotearg.rs:26:5: 26:22 (#0)",
        "source": "std::clone::Clone"
      },
      {
        "span": "src/quotearg.rs:28:1: 28:15 (#0)",
        "source": "use std::char;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:751 ~ rust[fc84]::src::setlocale_null_unlocked::setlocale_null_r_unlocked)",
    "span": "src/setlocale_null_unlocked.rs:25:1: 56:2 (#0)",
    "pieces": [
      "src/setlocale_null_unlocked.rs:25:1: 56:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn setlocale_null_r_unlocked(\n    mut category: libc::c_int,\n    mut buf: *mut libc::c_char,\n    mut bufsize: size_t,\n) -> libc::c_int {\n    let mut result: *const libc::c_char = setlocale_null_unlocked(category);\n    if result.is_null() {\n        if bufsize > 0 as libc::c_int as libc::c_ulong {\n            *buf.offset(0 as libc::c_int as isize) = '\\0' as i32 as libc::c_char;\n        }\n        return 22 as libc::c_int;\n    } else {\n        let mut length: size_t = strlen(result);\n        if length < bufsize {\n            memcpy(\n                buf as *mut libc::c_void,\n                result as *const libc::c_void,\n                length.wrapping_add(1 as libc::c_int as libc::c_ulong),\n            );\n            return 0 as libc::c_int;\n        } else {\n            if bufsize > 0 as libc::c_int as libc::c_ulong {\n                memcpy(\n                    buf as *mut libc::c_void,\n                    result as *const libc::c_void,\n                    bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong),\n                );\n                *buf\n                    .offset(\n                        bufsize.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,\n                    ) = '\\0' as i32 as libc::c_char;\n            }\n            return 34 as libc::c_int;\n        }\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/setlocale_null_unlocked.rs:3:1: 3:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/setlocale_null_unlocked.rs:1:1: 1:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:97 ~ truncate[c51a]::emit_ancillary_info)",
    "span": "src/truncate.rs:235:1: 302:2 (#0)",
    "pieces": [
      "src/truncate.rs:235:1: 302:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 115,
    "source": "unsafe extern \"C\" fn emit_ancillary_info(mut program: *const libc::c_char) {\n    let infomap_0: [infomap; 7] = [\n        {\n            let mut init = infomap {\n                program: b\"[\\0\" as *const u8 as *const libc::c_char,\n                node: b\"test invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n                node: b\"Multi-call invocation\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha224sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha256sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha384sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: b\"sha512sum\\0\" as *const u8 as *const libc::c_char,\n                node: b\"sha2 utilities\\0\" as *const u8 as *const libc::c_char,\n            };\n            init\n        },\n        {\n            let mut init = infomap {\n                program: 0 as *const libc::c_char,\n                node: 0 as *const libc::c_char,\n            };\n            init\n        },\n    ];\n    let mut node: *const libc::c_char = program;\n    let mut map_prog: *const infomap = infomap_0.as_ptr();\n    while !((*map_prog).program).is_null()\n        && !(strcmp(program, (*map_prog).program) == 0 as libc::c_int)\n    {\n        map_prog = map_prog.offset(1);\n        map_prog;\n    }\n    if !((*map_prog).node).is_null() {\n        node = (*map_prog).node;\n    }\n    printf(\n        gettext(b\"\\n%s online help: <%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n    );\n    let mut lc_messages: *const libc::c_char = setlocale(\n        5 as libc::c_int,\n        0 as *const libc::c_char,\n    );\n    if !lc_messages.is_null()\n        && strncmp(\n            lc_messages,\n            b\"en_\\0\" as *const u8 as *const libc::c_char,\n            (::core::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)\n                .wrapping_sub(1 as libc::c_int as libc::c_ulong),\n        ) != 0\n    {\n        fputs_unlocked(\n            gettext(\n                b\"Report any translation bugs to <https://translationproject.org/team/>\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n    }\n    let mut url_program: *const libc::c_char = if strcmp(\n        program,\n        b\"[\\0\" as *const u8 as *const libc::c_char,\n    ) == 0 as libc::c_int\n    {\n        b\"test\\0\" as *const u8 as *const libc::c_char\n    } else {\n        program\n    };\n    printf(\n        gettext(b\"Full documentation <%s%s>\\n\\0\" as *const u8 as *const libc::c_char),\n        b\"https://www.gnu.org/software/coreutils/\\0\" as *const u8 as *const libc::c_char,\n        url_program,\n    );\n    printf(\n        gettext(\n            b\"or available locally via: info '(coreutils) %s%s'\\n\\0\" as *const u8\n                as *const libc::c_char,\n        ),\n        node,\n        if node == program {\n            b\" invocation\\0\" as *const u8 as *const libc::c_char\n        } else {\n            b\"\\0\" as *const u8 as *const libc::c_char\n        },\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:122 ~ truncate[c51a]::usage)",
        "span": "src/truncate.rs:432:9: 432:80 (#0)",
        "source": "emit_ancillary_info(CStr::from_bytes_with_nul(b\"truncate\\0\").unwrap());"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:23:1: 23:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/truncate.rs:21:1: 21:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/truncate.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/truncate.rs:18:1: 18:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/truncate.rs:20:1: 20:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/truncate.rs:17:1: 17:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:102 ~ truncate[c51a]::emit_size_note)",
    "span": "src/truncate.rs:316:1: 320:2 (#0)",
    "pieces": [
      "src/truncate.rs:316:1: 320:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_size_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\\nUnits are K,M,G,T,P,E,Z,Y,R,Q (powers of 1024) or KB,MB,... (powers of 1000).\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:122 ~ truncate[c51a]::usage)",
        "span": "src/truncate.rs:427:9: 427:26 (#0)",
        "source": "emit_size_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:17:1: 17:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/truncate.rs:21:1: 21:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/truncate.rs:23:1: 23:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/truncate.rs:18:1: 18:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/truncate.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/truncate.rs:20:1: 20:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:101 ~ truncate[c51a]::emit_mandatory_arg_note)",
    "span": "src/truncate.rs:310:1: 313:2 (#0)",
    "pieces": [
      "src/truncate.rs:310:1: 313:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn emit_mandatory_arg_note() {\n    fputs_unlocked(\n        gettext(\n            b\"\\nMandatory arguments to long options are mandatory for short options too.\\n\\0\"\n                as *const u8 as *const libc::c_char,\n        ),\n        stdout,\n    );\n}",
    "calls": [
      {
        "caller": "DefId(0:122 ~ truncate[c51a]::usage)",
        "span": "src/truncate.rs:406:9: 406:35 (#0)",
        "source": "emit_mandatory_arg_note();"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:21:1: 21:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/truncate.rs:23:1: 23:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/truncate.rs:20:1: 20:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/truncate.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/truncate.rs:17:1: 17:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/truncate.rs:18:1: 18:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:108 ~ truncate[c51a]::usage)",
    "span": "src/truncate.rs:391:1: 435:2 (#0)",
    "pieces": [
      "src/truncate.rs:391:1: 435:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 72,
    "source": "pub unsafe extern \"C\" fn usage(mut status: libc::c_int) {\n    if status != 0 as libc::c_int {\n        fprintf(\n            stderr,\n            gettext(\n                b\"Try '%s --help' for more information.\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            program_name,\n        );\n    } else {\n        printf(\n            gettext(\n                b\"Usage: %s OPTION... FILE...\\n\\0\" as *const u8 as *const libc::c_char,\n            ),\n            program_name,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"Shrink or extend the size of each FILE to the specified size\\n\\nA FILE argument that does not exist is created.\\n\\nIf a FILE is larger than the specified size, the extra data is lost.\\nIf a FILE is shorter, it is extended and the sparse extended part (hole)\\nreads as zero bytes.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_mandatory_arg_note();\n        fputs_unlocked(\n            gettext(\n                b\"  -c, --no-create        do not create any files\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"  -r, --reference=RFILE  base size on RFILE\\n  -s, --size=SIZE        set or adjust the file size by SIZE bytes\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --help        display this help and exit\\n\\0\" as *const u8\n                    as *const libc::c_char,\n            ),\n            stdout,\n        );\n        fputs_unlocked(\n            gettext(\n                b\"      --version     output version information and exit\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_size_note();\n        fputs_unlocked(\n            gettext(\n                b\"\\nSIZE may also be prefixed by one of the following modifying characters:\\n'+' extend by, '-' reduce by, '<' at most, '>' at least,\\n'/' round down to multiple of, '%' round up to multiple of.\\n\\0\"\n                    as *const u8 as *const libc::c_char,\n            ),\n            stdout,\n        );\n        emit_ancillary_info(b\"truncate\\0\" as *const u8 as *const libc::c_char);\n    }\n    exit(status);\n}",
    "calls": [
      {
        "caller": "DefId(0:125 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1355:9: 1355:18 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:125 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1434:5: 1434:14 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:125 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1191:17: 1191:26 (#0)",
        "source": "usage(0);"
      },
      {
        "caller": "DefId(0:125 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1209:17: 1209:26 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:125 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1123:25: 1123:34 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:125 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1426:9: 1426:18 (#0)",
        "source": "usage(1);"
      },
      {
        "caller": "DefId(0:125 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1284:9: 1284:18 (#0)",
        "source": "usage(1);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:18:1: 18:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/truncate.rs:17:1: 17:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/truncate.rs:23:1: 23:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/truncate.rs:20:1: 20:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/truncate.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/truncate.rs:21:1: 21:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:100 ~ truncate[c51a]::to_uchar)",
    "span": "src/truncate.rs:305:1: 307:2 (#0)",
    "pieces": [
      "src/truncate.rs:305:1: 307:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn to_uchar(mut ch: libc::c_char) -> libc::c_uchar {\n    return ch as libc::c_uchar;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:23:1: 23:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/truncate.rs:17:1: 17:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/truncate.rs:18:1: 18:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/truncate.rs:21:1: 21:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/truncate.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/truncate.rs:20:1: 20:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:109 ~ truncate[c51a]::do_ftruncate)",
    "span": "src/truncate.rs:437:1: 998:2 (#0)",
    "pieces": [
      "src/truncate.rs:437:1: 444:4 (#0)",
      "src/truncate.rs:998:1: 998:2 (#0)"
    ],
    "sub_chunks": [
      7
    ],
    "num_lines": 9,
    "source": "unsafe extern \"C\" fn do_ftruncate(\n    mut fd: libc::c_int,\n    mut fname: *const libc::c_char,\n    mut ssize: off_t,\n    mut rsize: off_t,\n    mut rel_mode: rel_mode_t,\n) -> bool {\n   <<chunk 7>>}",
    "calls": [
      {
        "caller": "DefId(0:125 ~ truncate[c51a]::main_0)",
        "span": "src/truncate.rs:1504:9: 1504:67 (#0)",
        "source": "errors |= !do_ftruncate(fd, fname, size, rsize, rel_mode);"
      }
    ],
    "globals": [
      {
        "span": "src/truncate.rs:215:1: 215:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      }
    ],
    "imports": [
      {
        "span": "src/truncate.rs:21:1: 21:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/truncate.rs:20:1: 20:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/truncate.rs:17:1: 17:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/truncate.rs:23:1: 23:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/truncate.rs:18:1: 18:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/truncate.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/truncate.rs:532:21: 612:22 (#0)",
        "pieces": [
          "src/truncate.rs:532:21: 612:22 (#0)"
        ],
        "num_lines": 81,
        "source": "if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            -(1 as libc::c_int) as off_t\n                        }) + blksize\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        (ssize < -(1 as libc::c_int) as off_t / blksize) as libc::c_int\n                    } else {\n                        ((if (if (if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            !(((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as libc::c_long\n                        }) < 0 as libc::c_int as libc::c_long\n                        {\n                            (blksize\n                                < -(if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    blksize\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) - 1 as libc::c_int as libc::c_long\n                                })) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long) < blksize) as libc::c_int\n                        }) != 0\n                        {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + -(1 as libc::c_int) as off_t\n                                >> (::core::mem::size_of::<ptrdiff_t>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)\n                        } else {\n                            -(1 as libc::c_int) as off_t / -blksize\n                        }) <= -(1 as libc::c_int) as libc::c_long - ssize) as libc::c_int\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut ssize: i64",
          "mut blksize: i64"
        ],
        "live_out": [
          "mut ssize: i64",
          "mut blksize: i64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/truncate.rs:614:21: 720:22 (#0)",
        "pieces": [
          "src/truncate.rs:614:21: 720:22 (#0)"
        ],
        "num_lines": 107,
        "source": "if (if (if ((if 1 as libc::c_int != 0 {\n                        0 as libc::c_int as libc::c_long\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) + 0 as libc::c_int as off_t\n                    }) - 1 as libc::c_int as libc::c_long)\n                        < 0 as libc::c_int as libc::c_long\n                    {\n                        !(((((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t\n                        }) + 1 as libc::c_int as libc::c_long)\n                            << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long)\n                    } else {\n                        (if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t\n                        }) + 0 as libc::c_int as libc::c_long\n                    }) < 0 as libc::c_int as libc::c_long\n                    {\n                        (((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            blksize\n                        }) + 0 as libc::c_int as off_t)\n                            < -(if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    blksize\n                                }) + 0 as libc::c_int as off_t\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 0 as libc::c_int as off_t\n                                }) + 1 as libc::c_int as libc::c_long)\n                                    << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                        .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                        .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                    - 1 as libc::c_int as libc::c_long)\n                                    * 2 as libc::c_int as libc::c_long\n                                    + 1 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        blksize\n                                    }) + 0 as libc::c_int as off_t\n                                }) - 1 as libc::c_int as libc::c_long\n                            })) as libc::c_int\n                    } else {\n                        ((0 as libc::c_int as libc::c_long)\n                            < (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) + 0 as libc::c_int as off_t) as libc::c_int\n                    }) != 0 && blksize == -(1 as libc::c_int) as libc::c_long\n                    {\n                        if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            ssize\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            ((0 as libc::c_int as libc::c_long)\n                                < ssize + 0 as libc::c_int as off_t) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long) < ssize\n                                && (-(1 as libc::c_int) as libc::c_long\n                                    - 0 as libc::c_int as off_t)\n                                    < ssize - 1 as libc::c_int as libc::c_long) as libc::c_int\n                        }\n                    } else {\n                        (0 as libc::c_int as off_t / blksize < ssize) as libc::c_int\n                    }",
        "sub_chunks": [],
        "live_in": [
          "mut ssize: i64",
          "mut blksize: i64"
        ],
        "live_out": [
          "mut ssize: i64",
          "mut blksize: i64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/truncate.rs:723:17: 836:18 (#0)",
        "pieces": [
          "src/truncate.rs:723:17: 836:18 (#0)"
        ],
        "num_lines": 114,
        "source": "if blksize == 0 as libc::c_int as libc::c_long {\n                    0 as libc::c_int\n                } else {\n                    if ssize < 0 as libc::c_int as libc::c_long {\n                        if (if (if ((if 1 as libc::c_int != 0 {\n                            0 as libc::c_int as libc::c_long\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                ssize\n                            }) + 0 as libc::c_int as off_t\n                        }) - 1 as libc::c_int as libc::c_long)\n                            < 0 as libc::c_int as libc::c_long\n                        {\n                            !(((((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t\n                            }) + 1 as libc::c_int as libc::c_long)\n                                << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                    .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                - 1 as libc::c_int as libc::c_long)\n                                * 2 as libc::c_int as libc::c_long\n                                + 1 as libc::c_int as libc::c_long)\n                        } else {\n                            (if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t\n                            }) + 0 as libc::c_int as libc::c_long\n                        }) < 0 as libc::c_int as libc::c_long\n                        {\n                            (((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                ssize\n                            }) + 0 as libc::c_int as off_t)\n                                < -(if ((if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        ssize\n                                    }) + 0 as libc::c_int as off_t\n                                }) - 1 as libc::c_int as libc::c_long)\n                                    < 0 as libc::c_int as libc::c_long\n                                {\n                                    ((((if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            ssize\n                                        }) + 0 as libc::c_int as off_t\n                                    }) + 1 as libc::c_int as libc::c_long)\n                                        << (::core::mem::size_of::<libc::c_long>() as libc::c_ulong)\n                                            .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                                        - 1 as libc::c_int as libc::c_long)\n                                        * 2 as libc::c_int as libc::c_long\n                                        + 1 as libc::c_int as libc::c_long\n                                } else {\n                                    (if 1 as libc::c_int != 0 {\n                                        0 as libc::c_int as libc::c_long\n                                    } else {\n                                        (if 1 as libc::c_int != 0 {\n                                            0 as libc::c_int as libc::c_long\n                                        } else {\n                                            ssize\n                                        }) + 0 as libc::c_int as off_t\n                                    }) - 1 as libc::c_int as libc::c_long\n                                })) as libc::c_int\n                        } else {\n                            ((0 as libc::c_int as libc::c_long)\n                                < (if 1 as libc::c_int != 0 {\n                                    0 as libc::c_int as libc::c_long\n                                } else {\n                                    ssize\n                                }) + 0 as libc::c_int as off_t) as libc::c_int\n                        }) != 0 && ssize == -(1 as libc::c_int) as libc::c_long\n                        {\n                            if ((if 1 as libc::c_int != 0 {\n                                0 as libc::c_int as libc::c_long\n                            } else {\n                                blksize\n                            }) - 1 as libc::c_int as libc::c_long)\n                                < 0 as libc::c_int as libc::c_long\n                            {\n                                ((0 as libc::c_int as libc::c_long)\n                                    < blksize + 0 as libc::c_int as off_t) as libc::c_int\n                            } else {\n                                ((-(1 as libc::c_int) as libc::c_long\n                                    - 0 as libc::c_int as off_t)\n                                    < blksize - 1 as libc::c_int as libc::c_long) as libc::c_int\n                            }\n                        } else {\n                            (0 as libc::c_int as off_t / ssize < blksize) as libc::c_int\n                        }\n                    } else {\n                        (-(1 as libc::c_int) as off_t / blksize < ssize) as libc::c_int\n                    }\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut ssize: i64",
          "mut blksize: i64"
        ],
        "live_out": [
          "mut ssize: i64",
          "mut blksize: i64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/truncate.rs:848:13: 881:14 (#0)",
        "pieces": [
          "src/truncate.rs:848:13: 881:14 (#0)"
        ],
        "num_lines": 54,
        "source": "if 0 != 0 {\n                error(\n                    0 as libc::c_int,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"overflow in %jd * %td byte blocks for file %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    ssize0,\n                    blksize,\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                );\n                if 0 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"overflow in %jd * %td byte blocks for file %s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        ssize0,\n                        blksize,\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 0 as libc::c_int;\n                    error(\n                        __errstatus,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"overflow in %jd * %td byte blocks for file %s\\0\"\n                                as *const u8 as *const libc::c_char,\n                        ),\n                        ssize0,\n                        blksize,\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n            return 0 as libc::c_int != 0;",
        "sub_chunks": [],
        "live_in": [
          "mut fname: *const i8",
          "mut blksize: i64",
          "mut ssize0: i64",
          "__errstatus: i32"
        ],
        "live_out": [
          "mut fname: *const i8",
          "mut blksize: i64",
          "mut ssize0: i64",
          "__errstatus: i32"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/truncate.rs:508:9: 883:10 (#0)",
        "pieces": [
          "src/truncate.rs:508:9: 532:20 (#0)",
          "src/truncate.rs:613:1: 614:20 (#0)",
          "src/truncate.rs:721:1: 723:16 (#0)",
          "src/truncate.rs:837:1: 848:12 (#0)",
          "src/truncate.rs:883:1: 883:10 (#0)"
        ],
        "num_lines": 43,
        "source": "let mut blksize: ptrdiff_t = (if (0 as libc::c_int) < sb.st_blksize\n            && sb.st_blksize as libc::c_ulong\n                <= (-(1 as libc::c_int) as size_t)\n                    .wrapping_div(8 as libc::c_int as libc::c_ulong)\n                    .wrapping_add(1 as libc::c_int as libc::c_ulong)\n        {\n            sb.st_blksize\n        } else {\n            512 as libc::c_int\n        }) as ptrdiff_t;\n        let mut ssize0: intmax_t = ssize;\n        if if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t\n            && ((if 1 as libc::c_int != 0 {\n                0 as libc::c_int as libc::c_long\n            } else {\n                ssize\n            }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n            && ((if 1 as libc::c_int != 0 {\n                0 as libc::c_int as libc::c_long\n            } else {\n                blksize\n            }) - 1 as libc::c_int as libc::c_long) < 0 as libc::c_int as libc::c_long\n            && (if blksize < 0 as libc::c_int as libc::c_long {\n                if ssize < 0 as libc::c_int as libc::c_long {\n                   <<chunk 0>>                } else {\n                   <<chunk 1>>                }\n            } else {\n               <<chunk 2>>            }) != 0\n        {\n            let (fresh4, _fresh5) = ssize.overflowing_mul(blksize);\n            *(&mut ssize as *mut off_t) = fresh4;\n            1 as libc::c_int\n        } else {\n            let (fresh6, fresh7) = ssize.overflowing_mul(blksize);\n            *(&mut ssize as *mut off_t) = fresh6;\n            fresh7 as libc::c_int\n        } != 0\n        {\n           <<chunk 3>>        }",
        "sub_chunks": [
          0,
          1,
          2,
          3
        ],
        "live_in": [
          "mut fname: *const i8",
          "mut ssize: i64",
          "mut sb: stat",
          "__errstatus: i32"
        ],
        "live_out": [
          "mut fname: *const i8",
          "mut ssize: i64",
          "mut sb: stat",
          "mut blksize: i64",
          "mut ssize0: i64",
          "__errstatus: i32"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/truncate.rs:886:9: 911:2 (#0)",
        "pieces": [
          "src/truncate.rs:886:9: 911:2 (#0)"
        ],
        "num_lines": 108,
        "source": "let mut fsize: off_t = 0;\n        if 0 as libc::c_int as libc::c_long <= rsize {\n            fsize = rsize;\n        } else if usable_st_size(&mut sb) {\n            fsize = sb.st_size;\n            if fsize < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"%s has unusable, apparently negative size\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s has unusable, apparently negative size\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"%s has unusable, apparently negative size\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return 0 as libc::c_int != 0;\n            }\n        } else {\n            fsize = lseek(fd, 0 as libc::c_int as __off_t, 2 as libc::c_int);\n            if fsize < 0 as libc::c_int as libc::c_long {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot get the size of %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot get the size of %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot get the size of %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return 0 as libc::c_int != 0;\n            }\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut fd: i32",
          "mut fname: *const i8",
          "mut rsize: i64",
          "mut sb: stat"
        ],
        "live_out": [
          "mut fd: i32",
          "mut fname: *const i8",
          "mut rsize: i64",
          "mut sb: stat",
          "mut fsize: i64"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/truncate.rs:913:9: 936:2 (#0)",
        "pieces": [
          "src/truncate.rs:913:9: 936:2 (#0)"
        ],
        "num_lines": 68,
        "source": "if rel_mode as libc::c_uint == rm_min as libc::c_int as libc::c_uint {\n            nsize = if fsize > ssize { fsize } else { ssize };\n        } else if rel_mode as libc::c_uint == rm_max as libc::c_int as libc::c_uint {\n            nsize = if fsize < ssize { fsize } else { ssize };\n        } else if rel_mode as libc::c_uint == rm_rdn as libc::c_int as libc::c_uint {\n            nsize = fsize - fsize % ssize;\n        } else {\n            if rel_mode as libc::c_uint == rm_rup as libc::c_int as libc::c_uint {\n                let mut r: off_t = fsize % ssize;\n                ssize = if r == 0 as libc::c_int as libc::c_long {\n                    0 as libc::c_int as libc::c_long\n                } else {\n                    ssize - r\n                };\n            }\n            let (fresh8, fresh9) = fsize.overflowing_add(ssize);\n            *(&mut nsize as *mut off_t) = fresh8;\n            if fresh9 {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        0 as libc::c_int,\n                        gettext(\n                            b\"overflow extending size of file %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"overflow extending size of file %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"overflow extending size of file %s\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                return 0 as libc::c_int != 0;\n            }\n        }",
        "sub_chunks": [],
        "live_in": [
          "mut fname: *const i8",
          "mut ssize: i64",
          "mut rel_mode: u32",
          "mut nsize: i64",
          "__errstatus: i32",
          "mut fsize: i64"
        ],
        "live_out": [
          "mut fname: *const i8",
          "mut ssize: i64",
          "mut rel_mode: u32",
          "mut nsize: i64",
          "__errstatus: i32",
          "mut fsize: i64"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/truncate.rs:444:5: 997:34 (#0)",
        "pieces": [
          "src/truncate.rs:444:5: 508:8 (#0)",
          "src/truncate.rs:884:1: 886:8 (#0)",
          "src/truncate.rs:913:1: 913:8 (#0)",
          "src/truncate.rs:938:1: 997:34 (#0)"
        ],
        "num_lines": 129,
        "source": "let mut sb: stat = stat {\n        st_dev: 0,\n        st_ino: 0,\n        st_mode: 0,\n        st_nlink: 0,\n        st_uid: 0,\n        st_gid: 0,\n        st_rdev: 0,\n        __pad1: 0,\n        st_size: 0,\n        st_blksize: 0,\n        __pad2: 0,\n        st_blocks: 0,\n        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n        __glibc_reserved: [0; 2],\n    };\n    let mut nsize: off_t = 0;\n    if (block_mode as libc::c_int != 0\n        || rel_mode as libc::c_uint != 0 && rsize < 0 as libc::c_int as libc::c_long)\n        && fstat(fd, &mut sb) != 0 as libc::c_int\n    {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                quotearg_style(shell_escape_always_quoting_style, fname),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(b\"cannot fstat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    if block_mode {\n       <<chunk 4>>    }\n    if rel_mode as u64 != 0 {\n       <<chunk 5>>       <<chunk 6>>    } else {\n        nsize = ssize;\n    }\n    if nsize < 0 as libc::c_int as libc::c_long {\n        nsize = 0 as libc::c_int as off_t;\n    }\n    if ftruncate(fd, nsize) != 0 as libc::c_int {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                *__errno_location(),\n                gettext(\n                    b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quotearg_style(shell_escape_always_quoting_style, fname),\n                nsize,\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                    nsize,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    *__errno_location(),\n                    gettext(\n                        b\"failed to truncate %s at %jd bytes\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, fname),\n                    nsize,\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        return 0 as libc::c_int != 0;\n    }\n    return 1 as libc::c_int != 0;",
        "sub_chunks": [
          4,
          5,
          6
        ],
        "live_in": [
          "mut fd: i32",
          "mut fname: *const i8",
          "mut ssize: i64",
          "mut rsize: i64",
          "mut rel_mode: u32",
          "__errstatus: i32"
        ],
        "live_out": [
          "mut fd: i32",
          "mut fname: *const i8",
          "mut ssize: i64",
          "mut rsize: i64",
          "mut rel_mode: u32",
          "mut sb: stat",
          "mut nsize: i64",
          "__errstatus: i32"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:111 ~ truncate[c51a]::main_0)",
    "span": "src/truncate.rs:999:1: 1515:2 (#0)",
    "pieces": [
      "src/truncate.rs:999:1: 1003:4 (#0)",
      "src/truncate.rs:1286:1: 1286:4 (#0)",
      "src/truncate.rs:1428:1: 1428:4 (#0)",
      "src/truncate.rs:1437:1: 1437:4 (#0)",
      "src/truncate.rs:1489:1: 1489:4 (#0)",
      "src/truncate.rs:1515:1: 1515:2 (#0)"
    ],
    "sub_chunks": [
      4,
      5,
      6,
      7,
      8
    ],
    "num_lines": 10,
    "source": "unsafe fn main_0(\n    mut argc: libc::c_int,\n    mut argv: *mut *mut libc::c_char,\n) -> libc::c_int {\n   <<chunk 4>>   <<chunk 5>>   <<chunk 6>>   <<chunk 7>>   <<chunk 8>>}",
    "calls": [
      {
        "caller": "DefId(0:127 ~ truncate[c51a]::main)",
        "span": "src/truncate.rs:1527:18: 1527:82 (#0)",
        "source": "unsafe { main_0(argc, argv.as_ptr() as *mut *mut libc::c_char) }"
      }
    ],
    "globals": [
      {
        "span": "src/truncate.rs:215:1: 215:64 (#0)",
        "source": "pub const shell_escape_always_quoting_style: quoting_style = 4;"
      },
      {
        "span": "src/truncate.rs:223:1: 223:34 (#0)",
        "source": "pub const rm_max: rel_mode_t = 3;"
      },
      {
        "span": "src/truncate.rs:324:1: 324:69 (#0)",
        "source": "static mut ref_file: *const libc::c_char = 0 as *const libc::c_char;"
      },
      {
        "span": "src/truncate.rs:226:1: 226:34 (#0)",
        "source": "pub const rm_abs: rel_mode_t = 0;"
      },
      {
        "span": "src/truncate.rs:323:1: 323:37 (#0)",
        "source": "static mut block_mode: bool = false;"
      },
      {
        "span": "src/truncate.rs:222:1: 222:34 (#0)",
        "source": "pub const rm_rdn: rel_mode_t = 4;"
      },
      {
        "span": "src/truncate.rs:225:1: 225:34 (#0)",
        "source": "pub const rm_rel: rel_mode_t = 1;"
      },
      {
        "span": "src/truncate.rs:221:1: 221:34 (#0)",
        "source": "pub const rm_rup: rel_mode_t = 5;"
      },
      {
        "span": "src/truncate.rs:325:1: 389:3 (#0)",
        "source": "static mut longopts: [option; 7] = [\n    {\n        let mut init = option {\n            name: b\"no-create\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'c' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"io-blocks\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'o' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"reference\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 'r' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"size\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 1 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 's' as i32,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"help\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_HELP_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: b\"version\\0\" as *const u8 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: GETOPT_VERSION_CHAR as libc::c_int,\n        };\n        init\n    },\n    {\n        let mut init = option {\n            name: 0 as *const libc::c_char,\n            has_arg: 0 as libc::c_int,\n            flag: 0 as *const libc::c_int as *mut libc::c_int,\n            val: 0 as libc::c_int,\n        };\n        init\n    },\n];"
      },
      {
        "span": "src/truncate.rs:224:1: 224:34 (#0)",
        "source": "pub const rm_min: rel_mode_t = 2;"
      },
      {
        "span": "src/truncate.rs:322:1: 322:36 (#0)",
        "source": "static mut no_create: bool = false;"
      }
    ],
    "imports": [
      {
        "span": "src/truncate.rs:23:1: 23:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/truncate.rs:20:1: 20:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/truncate.rs:18:1: 18:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/truncate.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/truncate.rs:17:1: 17:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/truncate.rs:21:1: 21:20 (#0)",
        "source": "use std::io::Write;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/truncate.rs:1038:17: 1154:19 (#0)",
        "pieces": [
          "src/truncate.rs:1038:17: 1154:19 (#0)"
        ],
        "num_lines": 117,
        "source": "while *(*__ctype_b_loc())\n                    .offset(to_uchar(*optarg) as libc::c_int as isize) as libc::c_int\n                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n                {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                match *optarg as libc::c_int {\n                    60 => {\n                        rel_mode = rm_max;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    62 => {\n                        rel_mode = rm_min;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    47 => {\n                        rel_mode = rm_rdn;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    37 => {\n                        rel_mode = rm_rup;\n                        optarg = optarg.offset(1);\n                        optarg;\n                    }\n                    _ => {}\n                }\n                while *(*__ctype_b_loc())\n                    .offset(to_uchar(*optarg) as libc::c_int as isize) as libc::c_int\n                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0\n                {\n                    optarg = optarg.offset(1);\n                    optarg;\n                }\n                if *optarg as libc::c_int == '+' as i32\n                    || *optarg as libc::c_int == '-' as i32\n                {\n                    if rel_mode as u64 != 0 {\n                        if 0 != 0 {\n                            error(\n                                0 as libc::c_int,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"multiple relative modifiers specified\\0\" as *const u8\n                                        as *const libc::c_char,\n                                ),\n                            );\n                            if 0 as libc::c_int != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                        } else {\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multiple relative modifiers specified\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                            ({\n                                let __errstatus: libc::c_int = 0 as libc::c_int;\n                                error(\n                                    __errstatus,\n                                    0 as libc::c_int,\n                                    gettext(\n                                        b\"multiple relative modifiers specified\\0\" as *const u8\n                                            as *const libc::c_char,\n                                    ),\n                                );\n                                if __errstatus != 0 as libc::c_int {\n                                    unreachable!();\n                                } else {};\n                                \n                            });\n                        };\n                        usage(1 as libc::c_int);\n                    }\n                    rel_mode = rm_rel;\n                }\n                size = xdectoimax(\n                    optarg,\n                    !if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                        -(1 as libc::c_int) as off_t\n                    } else {\n                        (((1 as libc::c_int as off_t)\n                            << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long\n                    },\n                    if (0 as libc::c_int as off_t) < -(1 as libc::c_int) as off_t {\n                        -(1 as libc::c_int) as off_t\n                    } else {\n                        (((1 as libc::c_int as off_t)\n                            << (::core::mem::size_of::<off_t>() as libc::c_ulong)\n                                .wrapping_mul(8 as libc::c_int as libc::c_ulong)\n                                .wrapping_sub(2 as libc::c_int as libc::c_ulong))\n                            - 1 as libc::c_int as libc::c_long)\n                            * 2 as libc::c_int as libc::c_long\n                            + 1 as libc::c_int as libc::c_long\n                    },\n                    b\"EgGkKmMPQRtTYZ0\\0\" as *const u8 as *const libc::c_char,\n                    gettext(b\"Invalid number\\0\" as *const u8 as *const libc::c_char),\n                    0 as libc::c_int,\n                );",
        "sub_chunks": [],
        "live_in": [
          "mut size: i64",
          "mut rel_mode: u32"
        ],
        "live_out": [
          "mut size: i64",
          "mut rel_mode: u32"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/truncate.rs:1155:17: 1187:17 (#0)",
        "pieces": [
          "src/truncate.rs:1155:17: 1187:17 (#0)"
        ],
        "num_lines": 47,
        "source": "if (rel_mode as libc::c_uint == rm_rup as libc::c_int as libc::c_uint\n                    || rel_mode as libc::c_uint == rm_rdn as libc::c_int as libc::c_uint)\n                    && size == 0 as libc::c_int as libc::c_long\n                {\n                    if 0 != 0 {\n                        error(\n                            1 as libc::c_int,\n                            0 as libc::c_int,\n                            gettext(\n                                b\"division by zero\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                        );\n                        if 1 as libc::c_int != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                    } else {\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"division by zero\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                        ({\n                            let __errstatus: libc::c_int = 1 as libc::c_int;\n                            error(\n                                __errstatus,\n                                0 as libc::c_int,\n                                gettext(\n                                    b\"division by zero\\0\" as *const u8 as *const libc::c_char,\n                                ),\n                            );\n                            if __errstatus != 0 as libc::c_int {\n                                unreachable!();\n                            } else {};\n                            \n                        });\n                    };\n                }\n                got_size = 1 as libc::c_int != 0;",
        "sub_chunks": [],
        "live_in": [
          "mut got_size: bool",
          "mut size: i64",
          "mut rel_mode: u32"
        ],
        "live_out": [
          "mut got_size: bool",
          "mut size: i64",
          "mut rel_mode: u32"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/truncate.rs:1194:17: 1205:23 (#0)",
        "pieces": [
          "src/truncate.rs:1194:17: 1205:23 (#0)"
        ],
        "num_lines": 12,
        "source": "version_etc(\n                    stdout,\n                    b\"truncate\\0\" as *const u8 as *const libc::c_char,\n                    b\"GNU coreutils\\0\" as *const u8 as *const libc::c_char,\n                    Version,\n                    proper_name_lite(\n                        b\"Padraig Brady\\0\" as *const u8 as *const libc::c_char,\n                        b\"P\\xC3\\xA1draig Brady\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    0 as *mut libc::c_void as *mut libc::c_char,\n                );\n                exit(0 as libc::c_int);",
        "sub_chunks": [],
        "live_in": [],
        "live_out": []
      },
      {
        "chunk_id": 3,
        "span": "src/truncate.rs:1017:9: 1211:10 (#0)",
        "pieces": [
          "src/truncate.rs:1017:9: 1038:16 (#0)",
          "src/truncate.rs:1155:1: 1155:16 (#0)",
          "src/truncate.rs:1189:1: 1194:16 (#0)",
          "src/truncate.rs:1207:1: 1211:10 (#0)"
        ],
        "num_lines": 34,
        "source": "c = getopt_long(\n            argc,\n            argv,\n            b\"cor:s:\\0\" as *const u8 as *const libc::c_char,\n            longopts.as_ptr(),\n            0 as *mut libc::c_int,\n        );\n        if !(c != -(1 as libc::c_int)) {\n            break;\n        }\n        match c {\n            99 => {\n                no_create = 1 as libc::c_int != 0;\n            }\n            111 => {\n                block_mode = 1 as libc::c_int != 0;\n            }\n            114 => {\n                ref_file = optarg;\n            }\n            115 => {\n               <<chunk 0>>               <<chunk 1>>            }\n            -2 => {\n                usage(0 as libc::c_int);\n            }\n            -3 => {\n               <<chunk 2>>            }\n            _ => {\n                usage(1 as libc::c_int);\n            }\n        }",
        "sub_chunks": [
          0,
          1,
          2
        ],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut got_size: bool",
          "mut size: i64",
          "mut rel_mode: u32",
          "mut c: i32"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut got_size: bool",
          "mut size: i64",
          "mut rel_mode: u32",
          "mut c: i32"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/truncate.rs:1003:5: 1285:6 (#0)",
        "pieces": [
          "src/truncate.rs:1003:5: 1017:8 (#0)",
          "src/truncate.rs:1212:1: 1285:6 (#0)"
        ],
        "num_lines": 89,
        "source": "let mut got_size: bool = 0 as libc::c_int != 0;\n    let mut size: off_t = 0 as libc::c_int as off_t;\n    let mut rsize: off_t = -(1 as libc::c_int) as off_t;\n    let mut rel_mode: rel_mode_t = rm_abs;\n    let mut c: libc::c_int = 0;\n    set_program_name(*argv.offset(0 as libc::c_int as isize));\n    setlocale(6 as libc::c_int, b\"\\0\" as *const u8 as *const libc::c_char);\n    bindtextdomain(\n        b\"coreutils\\0\" as *const u8 as *const libc::c_char,\n        b\"/usr/local/share/locale\\0\" as *const u8 as *const libc::c_char,\n    );\n    textdomain(b\"coreutils\\0\" as *const u8 as *const libc::c_char);\n    atexit(Some(close_stdout as unsafe extern \"C\" fn() -> ()));\n    loop {\n       <<chunk 3>>    }\n    argv = argv.offset(optind as isize);\n    argc -= optind;\n    if ref_file.is_null() && !got_size {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"you must specify either %s or %s\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote_n(\n                    1 as libc::c_int,\n                    b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify either %s or %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify either %s or %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }",
        "sub_chunks": [
          3
        ],
        "live_in": [
          "mut argc: i32",
          "mut argv: *mut *mut i8"
        ],
        "live_out": [
          "mut argc: i32",
          "mut argv: *mut *mut i8",
          "mut got_size: bool",
          "mut size: i64",
          "mut rsize: i64",
          "mut rel_mode: u32",
          "mut c: i32"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/truncate.rs:1286:5: 1427:6 (#0)",
        "pieces": [
          "src/truncate.rs:1286:5: 1427:6 (#0)"
        ],
        "num_lines": 142,
        "source": "if !ref_file.is_null() && got_size as libc::c_int != 0 && rel_mode as u64 == 0 {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"you must specify a relative %s with %s\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote_n(\n                    1 as libc::c_int,\n                    b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify a relative %s with %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"you must specify a relative %s with %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--reference\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }\n    if block_mode as libc::c_int != 0 && !got_size {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(\n                    b\"%s was specified but %s was not\\0\" as *const u8\n                        as *const libc::c_char,\n                ),\n                quote_n(\n                    0 as libc::c_int,\n                    b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                ),\n                quote_n(\n                    1 as libc::c_int,\n                    b\"--size\\0\" as *const u8 as *const libc::c_char,\n                ),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s was specified but %s was not\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"%s was specified but %s was not\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quote_n(\n                        0 as libc::c_int,\n                        b\"--io-blocks\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                    quote_n(\n                        1 as libc::c_int,\n                        b\"--size\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut got_size: bool",
          "mut size: i64",
          "mut rel_mode: u32"
        ],
        "live_out": [
          "mut got_size: bool",
          "mut size: i64",
          "mut rel_mode: u32"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/truncate.rs:1428:5: 1435:2 (#0)",
        "pieces": [
          "src/truncate.rs:1428:5: 1435:2 (#0)"
        ],
        "num_lines": 42,
        "source": "if argc < 1 as libc::c_int {\n        if 0 != 0 {\n            error(\n                0 as libc::c_int,\n                0 as libc::c_int,\n                gettext(b\"missing file operand\\0\" as *const u8 as *const libc::c_char),\n            );\n            if 0 as libc::c_int != 0 as libc::c_int {\n                unreachable!();\n            } else {};\n        } else {\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"missing file operand\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n            ({\n                let __errstatus: libc::c_int = 0 as libc::c_int;\n                error(\n                    __errstatus,\n                    0 as libc::c_int,\n                    gettext(\n                        b\"missing file operand\\0\" as *const u8 as *const libc::c_char,\n                    ),\n                );\n                if __errstatus != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n                \n            });\n        };\n        usage(1 as libc::c_int);\n    }",
        "sub_chunks": [],
        "live_in": [
          "mut argc: i32"
        ],
        "live_out": [
          "mut argc: i32"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/truncate.rs:1437:5: 1487:55 (#0)",
        "pieces": [
          "src/truncate.rs:1437:5: 1487:55 (#0)"
        ],
        "num_lines": 142,
        "source": "if !ref_file.is_null() {\n        let mut sb: stat = stat {\n            st_dev: 0,\n            st_ino: 0,\n            st_mode: 0,\n            st_nlink: 0,\n            st_uid: 0,\n            st_gid: 0,\n            st_rdev: 0,\n            __pad1: 0,\n            st_size: 0,\n            st_blksize: 0,\n            __pad2: 0,\n            st_blocks: 0,\n            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },\n            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },\n            __glibc_reserved: [0; 2],\n        };\n        let mut file_size: off_t = -(1 as libc::c_int) as off_t;\n        if stat(ref_file, &mut sb) != 0 as libc::c_int {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(b\"cannot stat %s\\0\" as *const u8 as *const libc::c_char),\n                    quotearg_style(shell_escape_always_quoting_style, ref_file),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"cannot stat %s\\0\" as *const u8 as *const libc::c_char),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(b\"cannot stat %s\\0\" as *const u8 as *const libc::c_char),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if usable_st_size(&mut sb) {\n            file_size = sb.st_size;\n        } else {\n            let mut ref_fd: libc::c_int = open(ref_file, 0 as libc::c_int);\n            if 0 as libc::c_int <= ref_fd {\n                let mut file_end: off_t = lseek(\n                    ref_fd,\n                    0 as libc::c_int as __off_t,\n                    2 as libc::c_int,\n                );\n                let mut saved_errno: libc::c_int = *__errno_location();\n                close(ref_fd);\n                if 0 as libc::c_int as libc::c_long <= file_end {\n                    file_size = file_end;\n                } else {\n                    *__errno_location() = saved_errno;\n                }\n            }\n        }\n        if file_size < 0 as libc::c_int as libc::c_long {\n            if 0 != 0 {\n                error(\n                    1 as libc::c_int,\n                    *__errno_location(),\n                    gettext(\n                        b\"cannot get the size of %s\\0\" as *const u8\n                            as *const libc::c_char,\n                    ),\n                    quotearg_style(shell_escape_always_quoting_style, ref_file),\n                );\n                if 1 as libc::c_int != 0 as libc::c_int {\n                    unreachable!();\n                } else {};\n            } else {\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot get the size of %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n                ({\n                    let __errstatus: libc::c_int = 1 as libc::c_int;\n                    error(\n                        __errstatus,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot get the size of %s\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, ref_file),\n                    );\n                    if __errstatus != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                    \n                });\n            };\n        }\n        if !got_size {\n            size = file_size;\n        } else {\n            rsize = file_size;\n        }\n    }\n    let mut oflags: libc::c_int = 0o1 as libc::c_int\n        | (if no_create as libc::c_int != 0 {\n            0 as libc::c_int\n        } else {\n            0o100 as libc::c_int\n        }) | 0o4000 as libc::c_int;\n    let mut errors: bool = 0 as libc::c_int != 0;\n    let mut fname: *const libc::c_char = 0 as *const libc::c_char;",
        "sub_chunks": [],
        "live_in": [
          "mut got_size: bool",
          "mut size: i64",
          "mut rsize: i64"
        ],
        "live_out": [
          "mut got_size: bool",
          "mut size: i64",
          "mut rsize: i64",
          "oflags: i32",
          "mut errors: bool",
          "mut fname: *const i8"
        ]
      },
      {
        "chunk_id": 8,
        "span": "src/truncate.rs:1489:5: 1513:35 (#0)",
        "pieces": [
          "src/truncate.rs:1489:5: 1513:35 (#0)"
        ],
        "num_lines": 122,
        "source": "loop {\n        fname = *argv;\n        if fname.is_null() {\n            break;\n        }\n        let mut fd: libc::c_int = open(\n            fname,\n            oflags,\n            0o400 as libc::c_int | 0o200 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int\n                | 0o400 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int\n                | 0o200 as libc::c_int >> 3 as libc::c_int >> 3 as libc::c_int,\n        );\n        if fd < 0 as libc::c_int {\n            if !(no_create as libc::c_int != 0\n                && *__errno_location() == 2 as libc::c_int)\n            {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"cannot open %s for writing\\0\" as *const u8\n                                as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot open %s for writing\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"cannot open %s for writing\\0\" as *const u8\n                                    as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                errors = 1 as libc::c_int != 0;\n            }\n        } else {\n            errors = (errors as libc::c_int\n                | !do_ftruncate(fd, fname, size, rsize, rel_mode) as libc::c_int) != 0;\n            if close(fd) != 0 as libc::c_int {\n                if 0 != 0 {\n                    error(\n                        0 as libc::c_int,\n                        *__errno_location(),\n                        gettext(\n                            b\"failed to close %s\\0\" as *const u8 as *const libc::c_char,\n                        ),\n                        quotearg_style(shell_escape_always_quoting_style, fname),\n                    );\n                    if 0 as libc::c_int != 0 as libc::c_int {\n                        unreachable!();\n                    } else {};\n                } else {\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to close %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                    ({\n                        let __errstatus: libc::c_int = 0 as libc::c_int;\n                        error(\n                            __errstatus,\n                            *__errno_location(),\n                            gettext(\n                                b\"failed to close %s\\0\" as *const u8 as *const libc::c_char,\n                            ),\n                            quotearg_style(shell_escape_always_quoting_style, fname),\n                        );\n                        if __errstatus != 0 as libc::c_int {\n                            unreachable!();\n                        } else {};\n                        \n                    });\n                };\n                errors = 1 as libc::c_int != 0;\n            }\n        }\n        argv = argv.offset(1);\n        argv;\n    }\n    return if errors as libc::c_int != 0 { 1 as libc::c_int } else { 0 as libc::c_int };",
        "sub_chunks": [],
        "live_in": [
          "mut argv: *mut *mut i8",
          "mut size: i64",
          "mut rsize: i64",
          "mut rel_mode: u32",
          "oflags: i32",
          "mut errors: bool",
          "mut fname: *const i8"
        ],
        "live_out": [
          "mut argv: *mut *mut i8"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:96 ~ truncate[c51a]::usable_st_size)",
    "span": "src/truncate.rs:228:1: 232:2 (#0)",
    "pieces": [
      "src/truncate.rs:228:1: 232:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "unsafe extern \"C\" fn usable_st_size(mut sb: *const stat) -> bool {\n    return (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n        == 0o100000 as libc::c_int as libc::c_uint\n        || (*sb).st_mode & 0o170000 as libc::c_int as libc::c_uint\n            == 0o120000 as libc::c_int as libc::c_uint\n        || ((*sb).st_mode).wrapping_sub((*sb).st_mode) != 0 || 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:21:1: 21:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/truncate.rs:23:1: 23:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/truncate.rs:17:1: 17:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/truncate.rs:18:1: 18:18 (#0)",
        "source": "use std::process;"
      },
      {
        "span": "src/truncate.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/truncate.rs:20:1: 20:20 (#0)",
        "source": "use std::ffi::CStr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:113 ~ truncate[c51a]::main)",
    "span": "src/truncate.rs:1516:1: 1529:2 (#0)",
    "pieces": [
      "src/truncate.rs:1516:1: 1529:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 19,
    "source": "pub fn main() {\n    let mut args: Vec::<*mut libc::c_char> = Vec::new();\n    for arg in ::std::env::args() {\n        args.push(\n            (::std::ffi::CString::new(arg))\n                .expect(\"Failed to convert argument into CString.\")\n                .into_raw(),\n        );\n    }\n    args.push(::core::ptr::null_mut());\n    unsafe {\n        ::std::process::exit(\n            main_0(\n                (args.len() - 1) as libc::c_int,\n                args.as_mut_ptr() as *mut *mut libc::c_char,\n            ) as i32,\n        )\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/truncate.rs:21:1: 21:20 (#0)",
        "source": "use std::io::Write;"
      },
      {
        "span": "src/truncate.rs:17:1: 17:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/truncate.rs:16:1: 16:23 (#0)",
        "source": "use std::ffi::CString;"
      },
      {
        "span": "src/truncate.rs:20:1: 20:20 (#0)",
        "source": "use std::ffi::CStr;"
      },
      {
        "span": "src/truncate.rs:23:1: 23:15 (#0)",
        "source": "use ::rust::*;"
      },
      {
        "span": "src/truncate.rs:18:1: 18:18 (#0)",
        "source": "use std::process;"
      }
    ],
    "chunks": []
  }
]